---
title: 'Java의 ORM 표준 기술, JPA'
subtitle: '객체와 관계형 DB의 조화를 위한 기나긴 여정'
date: 2023-07-05 01:35:00
category: 'JPA'
---

## JPA?

제가 주력으로 사용하는 프로그래밍 언어는 **Java**입니다. 대표적인 객체지향 언어이며, 우리나라 뿐만 아니라 전세계적으로 많이 사용되고 있습니다. 또한, **Spring 프레임워크**의 등장으로 정말 객체지향다운 객체지향 프로그래밍을 하면서도 쉽고 빠르게 웹 어플리케이션 개발이 가능해졌습니다. 백엔드 개발자를 꿈꾸는 저 역시, Spring 프레임워크와 Spring의 여러 하위 프로젝트들을 공부하면서 객체지향 프로그래밍에 대해 더 깊게 공부할 수 있었습니다.

그런데 첫 팀 프로젝트를 진행하며, 한가지 난관에 봉착했었습니다. 객체를 다루며 프로그래밍하는 것은 어느 정도 익숙해졌는데, 가공한 객체(데이터)를 영구히 저장할 방법을 잘 알지 못했습니다. 동아리 스터디 시간에 당장 구현해서 사용할 수 있도록 얉게 학습한 **Spring Data JPA**을 열심히 구글링해가며 프로젝트를 완성했습니다. 하지만 잘 알지 못한 채로 사용해 웹 어플리케이션의 성능은 썩 좋지 못했습니다.

프로젝트가 끝난 후, Spring Data JPA가 **JPA**(Java Persistence API)를 쉽게 다룰 수 있게 해주는 프로젝트임을 어렴풋이 알고 있었기에 JPA에 대해 본격적으로 공부하고자 했습니다. JPA가 **ORM**(Object Relational Mapping) 기술의 Java 진영 표준이라는 설명을 읽고 처음 든 생각은 **ORM이 도대체 무엇인가**였습니다.

## SQL 중심 개발의 문제점

ORM 기술에 대해 공부하기 위해서는 먼저 객체와 관계형 데이터베이스의 차이에 대해서 알아야 했습니다. NoSQL 데이터베이스를 사용하는게 아닌 이상, 우리가 Java와 같은 객체지향 프로그래밍 언어를 통해 객체를 생성한 후, 이를 관계형 데이터베이스에 저장해야 합니다. 어떠한 객체도 데이터베이스에 저장하지 못한다면 어플리케이션을 사용할 수도 없고 사용할 필요도 없기 때문이죠.

그런데, 객체를 관계형 데이터베이스에 바로 저장할 수는 없습니다. 객체 안에는 많은 속성들이 있고 상속관계, 연관관계 등, 다른 객체와의 복잡한 관계가 있을 수 있습니다. 심지어는 여러 객체를 가지고 하나의 객체로 묶어두는 컬렉션 객체도 있습니다.

ORM 기술이 없다면, **CRUD**라고 불리는 등록, 조회, 수정, 삭제 연산들을 위한 SQL을 작성하기 위해서 먼저 Java 객체를 SQL로, SQL을 Java 객체로 전환하는 코드를 **직접** 작성해야 했습니다. 거기다 객체에 속성이라도 추가된다면 기껏 작성해놓은 SQL을 몽땅 수정해야하는 불상사가 일어나기도 했습니다.

```java
// 만약 객체에 속성을 하나 추가한다면?
public class Member {
    private String memberId;
    private String name;
    ...
}
```

```SQL
# 이 SQL 쿼리도 수정해야 한다.
INSERT INTO MEMBER(MEMBER_ID, NAME) VALUES SELECT MEMBER_ID, NAME FROM MEMBER M
UPDATE MEMBER SET ...
```

즉, SQL에 의존적인 개발이 피하기 어려웠습니다. 다형성을 통한 유연한 확장이 장점인 객체지향 프로그래밍인데, 객체 데이터를 저장하려면 SQL에 의존적인 개발이 불가피한, 가장 중요한 객체지향의 원칙이 깨지는 문제가 발생한 것입니다.

## 객체와 관계형 데이터베이스의 차이

이렇게 치명적인 문제를 가지고 있는 SQL 중심의 개발을 할 수 밖에 없었던 이유는 **객체와 관계형 데이터베이스의 패러다임 불일치**에 있습니다. 객체는 어쨌든 관계형 데이터베이스에 저장하기 위해서 SQL로 변환해야 하는데, 이 작업을 모두 개발자가 해야 했기 때문에 SQL에 의존적일 수 밖에 없었습니다. 그럼 객체와 관계형 데이터베이스가 얼마나 차이가 나길래 개발자가 객체를 SQL로 매핑하느라 바빠진 것일까요?

### 객체 VS 관계형데이터베이스 - 상속

패러다임 불일치 중 첫 번째는 **상속**입니다. 객체지향 프로그래밍에서 너무나 중요하고 핵심적인 개념인 **상속은 관계형 데이터베이스에 존재하지 않습니다**. 분명히 객체는 상속관계를 가지고 있는데 관계형 데이터베이스에는 상속이라는 개념이 없다보니 상속관계의 객체를 저장하기 위해서는 특수한 방법을 이용해야 합니다.

<img width="1292" alt="objectrdbdiff" src="https://github.com/hangillee/coderoad.kr/assets/14046092/ecbaa265-dc84-47f7-b4ee-1e28f2df5d62">

<div align="center"><I>관계형 데이터베이스에서는 상속관계 대신 슈퍼타입 서브타입 관계를 사용한다.</I></div>
<br>

대표적으로 **슈퍼타입 서브타입 관계**라는 설계 기법을 통해 상속관계를 유사하게 표현하지만, 이것을 객체의 상속과 동일하다고 볼 수 없습니다. 슈퍼타입과 서브타입 테이블은 엄밀히 말하자면 서로 다른 테이블이고 상속관계의 객체가 이 테이블을 조회할 때 `JOIN` 연산으로 하나로 묶어서 결과를 반환하는 것일 뿐입니다.

부모 객체에 대한 자식 객체가 하나라면 `JOIN` 연산 쿼리 작성은 큰 문제는 아니겠지만, 자식 객체를 통해 유연하게 확장(다형성)하는 것이 객체지향 프로그래밍을 생각한다면 어림도 없는 이야기입니다. 당연히 이 연산을 위한 SQL 쿼리 작성과 객체와 SQL의 변환 코드는 모두 개발자가 직접 해야 합니다.

객체를 저장하는 것 역시 쉽지 않은 작업입니다. 객체 데이터를 저장할 때는 슈퍼타입과 서브타입 테이블 두 곳 모두에 자식 객체를 분해해서 각 테이블에 맞는 속성을 저장합니다. 즉, 하나의 객체를 저장하는데 두 테이블에 SQL 쿼리가 날아가는 것입니다.

```sql
# 부모 객체로 부터 상속 받은 속성은 슈퍼타입 테이블에
INSERT INTO ITEM ...
# 자식만의 속성은 서브타입 테이블에
INSERT INTO ALBUM ...
```

상속이 자식 객체가 부모 객체의 속성을 물려받아서 자유자재로 다룰 수 있는 것과는 분명 차이가 존재합니다. 그래서 DB에 저장할 객체에는 상속 관계를 사용하지 않습니다.

### 객체 VS 관계형 데이터베이스 - 연관관계

객체와 관계형 데이터베이스의 두 번째 불일치는 **연관관계**입니다. 연관관계는 서로 다른 두 객체가 **참조**를 통해 연결되는 것을 말합니다. 다행히도 데이터베이스 테이블 역시, **외래 키**를 통한 `JOIN` 연산을 활용하면 연관관계를 가질 수 있습니다. 그런데, 참조와 외래 키는 엄연히 다른 개념입니다. 참조는 다른 객체의 주소를 갖는 것과 마찬가지입니다. 따라서, 객체의 참조를 가져오는 것은 객체 그 자체를 가져오는 것이라고 볼 수 있습니다.

```java
// Team 객체를 향한 참조 존재. Team 객체와 연관관계를 맺음.
class Member {
    String id;
    Team team;
    String username;
    ...
}
```

```java
// team은 member와 연관관계를 맺는 Team 객체 그 자체를 가리킨다.
Team team = member.getTeam();
```

문제는 관계형 데이터베이스가 **객체를 객체 그 자체로 저장할 수 없다**는 것입니다. DB 테이블은 연관관계를 위해 외래 키를 가지고 있어야 하고, 이 외래 키를 통해 다른 테이블과 `JOIN`한 후, 데이터를 가져와야 합니다. 외래 키가 없다면 연관관계를 절대 표현할 수 없고, 연관관계를 가진 객체를 저장할 방법도 없습니다. 결국, 이러한 관계형 데이터베이스 테이블의 한계 때문에 객체를 테이블에 맞춰서 모델링해야 합니다.

```java
class Member {
    String id;
    Long teamId; // 외래 키
    String username;
}
```

이렇게 테이블에 맞춰서 객체를 모델링하면 데이터베이스에 객체를 저장하는 것은 간단해지지만, **이런 모델링은 전혀 객제지향스럽지 않은 모델링**입니다. 객체는 참조로 연관관계를 맺어야 하는데, 객체의 특정 속성을 통해 연관관계를 맺어야 하는 상황이 벌어졌습니다. 물론, 참조를 이용해 객체를 모델링하고 테이블에 저장할 때만 `team.getId()`와 같은 과정을 추가로 거쳐 SQL을 잘 작성하면 객체다운 모델링이 가능하지만, 이런 과정 자체가 번거롭고 실수하기 쉬운 작업입니다!

### 객체 VS 관계형 데이터베이스 - 객체 그래프 탐색

객체와 관계형 데이터베이스의 세 번째 불일치는 **객체 그래프 탐색**입니다. 객체는 자유롭게 객체 그래프를 탐색할 수 있어야 합니다. 즉, 객체는 **참조**를 통해서 여러 객체를 넘나들며 원하는 작업을 수행할 수 있어야 합니다. 문제는 데이터베이스의 경우, 처음 실행하는 SQL에 따라 탐색 범위가 결정되어버린다는 것입니다.

<img width="805" alt="objectgraph" src="https://github.com/hangillee/coderoad.kr/assets/14046092/96b19326-bce2-481a-879e-6974f639903c">

<div align="center"><I>객체는 이런 객체 그래프를 자유롭게 탐색할 수 있다.</I></div>
<br>

예를 들어, 다음과 같은 SQL을 통해 객체를 조회했을 때는 객체 그래프 탐색이 제한됩니다.

```sql
SELECT M.*, T.*
FROM MEMBER M
JOIN TEAM T ON M.TEAM_ID = T.TEAM_ID
```

```java
member.getTeam();
member.getOrder(); // NULL
```

분명히 위에서 본 객체 그래프에 의하면, `Member`와 `Order`가 연관관계를 갖고 있어 `Member`에서 출발하는 객체 그래프 탐색이 가능해야 합니다. 그러나, SQL에서는 `Team` 테이블과 `JOIN`해서 `Team` 말고는 어떠한 객체도 탐색이 불가능합니다.

이런 객체 그래프 탐색의 제한은 **엔티티 신뢰 문제**를 일으킵니다. 객체 입장에서는 연관관계를 맺은 다른 객체를 전적으로 신뢰하고 사용할 수 있어야 하는데, 작성한 SQL에 따라 결과가 완전히 달라질 수 있다는 큰 위험이 존재하는 것입니다. 즉, 다음과 같은 코드의 결과를 전혀 예측할 수 없다는 것입니다.

```java
class MemberService {
    ...
    public void process() {
        Member member = memberDAO.find(memberId);
        member.getTeam(); // 결과를 예측할 수 없음
        member.getOrder().getDelivery(); //결과를 예측할 수 없음
    }
}
```

이런 신뢰 불가능한 코드는 결국 서비스 로직을 구현하다 말고 `memberDAO` 같이 데이터베이스에 접근하는 객체의 코드를 직접 확인해야 하는 비효율적인 작업이 추가로 필요해집니다. 그렇다고 미리 모든 데이터를 전부 불러와서 준비해두는 것도 문제가 있습니다. 당장 사용하지 않을 객체의 테이블까지 모조리 `JOIN`해 SQL 쿼리 자체가 비대해지고 성능 저하가 발생하면 개선하기 어려워질 수도 있습니다.

이런 문제를 피하기 위해 모든 상황에 대비해 필요한 객체만 가져오는 메소드와 SQL 쿼리를 작성할 수도 있겠지만 여전히 효율적인 방법은 아닙니다.

### 객체 VS 관계형 데이터베이스 - 비교

마지막 객체와 관계형 데이터베이스 간의 불일치는 **비교**입니다. 어쩌면 가장 치명적일 수 있는 차이입니다.

```java
String memberId = "100";
Member member1 = memberDAO.getMember(memberId);
Member member2 = memberDAO.getMember(memberId);

member1 == member2; // false
```

데이터베이스에서 같은 `memberId`를 기준으로 조회해도 비교 시에 두 객체가 서로 다르다는 결과를 반환합니다. 우리는 위의 코드가 데이터베이스에서 같은 데이터를 가져왔다고 생각했지만, 객체 변환 과정에서 **SQL의 결과를 새로운 인스턴스로 생성해서 반환**하기 때문에 객체 입장에서는 전혀 다른 객체인 것입니다. 결론적으로, 우리의 예상과는 전혀 다르게 동작하기 때문에 예기치 못한 오류가 발생할 수도 있는 것입니다.

지금까지 여러 불일치들을 살펴보면 객체답게 객체를 모델링할수록 SQL 매핑 작업만 늘어나는 것을 볼 수 있습니다. 여기서 한 가지 고민을 해볼 수 있습니다. **객체를 Java 컬렉션에 저장하는 것처럼 DB에 저장할 수는 없을까요?** 이런 고민을 해결하기 위해 등장한 기술이 바로 **ORM 기술**, 그 중에서도 Java 진영의 ORM 기술 표준인 **JPA**입니다.

## ORM과 JPA
