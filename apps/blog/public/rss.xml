<?xml version="1.0" ?>
  <rss
    xmlns:dc="http://purl.org/dc/elements/1.1/"
    xmlns:content="http://purl.org/rss/1.0/modules/content/"
    xmlns:atom="http://www.w3.org/2005/Atom"
    version="2.0"
  >
    <channel>
        <title><![CDATA[Coderoad]]></title>
        <link>https://blog.coderoad.kr</link>
        <description>
          <![CDATA[Road to good developer.]]>
        </description>
        <language>en</language>
        <lastBuildDate>2023-07-04</lastBuildDate>
        <item>
    <title><![CDATA[정적 팩토리 메소드]]></title>
    <link>https://blog.coderoad.kr/static-factory-method</link>
    <pubDate>2023-07-04</pubDate>
    <guid isPermaLink="false">https://blog.coderoad.kr/static-factory-method</guid>
    <description>
    <![CDATA[Effective Java 3/E 정리 01]]>
    </description>
    <content:encoded>
      <![CDATA[<blockquote>
<p>생성자 대신 정적 팩토리 메소드를 고려하라</p>
</blockquote>
<h2 id="생성자와-정적-팩토리-메소드" class="heading">생성자와 정적 팩토리 메소드</h2>
<h2 id="정적-팩토리-메소드의-장점" class="heading">정적 팩토리 메소드의 장점</h2>
<h2 id="정적-팩토리-메소드의-단점" class="heading">정적 팩토리 메소드의 단점</h2>
<h2 id="정리" class="heading">정리</h2>]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[MVC Pattern]]></title>
    <link>https://blog.coderoad.kr/mvcpattern</link>
    <pubDate>2023-07-04</pubDate>
    <guid isPermaLink="false">https://blog.coderoad.kr/mvcpattern</guid>
    <description>
    <![CDATA[Java와 Servlet]]>
    </description>
    <content:encoded>
      <![CDATA[]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[객체지향의 사실과 오해]]></title>
    <link>https://blog.coderoad.kr/oop</link>
    <pubDate>2023-06-30</pubDate>
    <guid isPermaLink="false">https://blog.coderoad.kr/oop</guid>
    <description>
    <![CDATA[역할, 책임, 협력 관점에서 본 객체지향]]>
    </description>
    <content:encoded>
      <![CDATA[<h2 id="객체지향의-사실과-오해" class="heading">객체지향의 사실과 오해</h2>
<p>처음 소감을 남길 책은 **'객체지향의 사실과 오해'**입니다. 그렇게 두꺼운 책은 아니지만 꽤 긴 시간을 투자하며 여러번 읽었습니다. 이 책은 Java와 Spring 프레임워크를 공부하는 제게 너무나 중요한 개념인 '객체지향'이란 무엇인가를 쉽고 명확하게 설명합니다. 특히, 저를 포함한 많은 초보 개발자들이 가지고 있을 '객체지향은 <code>class</code>가 중심이다'라는 큰 오해를 완전히 뒤바꿔주는 강력한 책입니다.</p>
<p>... 작성 중</p>]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[GDSC SKHU 해커톤 in F-Lab]]></title>
    <link>https://blog.coderoad.kr/hackathon</link>
    <pubDate>2023-02-01</pubDate>
    <guid isPermaLink="false">https://blog.coderoad.kr/hackathon</guid>
    <description>
    <![CDATA[약 12시간의 개발 마라톤 후기]]>
    </description>
    <content:encoded>
      <![CDATA[<h2 id="주최는-해봤지만-참가는-처음이라" class="heading">주최는 해봤지만, 참가는 처음이라!</h2>
<p>특성화 고등학교를 졸업한 저에게 해커톤은 익숙한 대회입니다. 밤을 새워가며 마라톤처럼 쉬지 않고 프로그래밍 하는 해커톤은 특성화고 학생에게는 꽤 가까이, 그리고 많이 있었습니다. 제 친구들은 고등학생 시절부터 해커톤, 앱잼, 게임잼 가리지 않고 참여했습니다. 당연히 저에게도 여러 해커톤 대회에 참여할 기회는 있었습니다. 그러나 저는 '내가 팀의 짐덩어리가 되면 어떡하지'와 같은 생각으로 지레 겁 먹고 참여하지 않았습니다. 물론 고등학생 때는 지금보다 실력적으로도 떨어졌었고, 어떤 분야를 중점적으로 공부할지도 정하지 못해 다소 방황했었습니다. 지금 생각해보면 오히려 이런 태도가 제 실력 성장을 더디게한 것 같아 아쉽습니다. 누구보다 앞서 나갈 수 있었던 시간을 허투루 보내버린 셈입니다.</p>
<p>그래서 고등학교 3년 동안 하지 못한 것, 대학에서는 꼭 해보자는 마음을 가지고 고민할 것도 없이 개발 동아리에 가입했습니다. 저는 동기나 선배들보다 앞서 고등학교에서 경험한 것들을 공유하며 열심히 활동했고, 결국엔 회장직도 맡았습니다. 제가 회장이 된 해 겨울, 드디어 저는 인생 첫 해커톤에 참여했습니다. 그러나 저는 이번에도 '주최자'이자 '운영진'이라는 핑계로 개발은 커녕 팀에 소속되지도 않았습니다. 제가 그토록 아쉬워했던 경험의 기회를 제가 만들고 제가 걷어차버린 격입니다. 지금 생각해보면 '내 실력이 동아리원들의 기대에 못 미치는 실력이면 어쩌지'라는 두려움에 그런 선택을 했던 것 같습니다. 저는 또 다시 후회할 행동을 한 것입니다. 의외로 동아리원들은 제 실력에 별 생각이 없었고, 저 혼자 남 눈치를 보며 소중한 기회를 잃어버렸습니다.</p>
<p>그래서 저는 이번 GDSC 겨울 해커톤이 처음 "제대로" 참가하는 해커톤이었습니다. 저보다 뛰어나거나 저와 비슷한 수준의 개발 실력을 갖춘 사람들과 밤새 협업하면서 고민하고 토론하는 첫 기회였기에 기대도 됐고 긴장도 됐습니다. 이번엔 직접 팀에 참가했고, 팀의 리더를 맡아 주도적으로 프로젝트를 이끌었습니다. 팀원 모두 의욕이 가득했고, 해커톤은 활기찬 분위기 속에 시작됐습니다.</p>
<h2 id="코딩-올-나잇" class="heading">코딩 올 나잇</h2>
<p>이번 해커톤은 개발자 멘토링 서비스 기업 <a href="https://f-lab.kr/?utm_source=gdn&#x26;utm_medium=sa&#x26;utm_campaign=mentee&#x26;utm_content=mentoring&#x26;utm_term=&#x26;gad=1&#x26;gclid=CjwKCAjwjMiiBhA4EiwAZe6jQzLzQwsWxl_JmBl6eD_elDyRf7yHzubwZqbkEw3C8ioFkobBFwHXsBoCIEsQAvD_BwE" target="_blank" rel="noopener noreferer">F-Lab</a>에서 해커톤 장소와 맛있는 야식을 후원해주셨습니다. 23년 1월 27일, 추운 겨울 바람을 뚫고 F-Lab 사무실에서 모인 GDSC 멤버들은 후원사 연설과 간단한 브리핑을 들은 후, 팀 빌딩 과정을 거쳐 본격적인 해커톤을 시작했습니다. 프론트엔드 담당 2명, 백엔드 담당 2명으로 이루어진 팀이 구성되었고 백엔드 파트 코어 멤버였던 저는 자연스럽게 백엔드 개발자로 참여했습니다. 개발을 시작하기에 앞서, 다른 백엔드 멤버와 각자 책임지고 개발할 영역을 나누고 시간 계획을 세웠습니다. 개발에 주어진 시간이 그리 넉넉하지 않아 시간이 낭비되지 않게 해야 했습니다. 또한, 틈틈히 페어 프로그래밍하며 코드 컨벤션을 통일하고 서로의 코드를 바로 이해해가며 최대한 시간을 효율적으로 사용하며 협업했습니다. 다행히 GDSC 백엔드 파트에선 멤버 모두 Spring 프레임워크를 함께 스터디했기 때문에 이번 프로젝트에서 사용할 기술 스택은 큰 어려움 없이 빠르게 결정할 수 있었습니다.</p>
<p><img src="https://github.com/hangillee/kotlin-practice/assets/14046092/72afd62f-6e3b-4b25-b82a-ad5c67771c78" alt="hackathon01"></p>
<div align="center"><I>서비스 개발 계획에 대해 발표하는 나</I></div>
<p>개발 준비를 모두 마치고 약 12시간 동안 Spring Boot 뿐만 아니라 Spring Data JPA, Spring Security 등, 다양한 Spring 프레임워크 생태계의 프로젝트들을 통해 열심히 웹 어플리케이션 서버(WAS)를 구축해나갔습니다. 이번에 저와 제 팀원들이 기획한 서비스는 소비 기록을 통해 소비 습관 조언 서비스, "달빗"이었습니다. 사용자가 한 달, 혹은 하루에 쓸 수 있는 금액의 한도를 정해두고 매일 가계부를 작성하면 예산 초과 여부에 따라 다양한 소비 습관 개선 방법을 제안하는 서비스입니다. 이 서비스를 구현하면서 가장 어려웠던 점은 "날마다 작성할 가계부를 어떻게 데이터베이스에 저장할 것인가?"였습니다. Spring을 공부하면서 예제로 다뤘던 상품 주문 서비스나 게시판 서비스와는 다르게 년, 월, 일, 예산 등, 다양한 기준으로 조회가 가능해야했고, 프론트엔드 페이지가 달력으로 구성되어 있기 때문에 한 번에 여러 데이터를 조회해야 했습니다. 덕분에 엔티티 클래스에 작성한 필드가 상당히 많아져 제대로 하고 있는게 맞는지 헷갈리기도 했습니다. 그래도 프론트엔드 팀원들과 소비 내역을 어떻게 화면에 그릴 것인지 충분히 상의하고, 프론트엔드 팀원들의 기술 수준과 요구 사항에 맞춰 데이터베이스를 구축한 후, API를 구현하는데 성공했고, 야식을 먹기 전까지는 순조롭게 완성될 것이라 생각했습니다.</p>
<p><img src="https://github.com/hangillee/kotlin-practice/assets/14046092/5f95bb29-3d0a-46eb-a9ba-b651aecb3af0" alt="hackathon02"></p>
<div align="center"><I>이 사진이 찍힐 때까지는 여유로웠지만...</I></div>
<p>그러나 프론트엔드와 백엔드 간의 통신에서 예상치 못한 오류가 발생했고, 마감 기한 1시간 전까지도 제대로 통신하지 못해 힘들었습니다. 이 문제를 해결하는 과정에서 CORS의 개념에 대해 알게됐고, API 문서화의 필요성을 느끼게 됐습니다. 그동안 로컬 환경에서만 개발하고 프론트엔드와 직접 통신해본 적이 없어 마주치지 못했던 여러 문제들을 파악할 수 있었습니다. 해커톤 덕분에 CORS로 인해 발생하는 문제들을 해결하는 여러 방법을 알게 되었고, 이러한 문제 해결 과정에서 Spring Security가 정말 큰 도움이 되었습니다. 또한, API 문서화 도구들도 어렴풋이 알고만 있었고 어떻게 활용해야하는지, 왜 활용해야하는지 잘 알지 못했는데, 프론트엔드 팀원들이 개발 과정 내내 API의 정확한 사용법을 알지 못해 차질이 생겼던 것을 보며 API 문서화 도구는 필수이며, 사용하는 방법을 꼭 익혀야겠다고 생각했습니다. 서로 API에 대해 이해한 내용이 다르니 제대로 통신이 될리가 만무했습니다. 결국, 프론트엔드는 제대로 배포하지 못한 채 마감 기한이 다가왔고, "달빗"은 미완성으로 남게 됐습니다. 백엔드 역시 CI/CD 파이프라인 구축에 실패하면서 아쉬움이 큰 12시간이었습니다.</p>
<h2 id="여전히-알아야할-것은-많았다" class="heading">여전히 알아야할 것은 많았다.</h2>
<p>저는 지난 하반기 동안 GDSC의 코어 멤버로 활동하면서 일반 멤버들에게 Java, Spring, DB 관련 지식들을 공유하기 위해 열심히 공부했고, 덕분에 백엔드 개발과 서비스 배포 과정을 간단하게나마 홀로 해낼 수 있었습니다. 해커톤에 앞서 동아리원들끼리 진행한 미니 프로젝트까지 성공적으로 완성해 제 실력에 상당한 자신감을 가지고 있었습니다. 그러나, 넘쳐나던 자신감이 무색하게, 아직도 제가 갈길이 멀었다고 느낀 해커톤이었습니다. 특히, Dokcer와 Github Actions를 통한 CI/CD 파이프라인 구축은 완전 처음 해보는 작업이어서 그런지 많은 시행착오를 겪었습니다. 결국 제대로 알지 못하고 사용한 탓에 프로젝트 제출 제한 시간까지 CI/CD 파이프라인은 원하는 대로 동작하지 않았습니다. 좋은 개발자를 꿈꾼다는 사람이 사실상 표준이 되어가는, 백엔드 개발자라면 잘 다뤄야만 하는 기술을 아직도 어려워한다는게 부끄러웠습니다. 대학생이라, 시간이 모자라서, 아직 그렇게 중요하지 않아서 같은 변명은 이제 전혀 통하지 않는 고학번이 되었고, 정말 변해야겠다는 생각이 강하게 들었습니다.</p>
<p>그동안 저는 주변 사람들보다 조금 앞서 나갔다고 해서 절대 뛰어난 실력을 가진게 아닌데, 스스로 '이 정도 했으면 됐다'며 안주했고, 이번 해커톤에서 제 실력의 민낯을 보고 말았습니다. 구글링을 통해 구현하는 것도 제대로 못하는 제 자신에게 화도 나고 여러모로 실망스러웠습니다. 앞으로는 여러 외부 개발 활동에 참여해 최대한 많은 사람들과 다양한 경험을 해보고 제 실력의 척도를 객관화할 필요성을 느꼈습니다. 우물 안 개구리가 되어서는 절대 저의 목표인 "좋은 개발자"가 될 수 없을 것입니다. 여러모로 아쉬운 점이 많았지만 정말 얻어가는게 많았던 해커톤이었습니다.</p>]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[미니 프로젝트를 마치고]]></title>
    <link>https://blog.coderoad.kr/miniproject</link>
    <pubDate>2023-02-01</pubDate>
    <guid isPermaLink="false">https://blog.coderoad.kr/miniproject</guid>
    <description>
    <![CDATA[Spring을 본격적으로 공부하고 처음 진행한 프로젝트]]>
    </description>
    <content:encoded>
      <![CDATA[]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[빈 스코프]]></title>
    <link>https://blog.coderoad.kr/beanscope</link>
    <pubDate>2023-01-24</pubDate>
    <guid isPermaLink="false">https://blog.coderoad.kr/beanscope</guid>
    <description>
    <![CDATA[Spring 빈의 스코프]]>
    </description>
    <content:encoded>
      <![CDATA[<p><strong>본 문서는 인프런에서 수강할 수 있는 <a href="https://inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8" target="_blank" rel="noopener noreferer">스프링 핵심 원리 - 기본편</a>을 수강한 후, 공부한 내용을 정리한 문서입니다. 본 문서의 모든 저작권은 해당 강의의 저자이신 <a href="https://inflearn.com/users/@yh" target="_blank" rel="noopener noreferer">김영한</a> 우아한형제들 기술이사님께 있습니다.</strong></p>
<p>문서 공사중입니다.</p>
<h2 id="spring-빈-스코프" class="heading">Spring 빈 스코프?</h2>
<p>Spring 빈은 Spring 컨테이너가 시작될 때 함께 생성되고, 컨테이너가 종료될 때 같이 소멸됩니다. 이렇게 <strong>빈이 존재할 수 있는 범위</strong>를 <strong>스코프</strong>라고 합니다. Spring은 다양한 스코프를 지원합니다.</p>
<ul>
<li><strong>싱글톤</strong> : 기본 스코프로 컨테이너의 생성과 소멸까지 유지되는 가장 넓은 스코프</li>
<li><strong>프로토타입</strong> : 컨테이너가 빈의 생성과 의존관계 주입까지만 관여하는 매우 짧은 스코프</li>
<li><strong>웹 관련 스코프</strong>
<ul>
<li><strong>request</strong> : 웹 요청이 들어오고 나갈 때까지 유지되는 스코프</li>
<li><strong>session</strong> : 웹 세션이 생성되고 소멸될 때까지 유지되는 스코프</li>
<li><strong>application</strong> : 웹의 Servlet 컨텍스트와 같은 범위로 유지되는 스코프</li>
</ul>
</li>
</ul>
<p>기본적으로 Spring 빈은 싱글톤 패턴으로 생성됩니다. 프로토타입이나 웹 관련 스코프를 적용하려면 <code>@Scope</code> 어노테이션을 활용해서 적용하면 됩니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token comment">//이 빈은 프로토타입 스코프입니다.</span>
</span><span class="code-line"><span class="token comment">//빈 생성과 의존관계 주입 후에는 컨테이너가 관리하지 않습니다.</span>
</span><span class="code-line"><span class="token annotation punctuation">@Scope</span><span class="token punctuation">(</span><span class="token string">"prototype"</span><span class="token punctuation">)</span>
</span><span class="code-line"><span class="token annotation punctuation">@Bean</span>
</span><span class="code-line"><span class="token class-name">PrototypeBean</span> <span class="token class-name">ExampleBean</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">        count<span class="token operator">++</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token punctuation">}</span>
</span><span class="code-line">    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">        <span class="token keyword">return</span> count<span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token punctuation">}</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<h2 id="프로토타입-스코프" class="heading">프로토타입 스코프</h2>
<p>싱글톤 스코프 빈, 즉, 일반적인 빈은 컨테이너에서 조회하면 항상 같은 인스턴스의 빈을 반환해줍니다. Spring 컨테이너가 생성된 빈을 컨테이너 소멸 시까지 관리하기 때문입니다. 반대로, 프로토타입 스코프 빈은 컨테이너가 항상 새로운 인스턴스를 생성해서 반환해주는데, <strong>컨테이너가 빈을 생성하고 의존관계를 주입해주면 더 이상 관리하지 않아</strong> 반환해줄 빈이 없기 때문입니다. 따라서, <strong>클라이언트가 빈을 요청하면 항상 새로 생성해서 반환</strong>합니다.</p>
<p>프로토타입 빈은 초기화 콜백 메소드인 <code>@PostConstruct</code>는 실행되지만, <code>@PreDestroy</code>와 같은 소멸 콜백 메소드는 실행되지 않습니다. 때문에, 프로토타입 빈은 빈을 조회한 클라이언트가 직접 관리해줘야합니다. 당연히 소멸 콜백 메소드에 대한 호출도 클라이언트가 직접 해야합니다.</p>
<h3 id="프로토타입-스코프의-문제점">프로토타입 스코프의 문제점</h3>
<p>프로토타입 스코프 빈에는 큰 문제가 하나 존재합니다. <strong>싱글톤 빈과 함께 사용할 때</strong>, 프로토타입 스코프 빈이 <strong>의도한대로 동작하지 않을 가능성이 있습니다</strong>. 바로, 프로토타입 스코프 빈을 싱글톤 스코프 객체 안의 필드에 저장하게 되면 프로토타입의 특징을 잃어버리는 문제입니다.</p>
<p>우리가 프로토타입 빈을 사용할 때는 빈을 생성할 때마다 매번 새로운 인스턴스가 들어오는 것을 기대합니다. 그러나 막상 싱글톤 빈의 필드에 프로토타입 빈을 주입 받아 사용해보면 <strong>기존에 저장된 인스턴스가 호출</strong>됩니다. 이렇게 의도치 않게 프로토타입 빈이 싱글톤 빈과 함께 유지되는 이유는 프로토 타입 빈이 엄밀히 말하면 <strong>의존관계가 주입 될 때</strong> 새로 생성되는 것이지 <strong>이미 주입된 빈을 사용할 때는 새로 생성되지 않기 때문</strong> 입니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token annotation punctuation">@Scope</span><span class="token punctuation">(</span><span class="token string">"prototype"</span><span class="token punctuation">)</span>
</span><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PrototypeBean</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token comment">//싱글톤 빈의 필드에 프로토타입 빈을 대입하는 예시입니다.</span>
</span><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SingletonBean</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">PrototypeBean</span> prototypeBean<span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token annotation punctuation">@Autowired</span>
</span><span class="code-line">    <span class="token keyword">public</span> <span class="token class-name">SingletonBean</span><span class="token punctuation">(</span><span class="token class-name">PrototypeBean</span> prototypeBean<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">        <span class="token comment">//의존관계를 주입할 때만 새로운 PrototypeBean 인스턴스가 생성되고,</span>
</span><span class="code-line">        <span class="token comment">//이 필드를 활용할 때는 새로 생성하는 것이 아니라 저장된 인스턴스가 호출됩니다.</span>
</span><span class="code-line">        <span class="token keyword">this</span><span class="token punctuation">.</span>prototypeBean <span class="token operator">=</span> prototypeBean<span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token punctuation">}</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<h3 id="스코프와-provider">스코프와 Provider</h3>
<p>이렇게 싱글톤 빈과 프로토타입 빈을 같이 쓸 때 발생하는 문제를 해결하기 위해선 <strong>싱글톤 빈이 프로토타입 빈을 사용할 때 마다 Spring 컨테이너에 새로운 인스턴스를 요청</strong>해야합니다. 이를 **의존관계 탐색(Dependency Lookup)**이라고 하는데, 의존관계 주입과 다르게 스스로 필요한 의존관계를 위한 인스턴스를 컨테이너에서 찾아 반환받는 것입니다. DL를 활용하는 가장 간단하고 익숙한 방법은 Spring 컨테이너, 즉,<code>AnnotationConfigApplicationContext</code>의 <code>getBean()</code> 메소드를 통해 항상 새로운 프로토타입 빈을 생성해 반환받는 방법입니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token annotation punctuation">@Autowired</span>
</span><span class="code-line"><span class="token keyword">private</span> <span class="token class-name">ApplicationContext</span> ac<span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">mainLogic</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token comment">//로직을 실행할 때마다 컨테이너로부터 항상 새로운 프로토타입 빈을 반환받습니다.</span>
</span><span class="code-line">    <span class="token class-name">PrototypeBean</span> prototypeBean <span class="token operator">=</span> ac<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token class-name">PrototypeBean</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    prototypeBean<span class="token punctuation">.</span><span class="token function">addCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token keyword">int</span> count <span class="token operator">=</span> prototypeBean<span class="token punctuation">.</span><span class="token function">getCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token keyword">return</span> count<span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p>우리가 지금까지 자주 다뤘던 메소드를 통해 해결하는 방법이지만 이 방법에도 문제가 있습니다. 바로 TDD(테스트 주도 개발)을 위한 단위 테스트 작성이 어렵다는 점입니다. 이 방법은 <code>ApplicationContext</code> 객체가 없이는 사용할 수 없기 때문에 테스트를 작성할 때마다 <code>ApplicationContext</code>를 주입받아야 합니다. <code>ApplicationContext</code>는 편리하기도 하지만 그만큼 많은 기능을 제공하고 이 말은 <strong>불필요한 기능도 많다</strong>는 것입니다. 또한, <code>ApplicationContext</code>가 꼭 필요하기 때문에 Spring에 종속적인 코드가 됩니다. 우리가 Spring을 공부하면서 계속 피해왔던 것이 특정 기술에 종속적인 코드를 작성하는 것이었던 걸 생각하면 이 방법보다 더 나은 방법을 찾아야 합니다.</p>
<p>다행히도 Spring에는 불필요한 기능들을 제외하고 <strong>DL</strong> 기능만 제공하는 **<code>ObjectProvider</code>**라는 객체가 있습니다. <code>ObjectProvider</code>는 <code>ObjectFactory</code>에 편의 기능을 추가한 객체로 DL 외에도 <code>ObjectFactory</code> 상속, 옵션, 스트림 처리 기능을 제공합니다. 별도의 라이브러리 없이 간단하게 사용할 수 있고 테스트 작성도 수월합니다. 그러나 여전히 Spring에 의존적이라는 문제는 해결하지 못합니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token annotation punctuation">@Autowired</span>
</span><span class="code-line"><span class="token keyword">private</span> <span class="token class-name">ObjectProvider</span><span class="token generics"><span class="token punctuation">&#x3C;</span><span class="token class-name">PrototypeBean</span><span class="token punctuation">></span></span> prototypeBeanProvider<span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">mainLogic</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token comment">//ObjectProvider를 통해 매번 새로운 프로토타입 빈을 반환받습니다.</span>
</span><span class="code-line">    <span class="token class-name">PrototypeBean</span> prototypeBean <span class="token operator">=</span> prototypeBeanProvider<span class="token punctuation">.</span><span class="token function">getObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    prototypeBean<span class="token punctuation">.</span><span class="token function">addCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token keyword">int</span> count <span class="token operator">=</span> prototypeBean<span class="token punctuation">.</span><span class="token function">getCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token keyword">return</span> count<span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p>마지막 문제인 Spring에 의존적인 코드를 벗어나기 위해선 <code>javax.inject.Provider</code>라는 <strong>JSR-330</strong> Java 표준 Provider를 사용하는 방법입니다. 참고로 <strong>Spring Boot 3.0</strong>에서는 <code>jakarta.inject.Provider</code> ㅖ라이브러리를 사용합니다. 사용법은 다음과 같습니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token annotation punctuation">@Autowired</span>
</span><span class="code-line"><span class="token keyword">private</span> <span class="token class-name">Provider</span><span class="token generics"><span class="token punctuation">&#x3C;</span><span class="token class-name">PrototypeBean</span><span class="token punctuation">></span></span> provider<span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">mainLogic</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token comment">//jakarta.inject.Provider 라이브러리의 Provider를 사용합니다.</span>
</span><span class="code-line">    <span class="token class-name">PrototypeBean</span> prototypeBean <span class="token operator">=</span> provider<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    prototypeBean<span class="token punctuation">.</span><span class="token function">addCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token keyword">int</span> count <span class="token operator">=</span> prototypeBean<span class="token punctuation">.</span><span class="token function">getCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token keyword">return</span> count<span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p><code>Provider</code>는 <code>get()</code> 메소드로 Spring의 <code>ObjectProvider</code>와 동일하게 DL을 통해 Spring 컨테이너로부터 새로운 인스턴스를 반환받습니다. 이 방법은 Java 표준이고 단순하기 때문에 Spring에 의존적이지 않고 단위 테스트를 작성하기 좋습니다.</p>
<p>지금까지 열심히 프로토타입 빈에 대해 알아봤습니다. 프로토타입 빈은 <strong>'사용할 때마다 의존관계 주입이 완료된 새로운 객체가 필요할 때'</strong> 사용하면 됩니다. 사실, 실무에서 웹 애플리케이션을 개발할 때, 싱글톤 빈으로 대부분의 문제를 해결할 수 있기 때문에 프로토타입 빈을 직접 사용하는 일은 매우 드물다고 합니다.</p>
<h2 id="웹-스코프" class="heading">웹 스코프</h2>
<p>마지막으로 알아볼 스코프는 <strong>웹 스코프</strong>입니다. 싱글톤 스코프는 Spring 컨테이너의 시작과 끝을 함께하고, 프로토타입 스코프는 빈 생성과 의존관계 주입, 초기화까지만 담당하는 특수한 스코프였습니다. 그렇다면 웹 스코프는 어떤 스코프일까요? 굳이 다르게 구분한 이유는 무엇일까요?</p>
<p>웹 스코프의 가장 큰 특징은 <strong>'웹 환경'에서만 동작</strong>한다는 것입니다. 또한 싱글톤 스코프와 마찬가지로 웹 스코프의 종료 시점까지 Spring에서 관리해 소멸 콜백 메소드를 호출할 수 있습니다. 웹 스코프의 종류는 다음과 같습니다.</p>
<ul>
<li><strong>request</strong> : HTTP 요청이 들어오고 나갈 때까지 유지되는 스코프로 각각의 HTTP 요청마다 별도의 인스턴스를 생성 및 관리</li>
<li><strong>session</strong> : HTTP의 Session과 동일한 생명주기를 가지는 스코프</li>
<li><strong>application</strong> : **서블릿 컨텍스트(ServletContext)**와 동일한 생명주기를 가지는 스코프</li>
<li><strong>websocket</strong> : 웹 소켓과 동일한 생명주기를 가지는 스코프</li>
</ul>
<p>웹 스코프도 프로토타입 스코프와 마찬가지로 인스턴스와 관련된 문제가 발생할 수 있습니다. 바로, 실제 사용자의 웹 요청이 있기 전까지는 웹 스코프 빈의 인스턴스가 생성되지 않아 필요한 인스턴스가 제대로 할당되지 않은 채 로직이 실행되는 문제입니다. 이 문제도 앞서 정리해본 <strong>Provider</strong>를 통해 해결할 수 있습니다. <code>ObjectProvider</code>는 <code>getObject()</code>와 같은 DL 메소드를 호출하는 시점까지 <strong>웹 스코프 빈의 생성을 지연할 수 있습니다.</strong></p>
<p>다시 말해서, HTTP 요청이 진행 중인 순간에 <code>getObject()</code>를 호출하면 빈이 정상적으로 생성되고 로직이 문제 없이 작동하는 것을 알 수 있습니다. 그러나 아직도 근본적인 문제가 남아있습니다. 이 코드는 <strong>너무 비효율적이고 복잡합니다.</strong> 이런 일련의 문제 해결 과정을 직접 구현하는 것은 본 문제보다 부가적인 문제에 너무 집중하게 됩니다. 흔히 말하는 배보다 배꼽이 더 큰 상황입니다.</p>
<h2 id="스코프와-프록시" class="heading">스코프와 프록시</h2>
<p>웹 스코프의 인스턴스 문제를 해결해주기 위해 <strong>프록시</strong>라는 기술을 활용하면 좋습니다. Spring 빈의 스코프를 지정해주는 <code>@Scope</code> 어노테이션의 속성인 <code>proxyMode</code>를 활용해 프록시 방식을 활용할 수 있습니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token annotation punctuation">@Component</span>
</span><span class="code-line"><span class="token annotation punctuation">@Scope</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"request"</span><span class="token punctuation">,</span> proxyMode <span class="token operator">=</span> <span class="token class-name">ScopedProxyMode</span><span class="token punctuation">.</span>TARGET_CLASS<span class="token punctuation">)</span>
</span><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyWebScopeBean</span> <span class="token punctuation">{</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p><code>proxyMode</code>의 속성에는 <code>TARGET_CLASS</code>와 <code>INTERFACES</code> 두 가지가 있습니다. 스코프를 적용하려는 객체가 클래스일 경우 <code>TARGET_CLASS</code>를, 인터페이스일 경우 <code>INTERFACES</code>를 <code>ScopedProxyMode</code>에 붙여주면 됩니다. 이렇게 속성을 부여한 객체는 HTTP 요청 여부에 상관 없이 <strong>가짜 프록시 인스턴스</strong>를 빈에 미리 주입해 둘 수 있습니다. Provider를 사용하기 전에 인스턴스가 없어서 발생했던 문제를 가짜 프록시 인스턴스를 통해 해결한 것입니다. 즉, 복잡하고 거추장스러운 Provider를 사용하지 않고도 문제를 해결할 수 있게 된 것입니다!</p>
<p>이것이 가능한 이유는 바이트코드를 조작하는 <strong>CGLIB 라이브러리를 활용해</strong> 내가 직접 작성한 클래스(예를 들어 예제 코드의 <code>MyWebScopeBean</code>)를 상속 받은 <strong>가짜 프록시 객체</strong>를 만들어서 대신 주입하고, HTTP 요청이 왔을 때 <strong>가짜 프록시 객체</strong>가 내부의 위임 로직을 통해 진짜 객체의 로직을 실행하기 때문입니다. 쉽게 설명하자면, <strong>가짜 프록시 객체는 자리만 지키고 있다</strong>가 실제 사용자 요청이 들어오면 <strong>자신이 상속 받은 진짜 빈을 호출</strong>하고 그때서야 나타난 진짜 빈이 사용자가 요청한 로직을 수행하는 것입니다.</p>
<p>프록시 객체 덕분에 클라이언트는 싱글톤 빈을 사용하는 것처럼 편리하게 웹 스코프를 사용할 수 있습니다. 이는 다형성의 장점이기도 한데, 클라이언트는 내부 코드가 어떻게 동작하는지, 실제로 내가 어떤 객체를 사용하는지는 전혀 알 필요가 없습니다. 다시 말해서, 다형성 덕분에 <strong>클라이언트의 변경 없이 유연하게 객체를 바꿔가며 문제를 해결</strong>한 것입니다.</p>
<p>사실, Provider를 통한 해결법이든, 프록시 객체를 통한 해결법이든, 중요한 것은 진짜 객체, 진짜 빈을 컨테이너에서 조회하는 시점을 꼭 필요할 때까지(실제 요청이 들어오거나, 사용할 때 마다) 지연 처리 한다는 점입니다. 추가로, 꼭 웹 스코프가 아니더라도 프록시 기능을 사용할 수 있습니다.</p>]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[빈 생명주기와 콜백]]></title>
    <link>https://blog.coderoad.kr/lifecyclecallback</link>
    <pubDate>2023-01-23</pubDate>
    <guid isPermaLink="false">https://blog.coderoad.kr/lifecyclecallback</guid>
    <description>
    <![CDATA[Spring 빈의 생명주기, 콜백이란?]]>
    </description>
    <content:encoded>
      <![CDATA[<p><strong>본 문서는 인프런에서 수강할 수 있는 <a href="https://inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8" target="_blank" rel="noopener noreferer">스프링 핵심 원리 - 기본편</a>을 수강한 후, 공부한 내용을 정리한 문서입니다. 본 문서의 모든 저작권은 해당 강의의 저자이신 <a href="https://inflearn.com/users/@yh" target="_blank" rel="noopener noreferer">김영한</a> 우아한형제들 기술이사님께 있습니다.</strong></p>
<h2 id="spring-빈의-생명주기와-콜백" class="heading">Spring 빈의 생명주기와 콜백</h2>
<p>우리가 웹 애플리케이션을 작성하다보면 다른 객체들과의 연결이 필요하다는 것을 알 수 있습니다. 특히, 데이터베이스와의 연결이나 네트워크 소켓 연결 같은 작업은 웹 애플리케이션 개발 시 필수에 가까운 작업입니다. 그러나, 이렇게 <strong>외부와 연결하는 작업들은 상당히 긴 시간이 소요</strong>됩니다. 개발자는 사용자의 요청이 들어왔을 경우 바로 응답할 수 있도록 <strong>미리 연결</strong>(DB 커넥션 풀 등)된 인스턴스들을 사용해야하며, 예기치 못한 오류를 피하기 위해 외부 연결들을 애플리케이션 종료 시점보다 먼저 연결 종료하는 안전한 프로그램을 작성해야합니다. 따라서, 개발자는 객체의 초기화와 종료 과정(생명주기)을 <strong>직접 제어</strong>해야합니다.</p>
<p>Spring 빈은 <strong>객체가 생성되고 의존관계가 주입된 후에 사용할 준비가 완료</strong>됩니다. 즉, 초기화 작업(구현 객체 주입)은 빈이 Spring 컨테이너에 등록되고, 의존관계까지 주입이 모두 끝난 다음 진행해야합니다. 당연한 이야기지만 초기화 작업을 위해선 Spring 빈의 의존관계 주입이 완료되는 시점을 알아야합니다. Spring 빈이 사용될 준비를 다 마치지도 않은 시점에서 사용하려하면 아무런 구현 객체도 가지지 않는 빈을 사용하게 되어 애플리케이션이 의도한대로 작동하지 않을 것입니다.</p>
<p>다행히, Spring은 의존관계 주입을 완료하면 <strong>콜백 메소드를 통해 빈의 초기화가 가능하다는 것을 알려줍니다.</strong> 또한, Spring 컨테이너가 소멸되기 전에도 <strong>소멸 콜백 메소드를 호출</strong>해 애플리케이션이 종료된다는 것을 알려주는데, 개발자는 이 콜백 메소드들 덕분에 초기화와 종료 전 로직들을 정상적으로 수행할 수 있습니다.</p>
<p>지금까지 살펴본 내용을 토대로 Spring 빈의 생명주기를 정리하자면 다음과 같습니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line">컨테이너 생성 <span class="token operator">-></span> 빈 생성 <span class="token operator">-></span> 의존관계 주입 <span class="token operator">-></span> 초기화 콜백 <span class="token operator">-></span> 빈 사용 <span class="token operator">-></span> 소멸 전 콜백 <span class="token operator">-></span> <span class="token class-name">Spring</span> 종료
</span></code></pre>
<p>이 중, 초기화 콜백과 소멸 전 콜백을 <strong>생명주기 콜백</strong>이라고 합니다. Spring은 크게 3가지 방식으로 생명주기 콜백을 지원합니다.</p>
<ul>
<li>인터페이스 (<code>InitializingBean</code>, <code>DisposableBean</code>)</li>
<li>설정 정보에 초기화 메소드, 종료 메소드 직접 작성</li>
<li><code>@PostConstruct</code>, <code>@PreDestroy</code> 어노테이션</li>
</ul>
<h2 id="인터페이스를-통한-생명주기-콜백-다루기" class="heading">인터페이스를 통한 생명주기 콜백 다루기</h2>
<p>첫 번째로 인터페이스를 통해 콜백 메소드를 다루는 방법에 대해 알아보겠습니다. 먼저, 초기화는 <code>InitializingBean</code> 인터페이스의 <code>afterPropertiesSet()</code> 메소드를 활용해서 진행합니다. 이 메소드는 의존관계가 주입이 모두 완료된 후에 호출되기 때문에, 초기화 관련 코드를 넣어두면 초기화가 누락되는 등의 오류 없이 진행할 수 있습니다.</p>
<p>다음으로 빈 소멸은 <code>DisposableBean</code> 인터페이스의 <code>destroy()</code> 메소드를 통해 구현합니다. 이 메소드는 Spring 컨테이너가 종료 로직이 시작될 때, 호출되어 애플리케이션이 완전 종료되기 전에 필요한 로직들을 먼저 수행할 수 있도록 해줍니다.</p>
<p>인터페이스만 구현해주면 되는 이 방식에는 큰 문제가 있는데, <strong>Spring 전용 인터페이스</strong>이기 때문입니다. 다시 말해서 코드가 Spring에 강하게 의존하게 되고, DIP를 위반할 가능성이 높습니다.</p>
<p>요즘은 인터페이스를 활용하는 방식보다 더 좋은 방식들이 나오게 되어 잘 사용하지 않는 방식입니다.</p>
<h2 id="빈-등록-시-초기화와-소멸-메소드-지정" class="heading">빈 등록 시 초기화와 소멸 메소드 지정</h2>
<p>다음은 Java 설정 클래스에서 <code>@Bean</code> 어노테이션을 통해 Spring 빈을 등록할 때 해당 빈의 초기화 메소드와 소멸 메소드를 직접 지정하는 방식입니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token annotation punctuation">@Configuration</span>
</span><span class="code-line"><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">AppConfig</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token comment">//객체를 빈으로 등록할 때,</span>
</span><span class="code-line">    <span class="token comment">//해당 객체에 작성한 메소드들을 각각 초기화와 소멸 메소드로 지정할 수 있습니다.</span>
</span><span class="code-line">    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span>initMethod <span class="token operator">=</span> <span class="token string">"init"</span><span class="token punctuation">,</span> destroyMethod <span class="token operator">=</span> <span class="token string">"close"</span><span class="token punctuation">)</span>
</span><span class="code-line">    <span class="token keyword">public</span> <span class="token class-name">DatabaseClient</span> <span class="token function">databaseClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">        <span class="token class-name">DatabaseClient</span> databaseClient <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DatabaseClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">        <span class="token keyword">return</span> databaseClient<span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token punctuation">}</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p><code>DatabaseClient</code> 객체의 <code>init</code> 메소드와 <code>close</code> 메소드를 각각 초기화와 소멸 메소드로 지정했습니다. 당연히 직접 작성한 메소드를 활용하기 때문에 메소드 이름은 자유롭게 정할 수 있습니다. 또한, Spring 빈이 더 이상 Spring에 의존적이지 않기 때문에 외부 라이브러리에서도 우리가 직접 지정한 생명주기 콜백 메소드들을 활용할 수 있게 됩니다.</p>
<p>이 방식의 정말 특별한 기능이 하나 있는데, 바로 <strong>소멸 메소드 추론</strong>입니다. 소멸 메소드를 지정하는 <code>@Bean</code> 어노테이션의 <code>destroyMethod</code> 속성은 소멸 콜백 메소드의 이름을 말 그대로 **'추론'**합니다. 개발자나 라이브러리는 주로 소멸 메소드의 이름으로 <code>close</code>, <code>shutdown</code> 등의 이름을 사용합니다. <code>destroyMethod</code>는 이러한 이름들이 확인되면 소멸 메소드를 직접 지정해주지 않아도 해당 이름을 가진 메소드를 소멸 메소드로 '추론'하고 <strong>자동으로 호출</strong>합니다.</p>
<h2 id="어노테이션을-통한-콜백-다루기" class="heading">어노테이션을 통한 콜백 다루기</h2>
<p>마지막으로 어노테이션을 통한 초기화와 소멸 콜백 메소드 구현 방식입니다. 초기화 콜백에는 <code>@PostConstruct</code>를, 소멸 콜백에는 <code>@PreDestroy</code> 어노테이션을 사용합니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DatabaseClient</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token annotation punctuation">@PostConstruct</span>
</span><span class="code-line">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Database connection init"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">        <span class="token function">connect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token punctuation">}</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token annotation punctuation">@PreDestroy</span>
</span><span class="code-line">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Database connection close"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">        <span class="token function">disconnect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token punctuation">}</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p>예시 코드를 보면, 초기화 로직을 구현한 메소드에 <code>@PostConstruct</code>를 붙이고 소멸 로직을 구현한 메소드에 <code>@PreDestroy</code>를 붙인 것을 확인할 수 있습니다. 이렇게 어노테이션을 붙이는 것만으로 간단하게 생명주기 콜백을 구현할 수 있습니다. 또한, 이러한 편리함과 <strong>Java 표준</strong>이라는 점 덕분에 <strong>최신 Spring</strong>에서 가장 권장하는 방법이라고 합니다.</p>
<p>거기다 자동 빈 등록 방식인 **<a href="https://blog.coderoad.kr/" target="_blank" rel="noopener noreferer">컴포넌트 스캔</a>**과도 가장 잘 맞는 방식입니다. 일단, 인터페이스를 이용한 방식은 Spring에 의존적이기 때문에 피하는 것이 좋습니다. Java 설정 클래스에서 <code>@Bean</code>의 속성을 이용하는 방법은 Spring 빈이 될 클래스를 직접 지정합니다. 이는 곧 자동 빈 등록 기능을 사용하지 않는 것이기 때문에 딱히 효율적인 방식은 아닙니다.</p>
<p>어노테이션을 활용하는 방식의 유일한 단점은 외부 라이브러리에서는 사용하지 못한다는 점입니다. 따라서 상황과 필요에 따라 <code>@Bean</code>의 속성을 활용하거나 <code>@PostConstruct</code>와 <code>@PreDestroy</code> 어노테이션을 통해 콜백을 다루는 것이 좋습니다.</p>]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[의존관계 주입]]></title>
    <link>https://blog.coderoad.kr/ditype</link>
    <pubDate>2023-01-22</pubDate>
    <guid isPermaLink="false">https://blog.coderoad.kr/ditype</guid>
    <description>
    <![CDATA[다양한 DI 방식들]]>
    </description>
    <content:encoded>
      <![CDATA[<p><strong>본 문서는 인프런에서 수강할 수 있는 <a href="https://inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8" target="_blank" rel="noopener noreferer">스프링 핵심 원리 - 기본편</a>을 수강한 후, 공부한 내용을 정리한 문서입니다. 본 문서의 모든 저작권은 해당 강의의 저자이신 <a href="https://inflearn.com/users/@yh" target="_blank" rel="noopener noreferer">김영한</a> 우아한형제들 기술이사님께 있습니다.</strong></p>
<h2 id="다양한-의존관계-주입-방법" class="heading">다양한 의존관계 주입 방법</h2>
<p>Spring의 의존관계 주입 방법에는 크게 4가지 방법이 있습니다.</p>
<ul>
<li>생성자 주입</li>
<li>수정자 주입</li>
<li>필드 주입</li>
<li>일반 메소드 주입</li>
</ul>
<h3 id="생성자-주입">생성자 주입</h3>
<p>생성자 주입 방식은 말 그대로 클래스의 생성자(Constructor)를 통해 의존관계를 주입 받습니다. 생성자를 매개체로 사용하기 때문에 생성자 호출 시점에 <strong>딱 1번만 호출되는 것이 보장</strong>되며, 변하지 않고 필수적인 의존관계에 사용합니다. 즉, 생성자 주입 방식을 사용하면 의존관계 주입된 인스턴스를 중간에 변경할 수 없습니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MemberServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">MemberService</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token comment">//한 번 주입된 의존관계는 외부에서 변경할 수 없습니다!</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">MemberRepository</span> memberRepository<span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token annotation punctuation">@Autowired</span> <span class="token comment">//의존관계 자동 주입 기능을 사용했습니다.</span>
</span><span class="code-line">    <span class="token keyword">public</span> <span class="token class-name">MemberServiceImpl</span><span class="token punctuation">(</span><span class="token class-name">MemberRepository</span> memberRepository<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">        <span class="token comment">//Spring 컨테이너가 memberRepository 이름을 가진 빈을 주입해줍니다.</span>
</span><span class="code-line">        <span class="token keyword">this</span><span class="token punctuation">.</span>memberRepository <span class="token operator">=</span> memberRepository<span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token punctuation">}</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p>만약, 생성자가 딱 1개만 존재하면 <code>@Autowired</code>가 없어도 의존관계가 자동 주입됩니다. 당연히 주입하려는 의존관계가 Spring 빈이어야만 가능합니다.</p>
<h3 id="수정자-주입">수정자 주입</h3>
<p>수정자, 흔히 <code>Setter</code>라고 불리는 <strong>필드 값을 변경하는 수정자 메소드를 통해 의존관계를 주입</strong>하는 방법입니다. 생성자 주입 방식과 다르게 외부에서 언제든 접근이 가능하기 때문에 선택적이고 변경 가능성이 있는 의존관계에 사용하는 방식입니다. <code>Setter</code>를 사용하여 필드에 접근하는 방식을 <strong>Java 빈 프로퍼티 규약</strong>이라 하는데, 수정자 주입 방식이 해당 규약을 따른다고 생각하면 됩니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MemberServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">MemberService</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token comment">//final로 선언되지 않았기 때문에 수정될 수 있습니다.</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token class-name">MemberRepository</span> memberRepository<span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token annotation punctuation">@Autowired</span> <span class="token comment">//의존관계 자동 주입 기능을 사용했습니다.</span>
</span><span class="code-line">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setMemberRepository</span><span class="token punctuation">(</span><span class="token class-name">MemberRepository</span> memberRepository<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">        <span class="token keyword">this</span><span class="token punctuation">.</span>memberRepository <span class="token operator">=</span> memberRepository<span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token punctuation">}</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p>만약, 빈의 의존관계를 필수가 아닌 선택적으로 주입되도록 하려면, <code>@Autowired</code>를 <code>@Autowired(required = false)</code>와 같이 작성해야합니다.</p>
<h3 id="필드-주입">필드 주입</h3>
<p>필드 주입은 위의 두 방식보다 훨씬 간단합니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MemberServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">MemberService</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token comment">//이 한 줄이면 자동으로 의존관계가 주입됩니다!</span>
</span><span class="code-line">    <span class="token annotation punctuation">@Autowired</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token class-name">MemberRepository</span> memberRepository<span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p>너무나도 간단해서 많은 개발자들을 현혹시켰고, 실제로 많은 프로젝트에서 필드 주입 방식을 사용했다고 합니다. 그러나 필드 주입 방식에는 치명적인 단점들이 있어 <strong>사용을 지양해야합니다.</strong></p>
<p>가장 큰 문제는 <a href="https://blog.coderoad.kr/solid" target="_blank" rel="noopener noreferer">SOLID</a>의 SRP를 위반할 가능성이 크다는 것입니다. Spring을 관통하는 <strong>좋은 OOP를 포기하면서</strong>까지 필드 주입 방식을 사용할 이유가 없습니다!</p>
<p>또한, 클래스의 코드만 봐서는 의존관계가 한 눈에 보이지 않는 <strong>숨겨진 의존관계</strong>(Hidden dependency) 문제가 발생합니다. 실제로 어떤 인스턴스(Spring 빈)가 의존관계 주입되어야 하고, 어떤 의존관계가 필수인지, 어떤 의존관계가 변하면 안 되는지 코드를 하나하나 뜯어봐야하는 매우 비효율적인 상황이 생기는 것입니다.</p>
<p>더군다나 필드를 <code>final</code>로 선언할 수 없어 언제든 변경될 수 있습니다. 이 경우에 변경된 의존관계로 인해 예상치 못한 에러가 발생해도 쉽게 알아차릴 수 없습니다. 바로 전에 설명한 문제점에서 알 수 있듯, 필드 주입 방식은 의존관계가 감춰져 있기 때문입니다!</p>
<p>TDD(Test Driven Development, 테스트 주도 개발)에도 악영향을 끼칩니다. 필드 주입 방식은 의존관계를 주입할 때, <code>@Autowired</code> 어노테이션을 보고 Spring 컨테이너가 자동으로 주입 해주는 방식입니다. 이는, 단위 테스트 시 DI 컨테이너, 다시 말해 Spring 컨테이너가 없으면 의존관계를 주입할 방법이 없다는 이야기입니다. <code>@Autowired</code>를 보고 의존관계를 주입해줘야 하는데 순수한 Java 테스트 코드는 Spring 컨테이너가 없으니 제대로 동작할리가 없습니다.</p>
<p>Spring이 등장한 이유가 특정 기술(EJB)에 종속적이었던 Java 개발 생태계를 개선하려던 것이었음을 생각하면, Spring에 종속적인 코드는 매우 모순적인 상황이 아닐 수 없습니다. 그러니 우리는 필드 주입 방식을 멀리해야합니다.</p>
<h3 id="일반-메소드-주입">일반 메소드 주입</h3>
<p>일반적인 Java 메소드를 통해 의존관계를 주입 받을 수도 있습니다. 그러나, 일반적으로 잘 사용하지 않습니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MemberServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">MemberService</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token class-name">MemberRepository</span> memberRepository<span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token annotation punctuation">@Autowired</span>
</span><span class="code-line">    <span class="token comment">//사실 수정자 주입 방식과 별반 다를게 없습니다.</span>
</span><span class="code-line">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">dependencyInject</span><span class="token punctuation">(</span><span class="token class-name">MemberRepository</span> memberRepository<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">        <span class="token keyword">this</span><span class="token punctuation">.</span>memberRepository <span class="token operator">=</span> memberRepository<span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token punctuation">}</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<h2 id="주입-옵션-처리" class="heading">주입 옵션 처리</h2>
<p>앞서 살펴본 여러 의존관계 주입 방식 중, 선택적으로 의존관계를 주입할 때 수정자 주입 방식을 사용해야 한다는 것을 알았습니다. 다시 말하자면, 주입할 Spring 빈이 없어도 애플리케이션이 정상 작동해야할 때가 있습니다. 그런데 자동 주입 방식의 <code>@Autowired</code> 어노테이션은 주입 대상 빈이 없으면 오류가 발생해, <code>@Autowired(required = false)</code>와 같이 옵션 값을 넣어줘야 한다는 것도 잠깐 설명했습니다. 이 방법은 만약 자동 주입 대상이 없다면 수정자 메소드 자체가 실행되지 않습니다.</p>
<p><code>@Autowired</code>에 옵션 값을 지정하는 방법 외에도 주입 옵션을 설정하는 방법은 2가지가 있습니다.</p>
<ul>
<li><code>@Nullable</code> : 자동 주입 대상이 없다면 <code>null</code>을 입력</li>
<li><code>Optional&#x3C;></code> : 자동 주입 대상이 없다면 <code>Optional.empty</code> 입력</li>
</ul>
<p>두 방법의 예시는 다음과 같습니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token keyword">private</span> <span class="token class-name">Member</span> nullMember<span class="token punctuation">;</span>
</span><span class="code-line"><span class="token keyword">private</span> <span class="token class-name">Member</span> optionalMember<span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token annotation punctuation">@Autowired</span>
</span><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setBeanNullable</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Nullable</span> <span class="token class-name">Member</span> member<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword">this</span><span class="token punctuation">.</span>nullMember <span class="token operator">=</span> member<span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token annotation punctuation">@Autowired</span>
</span><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setBeanOptional</span><span class="token punctuation">(</span><span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&#x3C;</span><span class="token class-name">Member</span><span class="token punctuation">></span></span> member<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword">this</span><span class="token punctuation">.</span>optionalMember <span class="token operator">=</span> member<span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p><code>Member</code>가 Spring 빈이 아니라고 가정했을 때, 두 수정자 메소드에 의해 필드에 입력되는 값은 각각 <code>null</code>과 <code>Optional.empty</code>가 됩니다.</p>
<h2 id="생성자-주입을-선택해야하는-이유" class="heading">생성자 주입을 선택해야하는 이유</h2>
<p>지금까지 크게 3가지 의존관계 주입 방식에 대해 정리해봤습니다. 이 방식들 중, <strong>필드 주입 방식은 지양</strong>하는게 좋다는 것과 그 이유에 대해서도 알아봤습니다. 그럼 도대체 어떤 방식을 주로 사용해야하는 걸까요? 이 질문에 대한 답은 **생성자 주입을 적극 권장하며, 선택적인 의존관계(필수가 아닌 의존관계)를 지정할 때만 제한적으로 수정자 주입 방식을 사용한다.**입니다. 이는 생성자 주입이 가지는 강력한 장점과 수정자 주입 방식의 한계 때문입니다.</p>
<h3 id="불변">불변</h3>
<p>먼저, 생성자 주입 방식을 통해 의존관계를 주입하면, <strong>애플리케이션이 작동 중인 동안에 변경되지 않습니다.</strong> 컴파일 단계에서 주입된 대부분의 의존관계가 애플리케이션 종료 전까지 변할 일이 없어야 한다는 걸 생각하면 이는 훌륭한 장점입니다. 사실, 수정자 주입 방식의 <code>Setter</code> 메소드는 의도치 않은 변경에 매우 취약해 좋은 설계 방법이 아닙니다. 따라서, 객체를 생성할 때 딱 1번만 호출되는 <strong>생성자 주입 방식</strong>을 사용하도록 설계하는 것이 훨씬 좋은 방법입니다.</p>
<h3 id="누락">누락</h3>
<p>수정자 주입 방식의 큰 문제점이 하나 더 있습니다. 만약 연관관계 주입 자체가 누락될 경우, 컴파일 단계에서 오류가 발생하지 않고 실행 도중 <code>NullPointerException</code>를 맞닥뜨리게 됩니다. <code>NPE</code>는 그 원인을 찾아내기 까다로워 Java 프로그래머들을 가장 많이 괴롭히는 악명 높은 예외입니다. 그에 반해 <strong>생성자 주입 방식</strong>은 연관관계 주입이 누락되었을 경우, <strong>컴파일 오류</strong>가 발생합니다. 생성자에 즉, 생성자 주입 방식을 사용하는 것 만으로도 Java 프로그래머의 골칫거리 <code>NPE</code>를 사전에 차단할 수 있는 큰 장점이 있습니다.</p>
<h3 id="final">final</h3>
<p>더 나아가, <code>final</code> 키워드를 사용할 수 있는 것이 생성자 주입을 사용해야하는 이유입니다. <code>final</code> 키워드가 붙은 필드는 선언과 동시에 값을 할당해야하고, 그 값은 변경할 수 없습니다. 이 <code>final</code> 필드에 값을 할당할 수 있는 방법들 중 한가지가 바로 <strong>생성자</strong>를 활용하는 것입니다. 만약 <code>final</code> 필드에 생성자를 통해 아무런 값도 할당하지 않으면, Java는 다음과 같은 컴파일 오류를 발생시킵니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line">java<span class="token operator">:</span> variable might not have been initialized
</span></code></pre>
<p>선언과 동시에 값이 할당(초기화)되어야 하는 <code>final</code> 필드에 아무런 값도 할당되지 않았으니, 이대로 실행시켜도 오류가 발생할 수 밖에 없어 Java가 컴파일 단계에서 오류를 발생시켜주는 것입니다. <strong>컴파일 오류는 세상에서 가장 빠르고, 좋은 오류입니다!</strong> 이렇게 <code>final</code> 키워드를 붙이는 것만으로도 연관관계 주입이 빠지지 않고 제대로 될 수 있도록 강제하는 장점도 있으니, <strong>생성자 주입 방식</strong> 대신 다른 방식을 선택할 이유가 없습니다!</p>
<h2 id="lombok과-함께" class="heading">Lombok과 함께</h2>
<p>자, 이제 우리는 좋은 코드를 작성하기 위해선 <strong>생성자 주입 방식</strong>을 사용해야한다는 것도 알게 되었습니다. 그런데, 대부분의 연관관계는 불변입니다. 덕분에 <code>final</code> 키워드를 붙이는 건 이제 습관이 될 정도로 자주 사용하게 되었습니다. 매번 생성자를 작성하는 것도 반복적이고 지루한 작업으로 느껴질 정도가 되어버렸고, 비효율적인 것은 참지 못하는 개발자들은 더 나은 방법을 고안해내기 시작했습니다. 역시 가장 빠르고 효율적인 개발은 불필요한 코드를 지우는 것이었습니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token annotation punctuation">@Component</span>
</span><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MemberServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">MemberService</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">MemberRepository</span> memberRepository<span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">TeamRepository</span> teamRepository<span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token comment">//@Autowired 어노테이션은 생성자가 하나일 때 생략되어도 된다!</span>
</span><span class="code-line">    <span class="token keyword">public</span> <span class="token class-name">MemberServiceImpl</span><span class="token punctuation">(</span><span class="token class-name">MemberRepository</span> memberRepository<span class="token punctuation">,</span> <span class="token class-name">TeamRepository</span> teamRepository<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">        <span class="token keyword">this</span><span class="token punctuation">.</span>memberRepository <span class="token operator">=</span> memberRepository<span class="token punctuation">;</span>
</span><span class="code-line">        <span class="token keyword">this</span><span class="token punctuation">.</span>teamRepository <span class="token operator">=</span> teamRepository<span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token punctuation">}</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p><code>@Autowired</code> 어노테이션은 <strong>생성자가 딱 1개 있을 때 생략해도 된다</strong>는 것을 이 포스트의 초반에서 알아봤습니다. <code>@Autowired</code>를 생략하고보니 <strong>생성자</strong>도 굳이 개발자가 직접 타이핑 하지 않는 것이 더 효율적이지 않을까라고 생각하게 되었습니다. 이때 등장하는 것이 바로 <strong><code>Lombok</code> 라이브러리</strong>입니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token annotation punctuation">@Component</span>
</span><span class="code-line"><span class="token annotation punctuation">@RequiredArgsConstructor</span> <span class="token comment">//Lombok 라이브러리의 어노테이션</span>
</span><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MemberServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">MemberService</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">MemberRepository</span> memberRepository<span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">TeamRepository</span> teamRepository<span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token comment">//생성자가 사라져도 문제 없습니다!</span>
</span><span class="code-line">    <span class="token comment">//Lombok 라이브러리의 @RequiredArgsConstructor 어노테이션이</span>
</span><span class="code-line">    <span class="token comment">//연관관계 주입이 필요한 필드를 위해 자동으로 생성자를 만들어줍니다.</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p>놀랍게도 <code>Lombok</code>이라는 라이브러리를 사용했더니 어노테이션 한 줄 붙여줬을 뿐인데 생성자를 작성할 필요가 없어졌습니다! 이는 <code>Lombok</code> 라이브러리가 Java의 <strong>어노테이션 프로세서</strong>라는 기능을 통해 애플리케이션의 컴파일 시점에 생성자 코드를 자동으로 생성해줬기 때문입니다. 컴파일의 결과물인 <code>.class</code> 파일(Java 바이트 코드 파일)을 열어보면 알맞은 생성자가 작성되어 있는 것을 확인할 수 있습니다.</p>
<p>최근 실무에서는 이렇게 생성자를 1개만 둬 <code>@Autowired</code> 어노테이션을 생략하는 방법을 사용한다고 합니다. 거기에 <code>Lombok</code> 라이브러리까지 활용해 코드를 최대한 깔끔하게 만들되 기능은 모두 제공하는 방식으로 코드를 작성한다고 합니다.</p>
<h2 id="중복-빈이-존재할-때" class="heading">중복 빈이 존재할 때</h2>
<p>중복된 Spring 빈, 다시 말해 같은 타입의 빈이 여러개 존재할 경우, <code>NoUniqueBeanDefinitionException</code> 오류가 발생할 수 있습니다. 자동으로 의존관계를 주입해주는 <code>@Autowired</code> 어노테이션은 타입 기반으로 빈을 조회하는데, <a href="https://blog.coderoad.kr/containerandbean" target="_blank" rel="noopener noreferer">Spring 컨테이너와 빈</a> 포스트에서 정리했던 것처럼 동일한 타입의 빈이 존재하면 오류가 발생합니다. 이 오류를 해결하는 방법에는 여러가지가 있지만, <strong>의존관계 자동 주입 방식을 유지하면서 해결</strong>하는 방법들에 대해 알아보겠습니다.</p>
<h3 id="autowired-필드-이름과-빈-이름-매칭">@Autowired 필드 이름과 빈 이름 매칭</h3>
<p>가장 먼저, 간단하면서도 코드 변경도 적은 방법입니다. 예시로 간단한 의존관계 주입 코드를 작성해봤습니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token annotation punctuation">@Autowired</span>
</span><span class="code-line"><span class="token comment">//DiscountPolicy 타입의 Spring 빈이 하나만 있다면 문제 없지만...</span>
</span><span class="code-line"><span class="token keyword">private</span> <span class="token class-name">DiscountPolicy</span> discountPolicy<span class="token punctuation">;</span>
</span></code></pre>
<p>만약, <code>DiscountPolicy</code> 타입의 빈이 여러개 있다면, 오류가 발생할 것입니다. <strong><code>@Autowired</code> 필드 이름 매칭 방식</strong>으로 오류를 해결하려면 다음과 같이 빈 이름을 필드 이름으로 작성해주시면 됩니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token annotation punctuation">@Autowired</span>
</span><span class="code-line"><span class="token comment">//DiscountPolicy 타입의 rateDiscountPolicy Spring 빈을 주입합니다.</span>
</span><span class="code-line"><span class="token keyword">private</span> <span class="token class-name">DiscountPolicy</span> rateDiscountPolicy<span class="token punctuation">;</span>
</span></code></pre>
<p>이렇게 빈 이름을 필드 이름으로 작성하면 <code>DiscountPolicy</code> 타입의 <code>rateDiscountPolicy</code> 빈이 주입됩니다.</p>
<h3 id="qualifier와-primary-활용">@Qualifier와 @Primary 활용</h3>
<p>필드 이름 매칭 방식 외에도 활용할만한 방식이 2가지 더 있습니다. <code>@Qualifier</code>와 <code>@Primary</code> 어노테이션을 활용하는 방법입니다. 먼저 <code>@Qualifier</code> 어노테이션은 빈을 등록할 때, 추가적인 주입 옵션을 부여하는 어노테이션입니다. 사용 방법은 다음과 같습니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token annotation punctuation">@Component</span>
</span><span class="code-line"><span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span><span class="token string">"mainDiscountPolicy"</span><span class="token punctuation">)</span>
</span><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RateDiscountPolicy</span> <span class="token keyword">implements</span> <span class="token class-name">DiscountPolicy</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</span></code></pre>
<p>위와 같이 Spring 빈으로 등록할 클래스에 <code>@Qualifier</code> 어노테이션으로 의존관계 주입 시에 추가적으로 사용할 옵션을 부여할 수 있습니다. <code>@Qualifier</code>를 통해 추가한 옵션은 다음과 같이 의존관계 주입 시 활용할 수 있습니다. 예시로 우리의 주력 의존관계 주입 방식이 되어야 하는 생성자 주입 방식을 사용하겠습니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token annotation punctuation">@Autowired</span>
</span><span class="code-line"><span class="token keyword">public</span> <span class="token class-name">OrderServiceImpl</span><span class="token punctuation">(</span><span class="token class-name">MemberRepository</span> memberRepository<span class="token punctuation">,</span> <span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span><span class="token string">"mainDiscountPolicy"</span><span class="token punctuation">)</span> <span class="token class-name">DiscountPolicy</span> discountPolicy<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword">this</span><span class="token punctuation">.</span>memberRepository <span class="token operator">=</span> memberRepository<span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token keyword">this</span><span class="token punctuation">.</span>discountPolicy <span class="token operator">=</span> discountPolicy<span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p>이렇게 <code>@Qualifier</code>를 사용하면 <code>@Qualifier</code> 어노테이션을 통해 <code>mainDiscountPolicy</code>라는 이름을 옵션으로 추가한 빈을 먼저 매칭하고, 없다면 변수 이름과 동일한 빈 이름을 가진 빈을 매칭합니다.</p>
<p>마지막으로 <code>@Primary</code>는 여러 동일한 타입의 빈들이 있을 경우, <strong>우선 순위</strong>를 지정해주는 어노테이션입니다. <code>@Autowired</code>를 통해 의존관계를 자동 주입할 때, 같은 타입의 빈들이 여러개 매칭되면, <code>@Primary</code> 어노테이션이 붙은 빈이 우선권을 가지게 됩니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token annotation punctuation">@Component</span>
</span><span class="code-line"><span class="token annotation punctuation">@Primary</span> <span class="token comment">//RateDiscountPolicy 빈이 우선 순위가 높습니다.</span>
</span><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RateDiscountPolicy</span> <span class="token keyword">implements</span> <span class="token class-name">DiscountPolicy</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token annotation punctuation">@Component</span>
</span><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FixDiscountPolicy</span> <span class="token keyword">implements</span> <span class="token class-name">DiscountPolicy</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</span></code></pre>
<p>위와 같이 코드를 작성하면 <code>RateDiscountPolicy</code> 빈이 같은 타입을 가진 <code>FixDiscountPolicy</code> 빈 보다 더 높은 우선 순위를 갖고 있게 됩니다. 따라서 다음 코드 실행 시, <code>discountPolicy</code> 필드에는 <code>RateDiscountPolicy</code>가 주입됩니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token annotation punctuation">@Autowired</span>
</span><span class="code-line"><span class="token keyword">public</span> <span class="token class-name">OrderServiceImpl</span><span class="token punctuation">(</span><span class="token class-name">MemberRepository</span> memberRepository<span class="token punctuation">,</span> <span class="token class-name">DiscountPolicy</span> discountPolicy<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">      <span class="token keyword">this</span><span class="token punctuation">.</span>memberRepository <span class="token operator">=</span> memberRepository<span class="token punctuation">;</span>
</span><span class="code-line">      <span class="token keyword">this</span><span class="token punctuation">.</span>discountPolicy <span class="token operator">=</span> discountPolicy<span class="token punctuation">;</span> <span class="token comment">//@Primary가 붙은 RateDiscountPolicy가 주입됩니다.</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p>지금까지 살펴본 바로는 <code>@Qualifier</code>와 <code>@Primary</code> 모두 사용하는데 크게 번거로움은 없어보입니다. 둘 중 아무거나 사용해도 꽤 괜찮은 코드가 완성될 것입니다. 그러나 좀 더 세밀하게 두 어노테이션의 용도를 구분하자면 <code>@Primary</code>는 코드에서 자주 사용하는 빈을 주입해야할 때, <code>@Qualifier</code>는 특별히 지정해줘야하는 빈을 주입해야할 때 사용하는 것이 더 깔끔한 코드를 유지할 수 있습니다.</p>
<p>두 어노테이션 간의 우선 순위는 Spring의 기본적인 우선 순위와도 연관이 있습니다. Spring은 <strong>자동 보다 수동</strong>, <strong>넓은 범위 보다 좁은 범위</strong>가 <strong>우선권을 갖습니다.</strong> 따라서, 더 좁은 범위(특정 빈)를 의존관계 주입 대상으로 지정하는 <code>@Qualifier</code>가 우선권을 갖습니다. 이런 정책 덕분에 특별히 원하는 빈을 주입하고 싶은 곳에만 <code>@Qualifier</code>로 지정해주는 방식이 유효한 것입니다.</p>
<h2 id="조회한-빈이-모두-필요할-때" class="heading">조회한 빈이 모두 필요할 때</h2>
<p>만약, <strong>의도적으로 타입이 중복된 빈들이 모두 필요</strong>한 경우가 생길 때는 어떻게 해야할까요? 너무나 간단하게도 <code>List</code>나 <code>Map</code> 같은 자료구조를 활용해 모든 빈을 일단 컨테이너로부터 불러오고, 필요에 따라 의존관계를 주입하는 방식으로 같은 타입의 여러 빈들을 활용할 수도 있습니다.</p>
<p>이를 소위 <strong>전략 패턴</strong>이라고 합니다. 사용자가 건네준 조건에 따라 다르게 작동해야하는 로직이 있을 때, 타입은 같되 로직이 서로 다른 빈들을 미리 <strong>모두</strong> 준비해두고, Spring 빈 주입 시, 조건에 맞춰 필요한 빈을 유연하게 주입합니다.</p>
<p>전략 패턴을 적절하게 활용하면 추가적인 코드 변경 필요 없이 원하는 로직을 적재적소에 구동할 수 있게 할 수 있습니다. 바로, SOLID의 OCP를 잘 지킨 코드가 되는 것입니다.</p>
<h2 id="자동과-수동-빈-등록-올바른-실무-운영법" class="heading">자동과 수동 빈 등록, 올바른 실무 운영법</h2>
<p>지금까지 상당히 긴 호흡으로 Spring의 의존관계 주입에 대해 알아봤습니다. 어노테이션을 통한 수동 빈 등록과 <a href="https://blog.coderoad.kr/componentscan" target="_blank" rel="noopener noreferer">컴포넌트 스캔</a> 빈 등록, 여러 의존관계 주입 방식들의 장단점 등, Spring이 빈과 의존관계를 다루는 정말 다양한 방식들을 알게 되었는데, 도대체 어떤 방식을 기본으로 사용해야하는 것인지 확신이 서진 않습니다.</p>
<p>천천히 생각해보면 개발자들은 비효율적이고 반복적인 과정을 <strong>직접</strong> 겪어야할 필요가 없습니다. 오히려 그런 과정들을 피할 수 있다면 기존의 방식을 과감하게 포기하고 더 간편하고 효율적인 방식으로 코드를 작성해야합니다. 우리가 사용하는 Spring 생태계는 <strong>자동</strong> 방식들을 선호하고, 더 나아가 자동 방식들을 <strong>기본으로 사용</strong>합니다.</p>
<p>물론, 애플리케이션의 설정 정보를 가지는 <strong>구성자</strong>인 <strong>Java 설정 클래스</strong>나 xml 파일을 통해 애플리케이션의 실제 로직과 구성 정보를 분리해주는 것이 이상적인 코드지만, 개발자는 간편한 컴포넌트 스캔 기능을 포기할 이유가 없습니다. <strong>Spring이 자동 빈 등록 기능을 사용해도 OCP와 DIP를 준수할 수 있도록 돕기 때문에</strong>, Java 설정 클래스를 개발자가 직접 관리하는 것은 오히려 부담스러운 작업이 될 가능성이 높습니다.</p>
<p>기본적으로 자동 빈 등록과 자동 의존관계 주입 방식을 사용하다가, 애플리케이션에 광범위하게 영향을 미치는 <strong>기술 지원 객체나 다형성을 적극 활용해야할 때</strong>, 수동 빈 등록과 주입 방식을 사용하는 것을 추천합니다. 데이터베이스 연결과 같은 애플리케이션 전반에서 필요한 기능을 담당하는 <strong>기술 지원 객체</strong>는 그렇게 많은 수가 필요하지도 않고, 오히려 수동 등록을 통해 어떤 빈인지 명확하게 하는 것이 유지보수에 도움이 된다고 합니다.</p>]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[컴포넌트 스캔]]></title>
    <link>https://blog.coderoad.kr/componentscan</link>
    <pubDate>2023-01-21</pubDate>
    <guid isPermaLink="false">https://blog.coderoad.kr/componentscan</guid>
    <description>
    <![CDATA[Spring 빈을 더 현명하게 관리하기]]>
    </description>
    <content:encoded>
      <![CDATA[<p><strong>본 문서는 인프런에서 수강할 수 있는 <a href="https://inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8" target="_blank" rel="noopener noreferer">스프링 핵심 원리 - 기본편</a>을 수강한 후, 공부한 내용을 정리한 문서입니다. 본 문서의 모든 저작권은 해당 강의의 저자이신 <a href="https://inflearn.com/users/@yh" target="_blank" rel="noopener noreferer">김영한</a> 우아한형제들 기술이사님께 있습니다.</strong></p>
<h2 id="컴포넌트-스캔" class="heading">컴포넌트 스캔?</h2>
<p>우리는 지금까지 Spring 빈을 Spring 컨테이너에 등록할 때, 구성자(Java 설정 클래스)에서 <code>@Bean</code> 어노테이션이나 XML 파일을 통해 등록했습니다. (자세한 설명은 <a href="https://blog.coderoad.kr/iocanddi" target="_blank" rel="noopener noreferer">IoC와 DI</a>와 <a href="https://blog.coderoad.kr/containerandbean" target="_blank" rel="noopener noreferer">Spring 컨테이너와 Bean</a> 문서 참고!) 아주 간단한 Spring 애플리케이션이라면 이 방식도 괜찮지만, 규모가 큰 서비스에서 하나하나 직접 빈을 등록하는 것은 여러 문제점이 있습니다. 개발자가 직접 설정 정보를 작성해야하기 때문에 설정 클래스의 코드가 지나치게 길어지고, 등록해야할 빈을 실수로 빼먹기도 하는 문제가 발생합니다. 더군다나 이런 단순 반복 작업을 개발자가 하게 되는 것 자체가 너무 비효율적입니다.</p>
<p>다행히 Spring이 개발자가 사소한 일에 너무 많은 시간을 쏟지 않도록 자동으로 Spring 빈을 등록해주는 <strong>컴포넌트 스캔</strong>이라는 기능을 제공합니다. 기존에 <code>@Configuration</code> 어노테이션을 붙여 설정 클래스로 지정한 클래스의 빈 등록 코드를 모두 지우고 <code>@ComponentScan</code>이라는 어노테이션을 붙여주면 빈 생성과 등록을 모두 자동으로 합니다!</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token comment">//설정 클래스가 이제 스스로 빈을 생성하고 등록합니다!</span>
</span><span class="code-line"><span class="token annotation punctuation">@Configuration</span>
</span><span class="code-line"><span class="token annotation punctuation">@ComponentScan</span>
</span><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AppConfig</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token comment">//@ComponentScan이 없던 코드와 다르게 클래스 내부가 비어도 괜찮습니다.</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p>이렇게 어노테이션 하나만 추가하고 간단하게 자동 등록 기능이 동작하면 정말 좋겠지만, 그렇지 않습니다. 이 방식을 사용하려면 2가지 선행 조건을 충족해야합니다. <strong>Spring 빈으로 등록하고자 하는 Java 클래스에 <code>@Component</code> 어노테이션</strong>을 붙여줘야 하며, 의존관계를 명시한 코드가 설정 클래스에서 없어졌으니 <strong><code>@Component</code> 어노테이션을 붙인 클래스에서 직접 의존관계 주입</strong>을 해줘야합니다. 그래도 크게 걱정할 필요 없습니다. Spring은 <code>@AutoWired</code> 어노테이션을 통해 의존관계 자동 주입 기능도 제공합니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token annotation punctuation">@Component</span> <span class="token comment">//이제 이 Java 클래스는 Spring 빈입니다.</span>
</span><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MemberServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">MemberService</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">MemberRepository</span> memberRepository<span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token annotation punctuation">@Autowired</span> <span class="token comment">//Spring이 MemberRepository에 대한 의존관계를 자동으로 주입해줍니다.</span>
</span><span class="code-line">    <span class="token keyword">public</span> <span class="token class-name">MemberServiceImpl</span><span class="token punctuation">(</span><span class="token class-name">MemberRepository</span> memberRepository<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">        <span class="token keyword">this</span><span class="token punctuation">.</span>memberRepository <span class="token operator">=</span> memberRepository<span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token punctuation">}</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p>이 기능들의 원리는 의외로 간단한데, <code>@ComponentScan</code>은 <code>@Component</code> 어노테이션이 붙은 모든 클래스를 Spring 빈으로 등록합니다. 이때 빈 이름은 <code>@Bean</code> 방식과 유사하게 클래스명을 사용하되 맨 앞글자만 소문자로 등록합니다. (<code>@Bean</code> 방식은 메소드 명을 이름으로 사용했습니다.) 또한, <code>@Component("이름")</code>과 같이 빈 이름을 직접 지어줄 수도 있습니다.</p>
<p>이렇게 등록된 빈들은 <code>@Autowired</code> 어노테이션이 붙어 있는 생성자나 필드를 만나면 Spring 컨테이너에 의해 조회되고 주입됩니다. 이때, 컨테이너가 사용하는 기본 조회 방식은 타입으로 찾는 방식입니다. <code>getBean(타입.class)</code>와 동일하다고 보면 됩니다.</p>
<h2 id="컴포넌트-스캔-범위-설정" class="heading">컴포넌트 스캔 범위 설정</h2>
<p><code>@ComponentScan</code>을 사용해 빈을 등록하는 방식은 <code>@ComponentScan</code> 어노테이션이 붙은 클래스가 위치한 패키지와 하위 패키지의 모든 Java 클래스를 하나씩 검사하는 방식입니다. 따라서 명확하게 Spring 빈이 아닌 클래스들은 스캔 범위에서 제외해주면 성능 향상에 도움이 됩니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">(</span>
</span><span class="code-line">    <span class="token comment">//컴포넌트 스캔을 시작할 위치를 지정합니다.</span>
</span><span class="code-line">    <span class="token comment">//code.road를 포함해 모든 하위 패키지를 스캔합니다.</span>
</span><span class="code-line">    <span class="token comment">//시작 위치를 여러개 설정할 수도 있습니다.</span>
</span><span class="code-line">    basePackages <span class="token operator">=</span> <span class="token string">"code.road"</span><span class="token punctuation">,</span>
</span><span class="code-line"><span class="token punctuation">)</span>
</span></code></pre>
<p>물론 이렇게 직접 지정할 수도 있지만, 이 글을 작성하게된 강의의 저자이신 김영한님께서 가장 권장하시는 방법은 <strong>시작 위치를 따로 지정하지 않고 Java 설정 클래스(<code>@ComponentScan</code>이 붙은 클래스)를 프로젝트의 최상단에 두는 방법</strong>이었습니다. Spring Boot도 기본적으로 이 방식을 사용하고, 설정 클래스는 프로젝트를 대표하는 정보이기 때문에 최상단에 두는 것이 좋다라고 하셨기 때문에, 저도 프로젝트를 진행하면서 따로 스캔 시작 위치를 지정하지는 않고 있습니다.</p>
<p>추가로 컴포넌트 스캔 기본 대상은 <code>@Component</code> 어노테이션 뿐만 아니라 <code>@Controller</code>, <code>@Service</code>, <code>@Repository</code>, <code>@Configuration</code>도 컴포넌트 스캔 기능의 스캔 대상입니다. 우리가 Spring Web MVC를 공부하고 애플리케이션을 만들면서 자주 사용하게 될 어노테이션입니다. 위 어노테이션을 사용하면 우리가 크게 신경쓰지 않아도 Spring 빈으로 자동 등록됩니다.</p>
<h2 id="필터를-사용해보자" class="heading">필터를 사용해보자</h2>
<p>필터를 통해 컴포넌트 스캔 대상에 추가하거나 제외할 수 있습니다. 예시 코드를 통해 간단하게 필터 사용법을 알아보겠습니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">(</span>
</span><span class="code-line">    <span class="token comment">//BeanA는 스캔 대상에 추가되고</span>
</span><span class="code-line">    includeFilters <span class="token operator">=</span> <span class="token annotation punctuation">@Filter</span><span class="token punctuation">(</span>type <span class="token operator">=</span> <span class="token class-name">FilterType</span><span class="token punctuation">.</span>ASSIGNABLE_TYPE<span class="token punctuation">,</span> classes <span class="token operator">=</span> <span class="token class-name">BeanA</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
</span><span class="code-line">    <span class="token comment">//BeanB는 스캔 대상에서 제외됩니다.</span>
</span><span class="code-line">    excludeFilters <span class="token operator">=</span> <span class="token annotation punctuation">@Filter</span><span class="token punctuation">(</span>type <span class="token operator">=</span> <span class="token class-name">FilterType</span><span class="token punctuation">.</span>ASSIGNABLE_TYPE<span class="token punctuation">,</span> classes <span class="token operator">=</span> <span class="token class-name">BeanB</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
</span><span class="code-line"><span class="token punctuation">)</span>
</span></code></pre>
<p><code>FilterType</code>에 올 수 있는 옵션에는 5가지가 있습니다.</p>
<ul>
<li>ANNOTATION : 기본값으로 어노테이션을 인식해 필터링합니다.</li>
<li>ASSIGNABLE_TYPE : 지정한 타입과 자식 타입을 필터링합니다.</li>
<li>ASPECTJ : AspectJ 패턴을 통해 필터링합니다.</li>
<li>REGEX : 정규 표현식을 통해 필터링합니다.</li>
<li>CUSTOM : <code>TypeFilter</code>라는 인터페이스를 구현해서 필터링합니다.</li>
</ul>
<p>그러나, 스캔 대상에 추가하는 기능은 <code>@Component</code>나 <code>@Service</code> 같은 스캔 대상 어노테이션을 붙여주는 것으로 충분해 거의 사용하지 않습니다. 거기다 스캔 대상에서 제외하는 기능도 사용할 일이 많지 않으며, Spring Boot가 기본적으로 컴포넌트 스캔 기능을 제공하기 때문에, 필터를 사용하지 않는 편이 낫습니다. 그래서 컴포넌트 스캔에 필터라는 기능도 존재한다고 알고 넘어가면 될 것 같습니다.</p>
<h2 id="중복과-충돌" class="heading">중복과 충돌</h2>
<p>컴포넌트 스캔을 이용해 Spring 빈을 <strong>자동</strong> 등록하다보면 빈 이름이 중복되는 문제가 발생할 수 있습니다. 이때, <strong>자동으로 등록된 빈들은</strong> 개발자가 <strong>수동으로 등록한 빈보다 우선 순위가 떨어집니다.</strong> 기존의 Spring 프레임워크는 수동 등록한 빈이 자동으로 등록된 빈을 덮어씌워버리기 때문에 의도하지 않았다면 정말 잡아내기 힘든 버그가 탄생하게 됩니다.</p>
<p>그래서인지 최근 Spring Boot에서는 수동 등록 빈과 자동 등록 빈의 이름 중복으로 등록 과정에서 충돌이 발생하면 덮어씌우지 않고 오류를 발생시킵니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token class-name">Consider</span> renaming one of the beans or enabling overriding by setting spring<span class="token punctuation">.</span>main<span class="token punctuation">.</span>allow<span class="token operator">-</span>bean<span class="token operator">-</span>definition<span class="token operator">-</span>overriding<span class="token operator">=</span><span class="token boolean">true</span>
</span></code></pre>
<p>물론 자동 등록 빈 사이에서도 빈 이름 중복이 발생하면 오류가 발생합니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token class-name">Caused</span> by<span class="token operator">:</span> <span class="token class-name"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span>ConflictingBeanDefinitionException</span><span class="token operator">:</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</span></code></pre>
<p>사실 클래스 이름을 중복해서 작성하지 않는 한, 자주 볼 일 없는 오류지만 주의해야합니다.</p>]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[싱글톤]]></title>
    <link>https://blog.coderoad.kr/singleton</link>
    <pubDate>2023-01-20</pubDate>
    <guid isPermaLink="false">https://blog.coderoad.kr/singleton</guid>
    <description>
    <![CDATA[Spring과 싱글톤 패턴]]>
    </description>
    <content:encoded>
      <![CDATA[<p><strong>본 문서는 인프런에서 수강할 수 있는 <a href="https://inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8" target="_blank" rel="noopener noreferer">스프링 핵심 원리 - 기본편</a>을 수강한 후, 공부한 내용을 정리한 문서입니다. 본 문서의 모든 저작권은 해당 강의의 저자이신 <a href="https://inflearn.com/users/@yh" target="_blank" rel="noopener noreferer">김영한</a> 우아한형제들 기술이사님께 있습니다.</strong></p>
<h2 id="spring과-싱글톤" class="heading">Spring과 싱글톤</h2>
<p>싱글톤 패턴은 클래스의 <strong>인스턴스</strong>가 <strong>딱 1개 생성</strong>되는 것을 <strong>보장</strong>하는 <strong>디자인 패턴</strong>입니다. 따라서 우리가 싱글톤 패턴을 구현할 때, 의도적으로 객체 인스턴스가 2개 이상 생성되지 않게 해야합니다. 제가 갑자기 싱글톤에 대해서 설명하는 이유는, 이 싱글톤 패턴이 Spring과 아주 밀접한 관계가 있기 때문입니다.</p>
<p>웹 애플리케이션은 Spring 애플리케이션의 절대 다수를 차지합니다. Spring 프레임워크가 당시 무겁고 복잡했던 기업용 Java 기술들을 순수하고 편리하게 제공하기 위해 탄생했다는 것을 생각하면 웹 애플리케이션과 Spring은 뗄레야 뗄 수 없는 사이입니다. 그런데 웹 애플리케이션은 다수의 사용자가 동시에 서비스에 접근하게 됩니다. 만약 웹 애플리케이션이 서비스에 접근하는 사용자 모두에게 새로운 서비스 인스턴스를 생성해서 제공한다면, 초당 1천 명만 접속해도 순식간에 1천 개가 넘는 객체가 생성되고 삭제되는 심각한 메모리 낭비가 발생합니다.</p>
<p>이러한 메모리 낭비를 막고자 싱글톤 패턴을 사용해 서비스 객체는 딱 1개만 생성되고 모든 사용자들이 이를 공유하도록 해야합니다. 싱글톤 패턴을 구현하는 방법은 다양합니다. 중요한 것은 애플리케이션이 실행 중인 동안 인스턴스가 1개만 생성되어야 한다는 것입니다. 성공적으로 싱글톤 패턴을 구현했다면, 메모리 낭비가 심해지는 문제를 쉽게 해결할 수 있습니다.</p>
<p>그러나, 이런 싱글톤 패턴에도 문제가 있습니다. 싱글톤 패턴을 직접 구현한다는 것은 결국 핵심 서비스 로직 외에도 추가적인 코드를 작성해야하는 비용이 드는 것이고, 의존 관계상 클라이언트가 구체 클래스(유일한 인스턴스)에 의존하게 됩니다. 이것은 DIP를 위반하게 되는 것으로 <a href="https://blog.coderoad.kr/solid" target="_blank" rel="noopener noreferer">SOLID</a>를 지키지 못한, 나쁜 객체지향 프로그래밍입니다. 또한 구체 클래스에 의존하게 됐기 때문에, OCP도 위반할 가능성이 높습니다.</p>
<p>메모리 낭비를 줄이겠다고 Spring의 근간부터 흔들리고 코드는 잔뜩 꼬여버리는 배보다 배꼽이 더 커져버린 상황이 발생합니다. Spring은 이런 문제를 해결하기 위해 **<a href="https://blog.coderoad.kr/containerandbean" target="_blank" rel="noopener noreferer">Spring 컨테이너</a>**에게 객체 인스턴스를 싱글톤으로 관리하도록 했습니다.</p>
<h2 id="싱글톤-컨테이너" class="heading">싱글톤 컨테이너</h2>
<p><strong>Spring 컨테이너는 싱글톤 컨테이너</strong>의 역할을 담당합니다. 다시 말해서, Spring 컨테이너가 관리하는 Spring 빈들은 모두 싱글톤 패턴으로 관리되는 인스턴스들입니다. 우리가 Spring 컨테이너에 대해 정리했을때, Spring 빈으로 등록한 객체들은 Spring 컨테이너가 인스턴스화하여 가지고 있다가 요청에 따라 의존관계를 주입해준다는 것을 알았습니다.</p>
<p>이렇게 싱글톤 객체를 생성하고 관리하는 기능을 **싱글톤 레지스트리(Singleton Registry)**라고 합니다. Spring 컨테이너의 이런 기능 덕분에 싱글톤 패턴을 직접 구현하면서 발생한 문제들을 해결하고도 인스턴스를 싱글톤으로 유지할 수 있습니다. 즉, 사용자의 요청이 애플리케이션으로 올 때 마다 인스턴스를 생성하는 것이 아니라 이미 만들어진 인스턴스(빈)을 공유해 효율적으로 재사용할 수 있게 된 것입니다.</p>
<p>물론, Spring의 빈 등록 방식은 다양합니다. 기본 방식이 싱글톤일 뿐, 다른 방식도 지정할 수 있습니다.</p>
<h2 id="싱글톤-방식의-주의점" class="heading">싱글톤 방식의 주의점</h2>
<p>싱글톤 방식을 사용할 때 너무나도 중요하고 명심해야하는 점은 Spring 빈을 설계할 때 **무상태(Stateless)**로 설계해야 한다는 것입니다. 싱글톤으로 관리되는 Spring 빈을 공유하는 사용자들은 인스턴스의 공유 가능한 값(클래스 변수)들도 동시다발적으로 접근 가능합니다. 만약 어떤 값을 유지하고 이를 중요 서비스 로직에 사용하도록 빈을 설계했다면 치명적인 오류가 발생할 수 있습니다.</p>
<p>예를 들어, 클래스 변수에 내가 주문한 금액을 저장해두고(Stateful) 이를 통해 은행 계좌에서 주문 금액만큼 인출되도록 서비스 객체를 설계했다고 가정합시다. 이 서비스 객체가 싱글톤 방식으로 관리되고 인스턴스를 모든 사용자가 공유한다면 클래스 변수도 당연히 모든 사용자가 공유하는 변수입니다. 이 변수에 나의 주문 금액을 저장해두어도 다른 사용자가 몇 초 차이로 나중에 주문 서비스를 이용하면 값이 <strong>덮어씌워질 수 있다</strong>는 것입니다.</p>
<p>만약, 난 10만원만 사용했는데 3초 뒤에 다시 주문 서비스를 이용한 사람이 100만원을 사용했고 내가 5초 뒤에 주문을 확정지었다면 나도 모르는 새에 주문 금액은 100만원으로 늘어나는 대형 사고가 발생하는 것입니다. 때문에, 무슨 일이 있어도 싱글톤 방식을 사용할 때는 무조건 무상태(Stateless), 공유 가능한 필드가 없도록 Spring 빈을 설계해야합니다.</p>
<h2 id="configuration" class="heading">@Configuration</h2>
<p>사실 Spring 컨테이너가 싱글톤 컨테이너의 역할을 할 수 있는 것은 <strong>@Configuration</strong> 어노테이션이 붙은 <strong>구성자</strong>, Java 설정 클래스 덕분입니다. 우리가 <strong>@Bean</strong> 어노테이션을 통해 Spring 빈으로 등록한 객체들은 @Configuration 어노테이션이 없으면 싱글톤이 보장되지 않습니다. 도대체 @Configuration에 무슨 비밀이 있길래 이 어노테이션만 붙이면 싱글톤이 보장되는 것일까요?</p>
<p>바로, @Configuration 어노테이션이 활용하는 <code>CGLIB</code>라는 기술에 있습니다. @Configuration 어노테이션은 <code>CGLIB</code> 기술을 통해 Java 설정 클래스에서 <strong>같은 객체를 여러번 <code>new</code> 키워드로 생성해도 처음 생성된 인스턴스를 활용</strong>하도록 <strong>바이트코드를 조작</strong>해 싱글톤을 보장합니다. 즉, 아무리 <code>new</code> 키워드를 여러번 사용해도 바이트코드 단계에서 <code>new</code> 키워드가 새로운 인스턴스를 만들지 않고 기존에 생성된 인스턴스를 반환하도록 합니다. 따라서 Spring 컨테이너가 싱글톤 방식을 사용하도록 하려면, Java 설정 클래스(구성자)에 @Configuration 어노테이션을 잊어선 안됩니다.</p>]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[Spring 컨테이너와 빈]]></title>
    <link>https://blog.coderoad.kr/containerandbean</link>
    <pubDate>2023-01-19</pubDate>
    <guid isPermaLink="false">https://blog.coderoad.kr/containerandbean</guid>
    <description>
    <![CDATA[컨테이너와 빈의 개념 정리]]>
    </description>
    <content:encoded>
      <![CDATA[<p><strong>본 문서는 인프런에서 수강할 수 있는 <a href="https://inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8" target="_blank" rel="noopener noreferer">스프링 핵심 원리 - 기본편</a>을 수강한 후, 공부한 내용을 정리한 문서입니다. 본 문서의 모든 저작권은 해당 강의의 저자이신 <a href="https://inflearn.com/users/@yh" target="_blank" rel="noopener noreferer">김영한</a> 우아한형제들 기술이사님께 있습니다.</strong></p>
<h2 id="spring-컨테이너" class="heading">Spring 컨테이너</h2>
<p>Spring은 <strong><a href="https://blog.coderoad.kr/iocanddi" target="_blank" rel="noopener noreferer">IoC(제어의 역전)</a></strong> 개념을 통해 탄생한 구성자, <strong>컨테이너</strong>로 프로그램의 흐름을 제어합니다. Spring에서의 컨테이너를 <strong>Spring 컨테이너</strong>라고 부릅니다. Spring 컨테이너는 <code>ApplicationContext</code> 인터페이스를 통해 생성하는데, 이 <code>ApplicationContext</code> 자체를 Spring 컨테이너라고 하기도 합니다. 본격적으로 Spring을 활용하기 위해선 이 Spring 컨테이너를 생성해야합니다. 방법은 매우 간단합니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token comment">//'AppConfig.class'는 프로그래머가 작성한 구성 정보를 담은 Java 설정 클래스입니다.</span>
</span><span class="code-line"><span class="token class-name">ApplicationContext</span> applicationContext <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span><span class="token class-name">AppConfig</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></code></pre>
<p>위 코드가 바로 Spring 컨테이너를 생성하는 코드입니다. <code>AnnotationConfigApplicationContext</code>는 <code>ApplicationContext</code> 인터페이스의 구현체로, <code>AppConfig</code>와 같이 구성 정보를 담은 <strong>'어노테이션'</strong> 기반의 <strong>'Java 설정 클래스'</strong>(구성자)를 통해 Spring 컨테이너를 생성합니다. Spring 컨테이너를 생성하는 방식은 다양합니다. 그 중, 대표적인 두 가지가 위의 코드와 같이 어노테이션 기반의 Java 설정 클래스를 통한 생성법과 XML을 기반으로한 생성법입니다. 최근에는 주로 Java 설정 클래스를 통해 Spring 컨테이너를 생성합니다.</p>
<p>우리는 Spring 컨테이너를 생성할 때 Java 설정 클래스(이제 설정 클래스라 작성하겠습니다.)를 활용한다는 것을 알았습니다. 그런데 Spring이 프로그램의 수많은 클래스들 중에 설정 클래스가 무엇인지 어떻게 알 수 있을까요? 또, 어노테이션을 기반으로 한다는데, 어노테이션은 무엇일까요? 당연히 모든 클래스가 설정 클래스가 되는 것은 아닙니다. 프로그램의 구성 정보(DI 정보)를 담고 있다고 해서 자동으로 설정 클래스가 되는 것도 아닙니다. 프로그래머가 설정 클래스로 사용하고자 하는 클래스를 <strong>어노테이션</strong>을 통해 직접 명시해줘야 Spring이 이를 확인하고 컨테이너를 생성하는데 설정 클래스로 등록된 클래스를 활용합니다.</p>
<p>어노테이션은 Java의 문법으로 메타데이터의 일종입니다. 쉽게 설명하자면 해당 코드가 무엇인지 설명해주는 역할을 가집니다. Spring은 여러가지 자체적인 어노테이션들을 가지고 있고, 프로그래머가 이를 사용해 Spring의 기술을 활용할 수 있도록 합니다. 그 중 가장 기초가 되는 것이 바로 순수한 클래스를 설정 클래스로 만들어주는 <code>@Configuration</code> 어노테이션입니다. 클래스 선언문 앞에 해당 어노테이션을 붙혀주면 Spring은 해당 클래스를 자동으로 설정 클래스로 인식하고 그에 맞는 동작들을 수행합니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token comment">//이제 AppConfig 클래스는 Spring에 의해 설정 클래스로 관리됩니다.</span>
</span><span class="code-line"><span class="token annotation punctuation">@Configuration</span>
</span><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AppConfig</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p>이렇게 <code>@Configuration</code> 어노테이션을 통해 설정 클래스로 등록된 <code>AppConfig</code> 클래스는 Spring 컨테이너 생성 시 프로그램의 구성 정보로 활용됩니다. Spring은 <code>AppConfig</code>에 적혀진 대로 객체를 생성하고, 관리하며, 의존관계를 주입합니다. 다시 말해, <code>@Configuration</code> 어노테이션에 의해 설정 클래스로 등록된 <code>AppConfig</code> 클래스는, IoC를 통해 프로그램의 제어권을 가지게 된 Spring 컨테이너에게 해당 프로그램의 설명서 역할을 하는 것입니다. <code>AnnotationConfigApplicationContext</code> 클래스를 기반으로 Spring 컨테이너를 생성하기 위해선 <code>AppConfig</code>와 같은 설정 클래스가 필수입니다.</p>
<h2 id="spring-빈" class="heading">Spring 빈</h2>
<p>Spring 컨테이너는 생성될 때, 구성 정보로 등록한 설정 클래스(<code>@Configuration</code>이 붙은 클래스)에 작성되어 있는 객체들을 모두 생성해서 자기 자신에 등록합니다. 이때, 컨테이너에 등록된 객체들을 **빈(Bean)**이라고 합니다.</p>
<blockquote>
<p>@Configuration 어노테이션 뿐만 아니라 @Component, @Controller 같은 어노테이션으로도 컨테이너에 빈 등록이 가능합니다! 각각 어노테이션들은 다른 포스트에서 설명하도록 하겠습니다.</p>
</blockquote>
<p>물론 이 방식을 사용할 때, 설정 클래스에 있는 모든 요소들이 빈으로 등록되는 것은 아닙니다. <code>@Bean</code> 어노테이션을 붙힌 메소드가 반환하는 객체들이 등록되는 것입니다. 빈은 정확히는 컨테이너 내부의 빈 저장소에 등록되는데, 빈을 불러올 수 있는 키(key) 역할을 하는 **'빈 이름'**과 실제 객체인 **'빈 객체'**가 같이 등록됩니다. 빈 이름은 따로 지정해주지 않으면 <code>@Bean</code>을 붙혀 Spring 빈으로 지정한 메소드 이름으로 자동 저장됩니다. Spring 빈으로 등록하는 법은 다음과 같습니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token comment">//컨테이너 생성에 활용할 구성 정보를 가진 설정 클래스입니다.</span>
</span><span class="code-line"><span class="token annotation punctuation">@Configuration</span>
</span><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AppConfig</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token comment">//Spring 빈으로 등록되었습니다.</span>
</span><span class="code-line">    <span class="token comment">//빈 이름 : memberRepository</span>
</span><span class="code-line">    <span class="token comment">//빈 객체 : MemoryMemberRepository 클래스의 인스턴스</span>
</span><span class="code-line">    <span class="token annotation punctuation">@Bean</span>
</span><span class="code-line">    <span class="token keyword">public</span> <span class="token class-name">MemberRepository</span> <span class="token function">memberRepository</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">        <span class="token comment">//IoC에 의해 해당 객체는 이 곳에서만 생성되고 의존관계가 주입됩니다.</span>
</span><span class="code-line">        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MemoryMemberRepository</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token punctuation">}</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token comment">//빈 이름을 직접 등록할 수도 있습니다.</span>
</span><span class="code-line">    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">"memberServiceBean"</span><span class="token punctuation">)</span>
</span><span class="code-line">    <span class="token keyword">public</span> <span class="token class-name">MemberService</span> <span class="token function">memberService</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MemberServiceImpl</span><span class="token punctuation">(</span><span class="token function">memberRepository</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token punctuation">}</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p>빈 이름을 직접 등록할 때 꼭 주의해야할 점은 이름이 중복되면 안된다는 것입니다. 서로 다른 두 빈이 같은 이름을 가지게 될 경우, 컨테이너에서 다른 하나의 빈은 무시되거나 아예 덮어씌워질 수도 있고 설정에 따라 오류가 발생할 수도 있습니다.</p>
<p>컨테이너의 역할인 생성과 관리(빈을 생성하고 컨테이너에 등록)까지 알아봤습니다. 다음은 가장 중요하다고 할 수 있는 컨테이너의 DI, 의존관계 주입 방식에 대해 알아보겠습니다. Spring은 빈을 생성하고 의존관계를 주입하는 단계가 나뉘어져 있습니다. 위의 코드로 설명하면, <code>@Bean</code> 어노테이션을 확인한 Spring은 그 아래에 있는 메소드들의 이름을 빈 이름으로, 그 메소드가 반환하는 객체들을 빈 객체로 Spring 컨테이너에 등록합니다. 이후, 메소드 안에 작성되어 있는 의존관계 정보(MemberServiceImpl 클래스는 memberRepository 빈에 의존합니다.)를 확인하고 그 의존관계를 주입해줍니다. 그런데, 위 코드와 같이 Java 설정 클래스를 통해 빈을 등록하면 생성자를 호출함과 동시에 의존관계도 주입됩니다. 즉, 단계가 나누어지지 않는다는 말입니다. 자세한 내용은 의존관계 자동 주입 파트에서 설명하겠습니다. 지금 가지고 가야할 정보는 설정 클래스를 활용해서 만들어진 Spring 빈은 생성될 때 의존관계가 자동으로 주입된다는 것입니다.</p>
<h2 id="컨테이너의-빈-조회하기" class="heading">컨테이너의 빈 조회하기</h2>
<p>이제 Spring 컨테이너를 생성하고 Spring 빈을 등록하는 방법까지 알아봤습니다. 이제 빈이 잘 등록되어 있는지 확인하는(혹은 빈을 활용하고자 객체를 불러오는) 방법에 대해 알아보겠습니다.</p>
<h2 id="모두-조회하기" class="heading">모두 조회하기</h2>
<p>먼저 Spring에 등록된 모든 빈 정보를 확인할 수 있는 방법입니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token comment">//설정 클래스 AppConfig를 구성 정보로 하는 어노테이션 기반 Spring 컨테이너 생성</span>
</span><span class="code-line"><span class="token class-name">AnnotationConfigApplicationContext</span> ac <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span><span class="token class-name">AppConfig</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token keyword">void</span> <span class="token function">findAllBean</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token comment">//빈 이름들을 모두 받아온 후</span>
</span><span class="code-line">    <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> beanDefinitionNames <span class="token operator">=</span> ac<span class="token punctuation">.</span><span class="token function">getBeanDefinitionNames</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token comment">//해당 빈 이름을 가진 빈 객체를 받아와서</span>
</span><span class="code-line">    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">String</span> beanDefinitionName <span class="token operator">:</span> beanDefinitionNames<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">        <span class="token class-name">Object</span> bean <span class="token operator">=</span> ac<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>beanDefinitionName<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">        <span class="token comment">//출력</span>
</span><span class="code-line">        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"name = "</span> <span class="token operator">+</span> beanDefinitionName <span class="token operator">+</span> <span class="token string">" object = "</span> <span class="token operator">+</span> bean<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token punctuation">}</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p>현재 Spring에서 관리하고 있는 모든 Spring 빈을 출력하는 방법입니다. <code>ac.getBeanDefinitionNames()</code>을 통해 Spring에 등록된 모든 빈 이름을 조회하고, <code>ac.getBean()</code>으로 조회한 빈 이름을 가진 빈 객체(인스턴스)를 조회합니다. 여기서 <code>ac</code>는 Spring 컨테이너 인스턴스를 담은 변수입니다. 당연히 이 이름은 바뀔 수 있습니다.</p>
<p>그러나 조금 아쉬운 점이 있습니다. 위의 방식을 사용하면 내가 등록한 Spring 빈 뿐만 아니라 Spring 자체적으로 등록한 Spring 빈들도 모두 조회됩니다. 내가 직접 등록한 빈들만 확인하려면 어떻게 해야할까요? 방법은 다음과 같습니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token comment">//설정 클래스 AppConfig를 구성 정보로 하는 어노테이션 기반 Spring 컨테이너 생성</span>
</span><span class="code-line"><span class="token class-name">AnnotationConfigApplicationContext</span> ac <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span><span class="token class-name">AppConfig</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token keyword">void</span> <span class="token function">findApplicationBean</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token comment">//빈 이름들을 모두 받아온 후</span>
</span><span class="code-line">    <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> beanDefinitionNames <span class="token operator">=</span> ac<span class="token punctuation">.</span><span class="token function">getBeanDefinitionNames</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token comment">//해당 빈 이름을 가진 빈 객체를 받아와서</span>
</span><span class="code-line">    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">String</span> beanDefinitionName <span class="token operator">:</span> beanDefinitionNames<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">        <span class="token class-name">BeanDefinition</span> beanDefinition <span class="token operator">=</span> ac<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>beanDefinitionName<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">        <span class="token comment">//해당 빈 이름을 가진 빈 객체의 속성을 확인한 후</span>
</span><span class="code-line">        <span class="token comment">//직접 등록한 애플리케이션 빈일 경우</span>
</span><span class="code-line">        <span class="token keyword">if</span> <span class="token punctuation">(</span>beanDefinition<span class="token punctuation">.</span><span class="token function">getRole</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token class-name">BeanDefinition</span><span class="token punctuation">.</span>ROLE_APPLICATION<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">            <span class="token class-name">Object</span> bean <span class="token operator">=</span> ac<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>beanDefinitionName<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">            <span class="token comment">//출력</span>
</span><span class="code-line">            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"name = "</span> <span class="token operator">+</span> beanDefinitionName <span class="token operator">+</span> <span class="token string">" object = "</span> <span class="token operator">+</span> bean<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">        <span class="token punctuation">}</span>
</span><span class="code-line">        <span class="token comment">//Role ROLE_APPLICATION: 직접 등록한 애플리케이션 빈</span>
</span><span class="code-line">        <span class="token comment">//Role ROLE_INFRASTRUCTURE: 스프링이 내부에서 사용하는 빈</span>
</span><span class="code-line">    <span class="token punctuation">}</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p>내가 직접 등록한 빈을 **'애플리케이션 빈'**이라고 합니다. Spring 내부의 빈과 애플리케이션 빈은 <code>getRole()</code> 메소드의 결과값으로 구분할 수 있습니다. <code>beanDefinition.getRole()</code>의 결과값은 <code>beanDefinition</code>에 저장해두었던 빈 이름을 가진 빈의 역할입니다. 만약 프로그래머가 직접 등록한 빈이라면 <code>ROLE_APPLICATION</code>이라는 결과값이 나옵니다. 이를 통해 내가 등록한 빈만 확인할 수 있습니다.</p>
<h3 id="기본-방식">기본 방식</h3>
<p>간단하게 정리하자면 Spring 컨테이너에서 빈을 찾는 가장 기본적인 방법은 <code>ac.getBean(빈 이름, 타입)</code>이나 <code>ac.getBean(타입)</code>입니다. 만약 이 방법으로 조회했는데 찾고자하는 Spring 빈이 존재하지 않는다면 다음과 같은 예외가 발생합니다. <code>NoSuchBeanDefinitionException: No bean named '' available</code></p>
<p>기본 방식을 사용할 때 주의해야할 점은 조회 코드의 <code>타입</code> 인자에 구현체 타입을 대입해서 조회하면 유연성이 떨어진다는 것입니다. 프로그래머는 추상화에 의존해야하지 구현체에 의존해서는 안 된다는 <strong>DIP</strong>를 항상 기억합시다!</p>
<h3 id="동일한-타입-존재-시">동일한 타입 존재 시</h3>
<p>만약 동일한 타입의 빈이 여러개 저장되어 있다면 <code>타입</code> 인자만 넣어서 조회할 시 오류가 발생합니다. 이때는 <code>ac.getBean(빈 이름, 타입)</code> 메소드를 사용해서 찾고자하는 빈의 이름을 정확하게 지정해줘야합니다.</p>
<p>혹은, <code>ac.getBeansOfType(타입)</code>을 사용해 인자로 넘겨준 타입의 모든 빈을 조회할 수도 있습니다. 기본적으로 Spring 빈의 이름은 어노테이션을 통해 직접 지정하거나 메소드의 이름으로 자동 지정되기 때문에 여러 빈을 한 번에 조회해도 내가 찾고자하는 빈을 쉽게 찾을 수 있습니다.</p>
<h3 id="상속-관계">상속 관계</h3>
<p>Spring 빈은 Spring 컨테이너가 관리하는 Java 객체이기 때문에 당연히 <strong>상속 관계도 가지고 있습니다.</strong> 부모 타입으로 빈을 조회하면 자식 타입을 가지는 빈들도 모두 조회됩니다. 이러한 특징을 이용해 <code>Object</code> 타입으로 빈을 조회하면 모든 Spring 빈을 조회할 수 있습니다.</p>
<h2 id="beanfactory와-applicationcontext" class="heading">BeanFactory와 ApplicationContext</h2>
<p>우리는 지금까지 <code>ApplicationContext</code>만으로 Spring 컨테이너를 구현했습니다. 그런데 이 <code>ApplicationContext</code>의 상위 인터페이스가 존재합니다. 바로 <code>BeanFactory</code> 인터페이스입니다. <code>BeanFactory</code>는 Spring 컨테이너의 최상위 인터페이스로 Spring 빈을 관리하고 조회하는 역할을 담당합니다. 바로 이 인터페이스에서 <code>getBean()</code>을 제공합니다. 지금까지 우리가 알아본 대부분의 기능들을 이 <code>BeanFactory</code>가 제공합니다.</p>
<p><code>ApplicationContext</code>은 <code>BeanFactory</code>를 상속받아 모든 기능들을 제공합니다. 그렇다면 <code>ApplicationContext</code>를 사용하는 이유는 무엇일까요? 당연한 말이지만 애플리케이션을 개발할 때는 빈의 관리와 조회 뿐만 아니라 다른 부가 기능들도 필요합니다.</p>
<p><code>ApplicationContext</code>는 <code>BeanFactory</code>를 비롯해 애플리케이션 국제화를 위한 <code>MessageSource</code> 인터페이스, 로컬, 개발, 운영을 구분해서 처리하기 위해 지정하는 환경 변수를 다루는 <code>EnvironmentCapable</code> 인터페이스 등을 추가로 상속받아 더 풍부한 편의 기능들을 제공합니다. 덕분에 우리가 <code>BeanFactory</code>를 직접 사용할 일은 거의 없습니다. 대부분의 경우에 <code>ApplicationContext</code>를 사용합니다.</p>
<p>물론 <code>BeanFactory</code>, <code>ApplicationContext</code> 두 인터페이스 모두 Spring 빈을 관리하고 조회하기 때문에 Spring 컨테이너입니다.</p>
<h2 id="beandefinition" class="heading">BeanDefinition</h2>
<p>우리는 지금까지 Spring 컨테이너가 <strong>어노테이션</strong>과 <strong>Java 설정 클래스</strong>(AppConfig 클래스)를 통해 설정 정보를 읽어와 Spring 빈을 생성하고 DI(의존관계 주입)를 진행한다는 것도 알아봤습니다. 그런데 앞서 Java 설정 클래스 방식뿐만 아니라 XML을 통한 설정법도 있다고 언급했습니다. 물론 지금은 잘 사용하지 않는 오래된 방식이지만 여전히 사용 중인 레거시 프로젝트들이 있기에 정상적으로 지원되고 있습니다. Spring은 어떻게 다양한 설정 방식을 지원하는 것일까요? 그 비밀은 바로 <code>BeanDefinition</code> 인터페이스에 있습니다.</p>
<p><code>BeanDefinition</code>은 XML 방식을 사용하든 Java 설정 클래스를 사용하든 개발자가 작성한 설정 정보를 기반으로 빈 설정 메타데이터를 가지게 됩니다. 그렇기에 Spring 컨테이너는 개발자가 어떤 방식을 사용(구현)했는지 알 필요 없이 <code>BeanDefintion</code>만 알고 있다면 적절하게 빈들을 생성하고, 관리하고 각종 기능들을 제공할 수 있습니다. 즉, 세상을 <strong>역할</strong>과 <strong>구현</strong>으로 나누는 <strong>다형성</strong>을 통해 실제 구현체(Java 설정 클래스나 XML 파일)가 무엇이든 <code>BeanDefinition</code>이라는 역할(추상화)에만 의존하는 것입니다. 덕분에 컨테이너는 유연하게 다양한 설정 지정 방식을 지원할 수 있게 된 것입니다.</p>
<p>사실 실무에서 이 <code>BeanDefinition</code>을 직접 다룰 일은 거의 없다고 합니다. 이 <code>BeanDefinition</code>을 깊이 있게 알기보다 어떤 방식으로 Spring이 다양한 형태의 설정 정보를 다루는지를 알기 위해 공부하는 것이 좋을 것 같습니다. 중요한 점은 Spring이 설정 정보를 다루는 과정에서 <strong>다형성</strong>을 활용한다는 것입니다. 그만큼 OOP에 대해 제대로 공부해야만 Spring을 온전히 내 기술로 다룰 수 있을 것 같습니다.</p>]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[캐시와 조건부 요청 헤더]]></title>
    <link>https://blog.coderoad.kr/cache</link>
    <pubDate>2023-01-18</pubDate>
    <guid isPermaLink="false">https://blog.coderoad.kr/cache</guid>
    <description>
    <![CDATA[HTTP 캐시와 조건부 요청 헤더란?]]>
    </description>
    <content:encoded>
      <![CDATA[<p><strong>본 문서는 인프런에서 수강할 수 있는 <a href="https://www.inflearn.com/course/http-%EC%9B%B9-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC" target="_blank" rel="noopener noreferer">모든 개발자를 위한 HTTP 웹 기본 지식</a>을 수강한 후, 공부한 내용을 정리한 문서입니다. 본 문서의 모든 저작권은 해당 강의의 저자이신 <a href="https://inflearn.com/users/@yh" target="_blank" rel="noopener noreferer">김영한</a> 우아한형제들 기술이사님께 있습니다.</strong></p>
<h2 id="캐시란" class="heading">캐시란?</h2>
<p>캐시가 없다면... 같은 리소스를 매번 다운로드. 인터넷 네트워크는 매우 느리고 비싸다. 브라우저 속도도 당연히 느려지고, 사용자도 느린 속도에 불편함을 경험한다.
"cache-control: max-age=시간(초)" 헤더를 통해 캐시를 적용할 수 있다. 처음 요청을 제외하곤 항상 브라우저 캐시 저장소를 먼저 방문해서 캐시 유무를 확인한다.
그러나 max-age 속성에 정해둔 시간이 지나면 캐시는 자동으로 삭제된다.(캐시 시간 초과) 그러면 서버에서 다시 다운로드 해야한다. 이를 해결하기 위해 검증 헤더와 조건부 요청을 사용한다.</p>
<h2 id="검증-헤더와-조건부-요청" class="heading">검증 헤더와 조건부 요청</h2>
<p>검증 헤더 "Last-Modified: (날짜)"를 추가해 데이터가 마지막으로 수정된 시간을 기준으로 시간 초과된 캐시 데이터와 서버의 데이터가 아직 일치하다면 기존 캐시 데이터 계속 이용 가능. (서버는 304 Not Modified 상태 코드를 보내 캐시를 재사용해도 좋다고 알린다. Not Modified는 HTTP Body가 없다. 데이터를 바꿀 필요도 없고 용량을 절약해야하기 때문.)</p>
<p>검증 헤더
캐시 데이터와 서버 데이터가 같은지 검증하는 데이터
Last-Modified, ETag</p>
<p>조건부 요청 헤더
검증 헤더로 조건에 따른 분기
If-Modified-Since: Last-Modified 사용
If-None-Match: ETag 사용
조건이 만족하면 200 OK
조건이 만족하지 않으면 304 Not Modified</p>
<p>Last-Modified, If-Modified-Since 단점
1초 미만의 캐시 조정 불가. 날짜 기반의 로직 사용해야함. 데이터를 수정해서 날짜는 다른데 정작 데이터 내용은 같으면 캐시 유지 불가. 서버에서 별도의 캐시 로직을 다루지 못함.</p>
<p>ETag(Entitiy Tag)
캐시용 데이터에 임의의 고유한 버전 이름을 달아둠.
데이터가 변경되면 이 이름을 바꿈. ETag가 같으면 캐시 유지, 다르면 갱신.
캐시 제어 로직을 서버에서 완전히 관리. (ETag 부여를 서버에서 한다.)</p>
<h2 id="캐시와-조건부-요청-헤더" class="heading">캐시와 조건부 요청 헤더</h2>
<p>캐시 제어 헤더
Cache-Control : 캐시 제어
Pragma : 캐시 제어(하위 호환, HTTP 구 버전을 위함)
Expires : 캐시 유효 기간(하위 호환, HTTP 구 버전을 위함)</p>
<p>Cache-Control: max-age : 유효 시간
Cache-Control: no-cache : 데이터는 캐시 가능. 그러나 항상 원 서버에 검증 요청.
Cache-Control: no-store : 데이터에 민감한 정보 있음. 캐시 불가.</p>
<p>검증 헤더
ETag
Last-Modified</p>
<p>조건부 요청 헤더
If-Match, If-None-Match : ETag 사용
If-Modified-Since, If-Unmodified-Since : Last-Modified 사용</p>
<h2 id="프록시-캐시" class="heading">프록시 캐시</h2>
<p>서버와 서버 사이의 거리는 매우 멀다. 한국의 클라이언트와 미국의 서버(오리진 서버)가 직통으로 통신하면 응답이 느리게 도착한다. 그래서 보통 통신 중간에 캐시 데이터를 저장해두는 프록시 캐시 서버를 두어 응답 속도를 높인다. 이때 클라이언트에 있는 캐시를 private 캐시, 프록시 캐시 서버에 있는 캐시를 public 캐시라고 한다.</p>
<p>Cache-Control: public (프록시 캐시 서버에 저장해도 무방함.)
Cache-Control: private (해당 응답이 사용자만을 위한 것. 프록시 캐시 서버에 저장 불가.)
Cache-Control: s-maxage (프록시 캐시에만 적용되는 max-age)
Age: 60 (오리진 서버의 응답 후 프록시 캐시 내에 머문 시간)</p>
<h2 id="캐시-무효화" class="heading">캐시 무효화</h2>
<p>Cache-Control: no-cache, no-store, must-revalidate (원 서버에 데이터 검증을 항상 받고, 캐시로 저장하지 않으며, 원 서버에 검증받아야 하고 만일 서버 접근 실패 시 504 Gateway Timeout이 발생해야함.)
Pragma: no-cache (HTTP/1.0 하위 호환)</p>
<p>no-cache는 만일 원 서버에 접근이 불가하면 오류대신 기존의 데이터를 사용하는 편이 낫다고 판단하고. 시간이 초과된 캐시 데이터를 계속 사용하게 하지만. must-validate는 504 Gateway Timeout 상태 코드를 반환해 캐시를 삭제시킨다.</p>]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[HTTP]]></title>
    <link>https://blog.coderoad.kr/http</link>
    <pubDate>2023-01-18</pubDate>
    <guid isPermaLink="false">https://blog.coderoad.kr/http</guid>
    <description>
    <![CDATA[웹 개발을 한다면 무조건 알아야 할 HTTP]]>
    </description>
    <content:encoded>
      <![CDATA[<p><strong>본 문서는 인프런에서 수강할 수 있는 <a href="https://www.inflearn.com/course/http-%EC%9B%B9-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC" target="_blank" rel="noopener noreferer">모든 개발자를 위한 HTTP 웹 기본 지식</a>을 수강한 후, 공부한 내용을 정리한 문서입니다. 본 문서의 모든 저작권은 해당 강의의 저자이신 <a href="https://inflearn.com/users/@yh" target="_blank" rel="noopener noreferer">김영한</a> 우아한형제들 기술이사님께 있습니다.</strong></p>
<h2 id="http의-시대" class="heading">HTTP의 시대</h2>
<p>HTTP 메시지에 모든 것을 전송. HTML, Text, 이미지, 음악, 영상, 파일, JSON, XML, 거의 모든 형태의 데이터 전송 가능. Server to Server 데이터 통신에도 사용</p>
<h2 id="클라이언트-서버-구조" class="heading">클라이언트-서버 구조</h2>
<p>Request - Response 구조
클라이언트는 서버에 요청을 보내고 서버의 응답을 대기
서버가 요청에 대한 결과를 만들어서 응답</p>
<h2 id="stateful과-stateless" class="heading">Stateful과 Stateless</h2>
<p>HTTP는 무상태(Stateless) 프로토콜이다. 서버가 클라이언트의 상태를 보존하지 않는다. 덕분에 서버 확장성(서버 확충)이 높다. 단점은 클라이언트가 매번 추가 데이터를 전송해야한다.
Stateful에서는 이전 요청에 대한 상태를 기억하고 있다. 그런데 한 명의 사용자에게 하나의 서버를 계속 붙여주는 것이 아니기 때문에 중간에 다른 서버에서 응답을 줘야하는 상황에서는 이전 상황에 대해 아는 것이 없어 제대로 된 데이터 통신이 불가능하다. 무상태에서는 현재 상태에 대한 정보를 클라이언트에서 계속 보내주어 이러한 문제가 해결 가능하다.</p>
<p>그러나 모든 상황에서 무상태를 사용할 수 있는 것은 아니다. (로그인 유지는 모든 서버가 알아야 한다.) 그래도 상태 유지는 최소한으로 사용해야한다.</p>
<h2 id="비연결성connectionless" class="heading">비연결성(Connectionless)</h2>
<p>HTTP는 비연결성 프로토콜이다. HTTP는 서버가 클라이언트의 요청에 대한 응답을 완료하면 즉시 연결을 끊는다. 서버 자원의 낭비를 막을 수 있다. 다만 매번 새로 연결을 해야하기 때문에 3 way handshake(SYN, SYN+ACK, ACK)이 매번 발생. 매번 수많은 리소스들이 다시 다운로드됨. 이 문제는 HTTP 지속 연결로 해결. 최신 버전인 HTTP/2, HTTP/3에선 최적화.</p>
<h2 id="http-메시지" class="heading">HTTP 메시지</h2>
<p>start-line -> header -> (공백(CRLF)) -> message body</p>]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[HTTP 헤더]]></title>
    <link>https://blog.coderoad.kr/httpheader</link>
    <pubDate>2023-01-18</pubDate>
    <guid isPermaLink="false">https://blog.coderoad.kr/httpheader</guid>
    <description>
    <![CDATA[HTTP의 필수 정보들이 담기는 곳]]>
    </description>
    <content:encoded>
      <![CDATA[<p><strong>본 문서는 인프런에서 수강할 수 있는 <a href="https://www.inflearn.com/course/http-%EC%9B%B9-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC" target="_blank" rel="noopener noreferer">모든 개발자를 위한 HTTP 웹 기본 지식</a>을 수강한 후, 공부한 내용을 정리한 문서입니다. 본 문서의 모든 저작권은 해당 강의의 저자이신 <a href="https://inflearn.com/users/@yh" target="_blank" rel="noopener noreferer">김영한</a> 우아한형제들 기술이사님께 있습니다.</strong></p>
<h2 id="http-헤더" class="heading">HTTP 헤더</h2>
<p>header-field = field-name":" OWS field-value OWS (OWS : 띄어쓰기 허용)
field-name은 대소문자 구분 없음. (ex. Host: <a href="http://www.google.com" target="_blank" rel="noopener noreferer">www.google.com</a> )
HTTP 전송에 필요한 모든 부가 정보. 표준 헤더가 너무 많다... 필요할 땐 임의 헤더 추가 가능.</p>
<p>HTTP Body
RFC723X 시리즈에 와서 엔티티는 표현(Representation). Representation = representation metadata + representation data. 즉, 표현 = 표현 메타데이터 + 표현 데이터.</p>
<p>메시지 본문을 통해 표현 데이터 전달. 메시지 본문 = 페이로드(payload). 표현은 요청이나 응답에서 전달할 실제 데이터. 표현 헤더는 표현 데이터를 해석할 수 있는 정보 제공.</p>
<h2 id="표현" class="heading">표현</h2>
<p>Content-Type : 표현 데이터의 형식
Content-Encoding : 표현 데이터의 압축 방식
Content-Language : 표현 데이터의 자연 언어
Content-Length : 표현 데이터의 길이</p>
<p>표현 헤더는 전송, 응답 둘다 사용</p>
<h2 id="협상콘텐츠-네고시에이션" class="heading">협상(콘텐츠 네고시에이션)</h2>
<p>Accept : 클라이언트가 선호하는 미디어 타입 전달
Accept-Charset : 클라이언트가 선호하는 문자 인코딩
Accept-Encoding : 클라이언트가 선호하는 압축 인코딩
Accept-Language : 클라이언트가 선호하는 자연 언어</p>
<p>협상 헤더는 요청 시에만 사용</p>
<p>협상과 우선순위
0 ~ 1 클수록 높은 우선순위, 생략하면 1, 구체적인 것이 우선한다. 구체적인 것을 기준으로 미디어 타입을 맞춘다.</p>
<h2 id="전송-방식" class="heading">전송 방식</h2>
<p>단순 전송(Content-Length), 압축 전송(Content-Encoding), 분할 전송(Transfer-Encoding), 범위 전송(Range, Content-Range)</p>
<h2 id="일반-정보" class="heading">일반 정보</h2>
<p>From : 유저 에이전트의 이메일 정보
Referer : 이전 웹 페이지 주소
User-Agent : 유저 에이전트 애플리케이션 정보
Server : 요청을 처리하는 오리진 서버의 소프트웨어 정보
Date : 메시지가 생성된 날짜</p>
<h2 id="특별한-정보" class="heading">특별한 정보</h2>
<p>Host : 요청한 호스트 정보 (도메인)
Location : 페이지 리다이렉션
Allow : 허용 가능한 HTTP 메소드
Retry-After : 유저 에이전트가 다음 요청을 하기까지 기다려야 하는 시간</p>
<h2 id="인증" class="heading">인증</h2>
<p>Authorization : 클라이언트 인증 정보를 서버에 전달
WWW-Authenticate : 리소스 접근시 필요한 인증 방법 정의</p>
<h2 id="쿠키" class="heading">쿠키</h2>
<p>Set-Cookie : 서버에서 클라이언트로 쿠키 전달(응답)
Cookie : 클라이언트가 서버에서 받은 쿠키를 저장하고, HTTP 요청 시 서버로 전달</p>
<p>생명주기 Expires, max-age
도메인 명시: 명시한 문서 기준 도메인 + 서브 도메인 포함. 생략: 현재 문서 기준 도메인만 적용
경로 : 이 경로를 포함한 하위 경로 페이지만 쿠키 접근
보안 : Secure(https에서만 전송), HttpOnly(자바스크립트의 쿠키 접근 불가.) SameSite(요청 도메인과 쿠키에 설정된 도메인이 같은 경우에만 쿠키 전송)</p>]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[HTTP 메소드]]></title>
    <link>https://blog.coderoad.kr/httpmethod</link>
    <pubDate>2023-01-18</pubDate>
    <guid isPermaLink="false">https://blog.coderoad.kr/httpmethod</guid>
    <description>
    <![CDATA[HTTP는 어떻게 동작할까?]]>
    </description>
    <content:encoded>
      <![CDATA[<p><strong>본 문서는 인프런에서 수강할 수 있는 <a href="https://www.inflearn.com/course/http-%EC%9B%B9-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC" target="_blank" rel="noopener noreferer">모든 개발자를 위한 HTTP 웹 기본 지식</a>을 수강한 후, 공부한 내용을 정리한 문서입니다. 본 문서의 모든 저작권은 해당 강의의 저자이신 <a href="https://inflearn.com/users/@yh" target="_blank" rel="noopener noreferer">김영한</a> 우아한형제들 기술이사님께 있습니다.</strong></p>
<h2 id="http-api-만들기" class="heading">HTTP API 만들기</h2>
<p>URI는 리소스만 고려해야한다. 행동(등록, 조회, 수정, 삭제)는 URI에 포함시키지 않는다.</p>
<h2 id="get" class="heading">GET</h2>
<p>리소스 조회</p>
<h2 id="post" class="heading">POST</h2>
<p>클라이언트에서 서버로 데이터를 전송해 서버가 처리하도록 전달하는 메소드. 메시지 바디를 통해 전달하며 주로 전달된 데이터로 신규 리소스 등록, 프로세스 처리 등에 사용한다.</p>
<h2 id="put" class="heading">PUT</h2>
<p>리소스 데이터 등록. 기존 데이터가 있다면 완전히 지우고 요청한 데이터 등록. (덮어쓰기)</p>
<h2 id="patch" class="heading">PATCH</h2>
<p>리소스 데이터 수정. 기존 데이터를 수정한다.</p>
<h2 id="delete" class="heading">DELETE</h2>
<p>리소스 데이터 삭제.</p>
<h2 id="http-메소드의-속성들" class="heading">HTTP 메소드의 속성들</h2>
<p>안전, 멱등, 캐시 가능</p>
<h2 id="클라이언트에서-서버로" class="heading">클라이언트에서 서버로</h2>
<p>크게 두가지 방식. 쿼리 파라미터를 통한 전송 (GET, 주로 정렬 필터(검색어)), 메시지 바디를 통한 데이터 전송 (POST, PUT, PATCH 회원 가입, 상품 주문, 리소스 등록, 리소스 변경). 4가지 상황 (정적 데이터 조회(GET, 리소스 경로), 동적 데이터 조회(GET, 쿼리 파라미터), HTML Form (GET(조회)/POST(저장), multipart/form-data), HTTP API (Server to server, App, Web, POST/PUT/PATCH, GET, Content-Type:application/json))</p>
<h2 id="http-api-설계-예시" class="heading">HTTP API 설계 예시</h2>
<p>HTTP API - 컬렉션 (POST 기반 리소스 등록) : 서버가 리소스의 URI를 관리 POST /members -> 서버가 /members/{id} 생성 후 저장
HTTP API - 스토어 (PUT 기반 리소스 등록) : 클라이언트가 리소스의 URI를 관리 PUT /filse/{filename} -> 서버는 저장
HTML FORM 사용 (GET/POST) : DELETE 같은 HTTP 메소드 사용 불가, 컨트롤러(컨트롤 URI, 동사 형태의 API)를 사용해야함. POST /members/{id}/delete</p>]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[HTTP 상태코드]]></title>
    <link>https://blog.coderoad.kr/httpstatus</link>
    <pubDate>2023-01-18</pubDate>
    <guid isPermaLink="false">https://blog.coderoad.kr/httpstatus</guid>
    <description>
    <![CDATA[404? 500? 200? 헷갈리는 HTTP의 상태코드들]]>
    </description>
    <content:encoded>
      <![CDATA[<p><strong>본 문서는 인프런에서 수강할 수 있는 <a href="https://www.inflearn.com/course/http-%EC%9B%B9-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC" target="_blank" rel="noopener noreferer">모든 개발자를 위한 HTTP 웹 기본 지식</a>을 수강한 후, 공부한 내용을 정리한 문서입니다. 본 문서의 모든 저작권은 해당 강의의 저자이신 <a href="https://inflearn.com/users/@yh" target="_blank" rel="noopener noreferer">김영한</a> 우아한형제들 기술이사님께 있습니다.</strong></p>
<h2 id="http-상태코드" class="heading">HTTP 상태코드</h2>
<p>클라이언트가 보낸 요청의 처리 상태를 응답에서 알려주는 기능. 클라이언트에서는 상위 상태코드로 상태를 해석한다. (2XX이면 성공!)</p>
<h2 id="2xx---successful" class="heading">2XX - Successful</h2>
<ul>
<li>
<p><strong>200 OK</strong>
요청 성공</p>
</li>
<li>
<p><strong>201 Created</strong>
요청 성공으로 새로운 리소스 생성</p>
</li>
<li>
<p><strong>202 Accepted</strong>
요청 접수되었으나 처리 미완 (배치 처리)</p>
</li>
<li>
<p><strong>204 No Content</strong>
요청 성공적으로 수행, 그러나 응답 메시지로 보낼 데이터 없음 (게시글 Save 버튼)</p>
</li>
</ul>
<h2 id="3xx---redirection" class="heading">3XX - Redirection</h2>
<h3 id="영구-리다이렉션">영구 리다이렉션</h3>
<p>리소스의 URI가 영구적으로 변경. 원래의 URL 사용하지 않음. 검색 엔진에서도 변경해야함.</p>
<ul>
<li>
<p><strong>301 Moved Permanently</strong>
리다이렉트 시 요청 메소드가 GET으로 변하고, 본문(메시지 바디)이 제거될 수도 있음.</p>
</li>
<li>
<p><strong>308 Permanent Redirect</strong>
리다이렉트 시 요청 메소드와 본문을 유지(첫 요청과 동일하게 유지).</p>
</li>
</ul>
<h3 id="일시적-리다이렉션">일시적 리다이렉션</h3>
<p>리소스의 URI가 일시적으로 변경. 검색 엔진에서 절대 변경되면 안됨.</p>
<ul>
<li>
<p><strong>302 Found</strong>
리다이렉트 시 요청 메소드가 GET으로 변하고, 본문이 제거될 수도 있음.</p>
</li>
<li>
<p><strong>307 Temporary Redirect</strong>
리다이렉트 시 요청 메소드와 본문 유지(절대 요청 메소드를 변경하면 안된다).</p>
</li>
<li>
<p><strong>303 See Other</strong>
리다이렉트 시 요청 메소드가 GET으로 변경</p>
</li>
<li>
<p><strong>304 Not Modified</strong>
캐시를 목적으로 사용. 클라이언트에게 리소스가 수정되지 않았음을 알림(캐시 사용 허가).</p>
</li>
</ul>
<h3 id="prg--postredirectget">PRG : POST/Redirect/GET</h3>
<p>POST로 요청 후에 새로 고침으로 인한 중복 요청 방지. POST 후에 결과 화면(응답)을 GET 메소드로 리다이렉트.</p>
<h2 id="4xx---client-error" class="heading">4XX - Client Error</h2>
<p>오류의 원인이 클라이언트에 있어 서버가 전혀 요청을 수행할 수 없음. 같은 요청을 다시 보내도 서버에선 계속 같은 실패 응답을 보냄.</p>
<ul>
<li>
<p><strong>400 Bad Request</strong>
클라이언트가 잘못된 요청을 보냄. 클라이언트가 요청 내용을 검토해야함. HTTP API 스펙이 맞지 않거나, 요청 파라미터가 잘못됨.</p>
</li>
<li>
<p><strong>401 Unauthorized</strong>
클라이언트가 접근하려는 리소스에 대한 인증 필요. Authentication되지 않음. WWW-Authenticate 헤더와 함께 인증 방법 설명
Authentication (본인 인증), Authorization (권한 확인)</p>
</li>
<li>
<p><strong>403 Forbidden</strong>
서버가 클라이언트의 요청을 이해했지만 승인 거부. 권한 부족. (일반 사용자가 어드민 리소스 접근)</p>
</li>
<li>
<p><strong>404 Not Found</strong>
요청 리소스가 서버에 없음. 또는 클라이언트에게 완전히 리소스의 존재 확인을 막을 때.</p>
</li>
</ul>
<h2 id="5xx---server-error" class="heading">5XX - Server Error</h2>
<p>서버 문제로 오류 발생. 재시도 시 성공 가능성 있음. 서버의 문제일 때만 5XX대 오류 반환해야함.</p>
<ul>
<li>
<p><strong>500 Internal Server Error</strong>
서버 문제로 오류 발생, 애매하면 500.</p>
</li>
<li>
<p><strong>503 Service Unavailable</strong>
서비스 이용 불가. 서버가 일시적인 과부하 또는 예정 작업으로 요청 처리 불가. Retry-After 헤더 필드로 복구 예상 시간 반환 가능.</p>
</li>
</ul>]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[인터넷 네트워크]]></title>
    <link>https://blog.coderoad.kr/internet</link>
    <pubDate>2023-01-18</pubDate>
    <guid isPermaLink="false">https://blog.coderoad.kr/internet</guid>
    <description>
    <![CDATA[웹 개발을 위한 인터넷 네트워크 기본 지식]]>
    </description>
    <content:encoded>
      <![CDATA[<p><strong>본 문서는 인프런에서 수강할 수 있는 <a href="https://www.inflearn.com/course/http-%EC%9B%B9-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC" target="_blank" rel="noopener noreferer">모든 개발자를 위한 HTTP 웹 기본 지식</a>을 수강한 후, 공부한 내용을 정리한 문서입니다. 본 문서의 모든 저작권은 해당 강의의 저자이신 <a href="https://inflearn.com/users/@yh" target="_blank" rel="noopener noreferer">김영한</a> 우아한형제들 기술이사님께 있습니다.</strong></p>
<h2 id="인터넷" class="heading">인터넷!</h2>
<h2 id="ip" class="heading">IP</h2>
<h2 id="tcp와-udp" class="heading">TCP와 UDP</h2>
<h2 id="port" class="heading">PORT</h2>
<h2 id="dns" class="heading">DNS</h2>]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[URI]]></title>
    <link>https://blog.coderoad.kr/uri</link>
    <pubDate>2023-01-18</pubDate>
    <guid isPermaLink="false">https://blog.coderoad.kr/uri</guid>
    <description>
    <![CDATA[통합 자원 식별자에 대해]]>
    </description>
    <content:encoded>
      <![CDATA[<p><strong>본 문서는 인프런에서 수강할 수 있는 <a href="https://www.inflearn.com/course/http-%EC%9B%B9-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC" target="_blank" rel="noopener noreferer">모든 개발자를 위한 HTTP 웹 기본 지식</a>을 수강한 후, 공부한 내용을 정리한 문서입니다. 본 문서의 모든 저작권은 해당 강의의 저자이신 <a href="https://inflearn.com/users/@yh" target="_blank" rel="noopener noreferer">김영한</a> 우아한형제들 기술이사님께 있습니다.</strong></p>
<h2 id="uri-url-urn" class="heading">URI, URL, URN</h2>
<h2 id="url-살펴보기" class="heading">URL 살펴보기</h2>]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[IoC와 DI]]></title>
    <link>https://blog.coderoad.kr/iocanddi</link>
    <pubDate>2023-01-18</pubDate>
    <guid isPermaLink="false">https://blog.coderoad.kr/iocanddi</guid>
    <description>
    <![CDATA[Spring의 시작과 끝, IoC와 DI]]>
    </description>
    <content:encoded>
      <![CDATA[<p><strong>본 문서는 인프런에서 수강할 수 있는 <a href="https://inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8" target="_blank" rel="noopener noreferer">스프링 핵심 원리 - 기본편</a>을 수강한 후, 공부한 내용을 정리한 문서입니다. 본 문서의 모든 저작권은 해당 강의의 저자이신 <a href="https://inflearn.com/users/@yh" target="_blank" rel="noopener noreferer">김영한</a> 우아한형제들 기술이사님께 있습니다.</strong></p>
<h2 id="제어의-역전-ioc" class="heading">제어의 역전 IoC</h2>
<p>**제어의 역전(Inversion of Control)**은 말 그대로 제어에 역전이 일어났다는 의미입니다. 제어에 역전이 일어났다니, 도대체 무슨 말일까요? 그동안 우리가 작성해왔던 프로그램들은 크게 신경쓰지 않았다면 자연스럽게 <strong>구현 객체가 프로그램의 흐름을 제어</strong>했습니다. 구현 객체 스스로 로직에 필요한 다른 구현 객체들을 생성하고(new 키워드), 연결하고, 로직에 맞춰 실행했습니다. 그러나 이런 방식은 결국 구현 객체에 의존해야(알아야)한다는 문제가 있습니다. 다시 말해서 <a href="https://blog.coderoad.kr/solid" target="_blank" rel="noopener noreferer">SOLID</a> 중 DIP(의존관계 역전 원칙)를 위반한다는 것입니다. 또한, 기존의 방식은 SRP와 OCP도 함께 위반하게 됩니다. 구현 객체가 객체의 생성, 연결, 실행까지 모두 담당하고 있어 SRP(단일 책임 원칙)에 위배되고, 새로운 구현 객체를 비즈니스에 적용하고자 코드를 수정해야할 때, 기존의 구현 객체에 의존하는 모든 코드들을 수정해야하기 때문에 OCP(개방-폐쇄 원칙)을 위반하게 됩니다.</p>
<p>우린 좋은 객체 지향 프로그래밍을 위해 여러 SOLID 원칙들을 위반하는 문제를 해결해야합니다. 먼저, DIP를 준수하기 위해선 <strong>추상화에만 의존</strong>해야합니다. 구현 객체들은 다른 구현 객체에 전혀 의존하지 않고, 자신들이 맡은 비즈니스 로직만 잘 수행하면 됩니다. 즉, 구현 객체 내부에서 다른 구현 객체들을 알고 있을 필요가 없습니다. 하지만 다른 구현 객체들과 협력하지 못한다면 SOLID를 지키기는 커녕 프로그램이 제대로 돌아갈리가 없습니다. 그렇다면 어떻게 추상화에만 의존하면서 객체들 간의 협력 관계를 부여할 수 있을까요?</p>
<p>방법은 간단합니다. 추상화에만 의존하고 있는 객체들에게 구현 객체를 전달해주는 <strong>구성자</strong>가 존재하면 해결됩니다. 모든 구현 객체들을 생성하고 필요한 곳에 연결해주는 등의 제어 권한을 가진 클래스를 만들어주면 DIP를 준수할 수 있습니다. 이 구성자의 등장으로 SRP와 OCP도 준수할 수 있습니다. 구성자는 앞서 설명했던대로 객체 생성, 연결이라는 책임을 구현 객체들로부터 가져왔기 때문에 구현 객체는 실행이라는 책임만 가지게 됐습니다. 또한, 구현 객체들이 <strong>추상화</strong>에만 의존하게 되었으므로 구현 객체를 교체할 때 수정해야하는 것은 <strong>구성자</strong>이지 구현 객체들이 아니기 때문에 OCP도 준수할 수 있습니다.</p>
<p>이렇게 외부의 <strong>구성자</strong>가 프로그램의 흐름을 관리하는 것을 **제어의 역전(Inversion of Control)**이라고 합니다. 흔히 프레임워크들이 제어의 역전을 통해 우리가 작성한 코드들을 제어하고 대신 실행합니다. 그에 반해 라이브러리는 우리의 코드를 제어하기 보단 라이브러리의 코드를 우리가 직접 활용하기 때문에 제어의 역전을 사용하지 않습니다.</p>
<h2 id="의존관계-주입-di" class="heading">의존관계 주입 DI</h2>
<p>**의존관계 주입(Dependency Injection)**은 의존관계를 외부에서 주입해주는 것을 말합니다. 우리는 앞서 SOLID 위반을 피하기 위해 추상화에만 의존하고자 프로그램에 IoC 개념을 적용했습니다. 추상화에만 의존하게 된 구현 객체들은 자신이 의존하고 있는 인터페이스 외에는 알고 있는 것이 전혀 없습니다. 하지만 인터페이스는 역할이고 구현체가 아니기 때문에, 인터페이스만 알고 있어서는 프로그램이 올바르게 동작하지 않습니다. 제대로 프로그램이 동작하도록 프로그램의 제어권을 가져간 <strong>구성자</strong>가 의존관계를 설정해줘야 합니다.</p>
<p>구성자가 관리해야할 의존관계에 대해 자세히 알아보기 전에 의존관계의 두 가지 분류를 살펴보겠습니다. 먼저, <strong>import 구문</strong>을 통해 명시적으로 작성하는 의존관계인 <strong>정적 클래스 의존관계</strong>가 있습니다. 이 의존관계는 import 구문을 읽으면 어떤 객체에 의존하고 있는지 프로그램을 실행하지 않아도 알 수 있습니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token comment">//이 코드는 MemberRepository 객체에 의존하고 있습니다.</span>
</span><span class="code-line"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">hello<span class="token punctuation">.</span>core<span class="token punctuation">.</span>member<span class="token punctuation">.</span></span><span class="token class-name">MemberRepository</span></span><span class="token punctuation">;</span>
</span></code></pre>
<p>그러나, 우리는 프로그램을 오로지 추상화에만 의존하도록 제어의 역전을 일으켜야 SOLID를 준수할 수 있다는 것을 알았습니다. 위의 코드와 같은 정적 클래스 의존관계는 의존하고 있는 추상화가 무엇인지는 알 수 있지만 실제 구현 객체는 전혀 알 수 없습니다. 이때, IoC와 <strong>구성자</strong>의 역할이 중요한 이유가 나타납니다. 프로그램의 제어권을 가져간 구성자는 프로그램의 실행 시점(런타임)에 실제 구현 객체 인스턴스를 직접 생성하고 해당 객체를 필요로하는 코드들에 의존관계를 연결합니다. 이것을 **의존관계 주입(Dependency Injection)**이라고 합니다. DI를 사용하면 클라이언트 코드를 전혀 변경하지 않고, 클라이언트가 호출하는 대상의 인스턴스 타입을 변경할 수 있습니다. 즉, OCP 원칙이 준수된다는 의미입니다.</p>
<h2 id="컨테이너의-등장" class="heading">컨테이너의 등장</h2>
<p>IoC를 통해 프로그램의 제어권을 온전히 가지게 된 <strong>구성자</strong>는 앞서 살펴본대로 객체를 생성하고, 관리하면서, 의존관계를 연결(DI)해주는 역할을 수행하고 있습니다. 이 구성자를 바로 **컨테이너(Container)**라고 합니다. IoC 컨테이너, DI 컨테이너 등, 많은 이름이 있지만 최근에는 DI에 중점을 두고 주로 DI 컨테이너라고 합니다. 물론 Spring에서는 <strong>Spring 컨테이너</strong>라고 합니다. 이름은 차이가 있어도 맡고 있는 역할은 전혀 다를게 없으니 Spring을 공부하는 입장에선 Spring 컨테이너라고 하는 것이 좋을 것 같습니다. 다시 한번 강조하지만, 컨테이너 외부에서는 애플리케이션의 모든 객체는 추상화에만 의존해야합니다. 컨테이너 외부에서 추상화가 아닌 구현체에 의존하게 되면 Spring을 사용하는 의미도 없을 뿐더러 SOLID에 위배되어 좋은 객체 지향 프로그래밍도 아니기 때문입니다. 물론 테스트 코드를 작성할 때는 필요에 따라 new 키워드로 구현 객체를 생성해도 상관 없습니다. 단위 테스트를 위해 간단한 더미 데이터가 필요한데 실제 서비스 코드를 수정하는게 훨씬 비효율적이기 때문입니다.</p>
<p>자, 이제 우리는 IoC를 통해 만들어진 구성자가 컨테이너라는 것도 알았습니다. 좋은 객체 지향 프로그래밍을 위해서 직접 컨테이너를 만들어 구현 객체를 생성하고, 관리하면서, 의존관계도 주입해주면 됩니다! Spring에서는 기본적으로 <strong>ApplicationContext</strong>라는 인터페이스를 통해 컨테이너를 제공하고 있습니다. 즉, 우린 Spring 컨테이너에 대해 공부하면 지금까지 알아봤던 여러 개념들을 간단하게 적용할 수 있는 것입니다! 이제 Spring의 컨테이너에 대해 더 자세하게 공부해, Spring의 장점을 극대화해봅시다.</p>]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[SOLID]]></title>
    <link>https://blog.coderoad.kr/solid</link>
    <pubDate>2023-01-17</pubDate>
    <guid isPermaLink="false">https://blog.coderoad.kr/solid</guid>
    <description>
    <![CDATA[Spring과 SOLID]]>
    </description>
    <content:encoded>
      <![CDATA[<p><strong>본 문서는 인프런에서 수강할 수 있는 <a href="https://inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8" target="_blank" rel="noopener noreferer">스프링 핵심 원리 - 기본편</a>을 수강한 후, 공부한 내용을 정리한 문서입니다. 본 문서의 모든 저작권은 해당 강의의 저자이신 <a href="https://inflearn.com/users/@yh" target="_blank" rel="noopener noreferer">김영한</a> 우아한형제들 기술이사님께 있습니다.</strong></p>
<h2 id="solid" class="heading">SOLID?</h2>
<p>SOLID, 단단하다는 뜻을 가진 영단어입니다. Spring과 SOLID는 도대체 무슨 연관이 있을까요? 사실 Spring을 넘어 프로그래밍에서 <strong>SOLID는 객체 지향 프로그래밍 및 설계의 가장 기초적인 원칙 5가지</strong>의 앞 글자를 딴 단어입니다. 2000년대 초반, 미국의 소프트웨어 엔지니어인 로버트 마틴이 "<a href="http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod" target="_blank" rel="noopener noreferer">The Principles of OOD</a>"라는 제목의 블로그 게시글에서 5개의 원칙을 명명했습니다.</p>
<p>그 원칙들은 다음과 같습니다.</p>
<table>
    <tr>
        <th colspan="2">SOLID</th>
    </tr>
    <tr>
        <th>이름</th>
        <th>설명</th>
    </tr>
    <tr>
        <td>단일 책임 원칙</td>
        <td>SRP (Single Responsibility Principle)<br>한 클래스는 하나의 책임만 가져야 한다.</td>
    </tr>
    <tr>
        <td>개방-폐쇄 원칙</td>
        <td>OCP (Open/Closed Principle)<br>소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.</td>
    </tr>
    <tr>
        <td>리스코프 치환 원칙</td>
        <td>LSP (Liskov Substitution Principle)<br>프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스를 바꿀 수 있어야 한다.</td>
    </tr>
    <tr>
        <td>인터페이스 분리 원칙</td>
        <td>ISP (Interface Segregation Principle)<br>특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나 보다 낫다.</td>
    </tr>
    <tr>
        <td>의존관계 역전 원칙</td>
        <td>DIP (Dependency Inversion Principle)<br>프로그래머는 추상화에 의존해야하지 구체화에 의존하면 안된다. 의존관계 주입은 이 원칙을 따르는 방법 중 하나.</td>
    </tr>
</table>
<h2 id="단일-책임-원칙-srp" class="heading">단일 책임 원칙 (SRP)</h2>
<p><strong>단일 책임 원칙</strong>(Single Responsibility Principle)은 "한 클래스는 하나의 책임만 가져야 한다."라는 원칙입니다. 여기서 '하나의 책임'이라는 말이 모호할 수 있습니다. 책임은 클 수도 있고, 작을 수도 있으며, 문맥과 상황에 따라 다릅니다. 하지만 가장 중요한 것은 <strong>변경</strong>입니다. 즉, 우리는 "변경"을 기준으로 잡아 단일 책임 원칙이 준수되었는지 확인해야합니다.</p>
<p>예를 들어, 웹 애플리케이션에서 특정 기능을 수정하게 된 상황을 가정해보겠습니다. 기능의 수정이 생겼기 때문에 당연히 내부 코드에도 변경이 필요합니다. 이 때, 단 하나의 클래스만 수정되어야 SRP를 잘 준수한 프로그램이 되는 것입니다. 즉, 하나의 클래스가 하나의 기능(책임)을 가지기 때문에 다른 클래스(코드)에 영향을 주지 않고도 변경이 가능합니다.</p>
<h2 id="개방-폐쇄-원칙-ocp" class="heading">개방-폐쇄 원칙 (OCP)</h2>
<p><strong>개방-폐쇄 원칙</strong>(Open/Closed Principle)은 "소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다."라는 원칙입니다. 그런데 이름부터 모순되는 말입니다. 어떻게 개방과 폐쇄가 동시에 지켜질 수 있다는 말일까요? 애플리케이션을 확장하려면, 즉 기능을 추가하거나 수정하려면 당연히 기존의 코드를 변경해야하는 것 아닐까요? 이 질문의 답은 객체 지향 프로그래밍에서 가장 중요한 <strong>다형성</strong>에 있습니다.</p>
<p>우리가 앞서 살펴봤던 다형성을 활용하려면, <strong>역할</strong>과 <strong>구현</strong>으로 철저하게 구분지어서 설계해야한다고 했습니다. 잘 설계된 역할이 있다면 그 구현체를 새로 만드는 것은 기존 코드에 전혀 영향을 주지 않습니다. 다형성의 목적이 유연하고 변경이 용이하게 하는 것임을 기억한다면, 미리 적어둔 코드의 수정 없이도 완전히 새로운 기능을 추가(확장)하는 것이 가능합니다. 즉, 새로운 클래스를 작성하고 애플리케이션에 적용(확장)할 때 다른 클래스를 수정(변경)한다면 확장에도 열려있고 변경에도 열려있어 OCP를 위반하는 것입니다.</p>
<p>그럼 OCP를 준수하려면 어떻게 해야할까요? 지금까지 우리는 새로 만든 구현체를 적용시키려면 그 구현체를 사용하는 다른 구현체의 코드를 수정해야했습니다. 이제 우리는 새로운 구현체를 외부에서 생성, 조립, 설정까지 모두 해주는 설정자가 필요해졌습니다. 이 설정자를 통해 기존 코드의 수정이 없이 설정자만 변경했을 때 의도한대로 동작한다면 그 프로그램은 OCP를 준수한 것입니다. 이 "설정자"는 나중에 설명하겠지만 "Spring 컨테이너"라는 Spring에서 아주 중요한 역할을 맡게 됩니다.</p>
<h2 id="리스코프-치환-원칙-lsp" class="heading">리스코프 치환 원칙 (LSP)</h2>
<p><strong>리스코프 치환 원칙</strong>(Liskov Substitution Principle)은 "프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스를 바꿀 수 있어야 한다."는 원칙입니다. 쉽게 설명해서 자식 클래스는 부모 클래스를 언제든 완전히 대체할 수 있어야 한다는 원칙입니다. 즉, 부모 클래스의 기능이 자식 클래스에서 정반대가 되어버린다면 LSP가 지켜지지 않은 것입니다. 오류는 나지 않겠지만 다형성이 완전히 무너지게 됩니다.</p>
<p>예를 들어, 자동차 인터페이스의 악셀 메소드는 가속을 합니다. 모든 자동차는 악셀은 가속, 브레이크는 감속이라는 기능을 가지는데, 만약 어느 한 구현체(자동차)만 이 인터페이스와는 정반대로 악셀은 감속, 브레이크는 가속이라는 기능을 가지면 대참사가 발생할 가능성이 있습니다. 물론 만들 수는 있고 실제로 운전도 어렵겠지만 가능은 합니다. 그러나 이 예시에선 구현체(자식 클래스)가 인터페이스(부모 클래스)를 완전히 대체하지 못하고 있기 때문에 LSP를 위반하고 있습니다.</p>
<p>가장 지키기 쉬운 원칙 중에 하나입니다. 인터페이스를 설계한 목적 그대로 구현하면 됩니다.</p>
<h2 id="인터페이스-분리-원칙-isp" class="heading">인터페이스 분리 원칙 (ISP)</h2>
<p><strong>인터페이스 분리 원칙</strong>(Interface Segregation Principle)은 "특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다."는 원칙입니다. 쉽게 설명하면 인터페이스를 더 세세하게 분리하는 것이 좋다는 것입니다. 즉, 하나의 인터페이스가 가지는 책임(기능)이 과다할 때, 분리할 수 있는 책임(기능)이 있다면 따로 분리해두어야 합니다.</p>
<p>예를 들어, 자동차 인터페이스는 "운전"이라는 큰 관점으로 묶이는 기능들과 "정비"라는 큰 관점으로 묶이는 기능들로 분리할 수 있습니다. 또한 사용자 인터페이스도 "운전자"와 "정비사"로 나눌 수 있습니다. 그럼 정비 인터페이스가 변해도 운전자 구현체에는 전혀 영향을 주지 않게 됩니다. 만약 자동차 인터페이스를 ISP 원칙을 지키지 않았다면 정비 부분 기능들을 수정할 때 운전자 구현체에도 영향을 미칠 것입니다. 따라서 ISP를 준수하면 인터페이스가 좀 더 명확해지고 대체 가능성이 높아집니다.</p>
<h2 id="의존관계-역전-원칙-dip" class="heading">의존관계 역전 원칙 (DIP)</h2>
<p><strong>의존관계 역전 원칙</strong>(Dependency Inversion Principle)은 "프로그래머는 추상화에 의존해야지, 구체화에 의존하면 안 된다."는 원칙입니다. 의존관계 주입(Dependency Injection)은 이 원칙을 따르는 방법 중 하나입니다. 쉽게 이야기해서 DIP는 구현 클래스에 의존하지 말고, 역할인 인터페이스에 의존하라는 뜻입니다. 여기서 "의존한다."는 "알고 있다."와 같습니다. 즉, 클라이언트가 인터페이스<strong>만</strong> 의존해야(알고 있어야) DIP를 준수하는 것입니다. 만약 인터페이스 뿐만 아니라 구현 객체도 의존한다(알고 있다)면, 구현체를 변경해야할 때 해당 구현체를 의존하는(알고 있는) 코드를 모두 변경해야합니다.</p>
<p>DIP에 대해 더 자세히 알아보기 위해 다형성을 설명하면서 작성했던 코드를 다시 살펴보겠습니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token comment">//이 코드는 DIP를 위반합니다!</span>
</span><span class="code-line"><span class="token comment">//Car라는 인터페이스를 의존합니다. 그러나 NormalCar라는 구현체도 알고 있습니다.</span>
</span><span class="code-line"><span class="token class-name">Car</span> myCar <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NormalCar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token keyword">int</span> currentSpeed<span class="token punctuation">;</span>
</span><span class="code-line">currentSpeed <span class="token operator">=</span> myCar<span class="token punctuation">.</span><span class="token function">accelPedal</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">currentSpeed <span class="token operator">=</span> myCar<span class="token punctuation">.</span><span class="token function">breakPedal</span><span class="token punctuation">(</span>currentSpeed<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></code></pre>
<p>한 눈에봐도 추상화(인터페이스)와 구체화(구현 클래스)를 동시에 의존하고(알고) 있어 DIP를 위반했다는 것을 알 수 있습니다. DIP를 준수하려면 추상화에만 의존해야합니다. 그런데 만약 추상화만 의존하기 위해 위의 코드를 아래와 같이 고치면 예외가 발생할 것입니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token comment">//추상화만 의존하긴 하지만...</span>
</span><span class="code-line"><span class="token comment">//myCar에는 아무것도 들어가지 않았습니다.</span>
</span><span class="code-line"><span class="token class-name">Car</span> myCar<span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token keyword">int</span> currentSpeed<span class="token punctuation">;</span>
</span><span class="code-line">currentSpeed <span class="token operator">=</span> myCar<span class="token punctuation">.</span><span class="token function">accelPedal</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">currentSpeed <span class="token operator">=</span> myCar<span class="token punctuation">.</span><span class="token function">breakPedal</span><span class="token punctuation">(</span>currentSpeed<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></code></pre>
<p>DIP를 지키려고 했더니 동작조차 하지 않는 망가진 코드가 완성되어버렸습니다. 분명 유연하게 변경할 수는 있지만 SOLID를 준수하자니 무언가 부족합니다. 객체 지향의 핵심이라는 다형성만으로는 쉽게 부품을 갈아 끼우듯이 개발할 수 없다는 것을 깨달았습니다. 또한 구현 객체를 변경할 때 클라이언트의 코드도 변경되어버린다는 것도 알았습니다. 즉, 다형성만으로는 DIP와 OCP를 완벽하게 지킬 수 없다는 것을 알아버렸습니다! 그럼 어떻게 해야 SOLID를 준수하면서 객체 지향 프로그래밍을 할 수 있을까요? 정답은 바로 <strong>Spring</strong>에 있습니다.</p>
<h2 id="갑자기-spring" class="heading">갑자기 Spring?</h2>
<p>Spring이 제공하는 <strong>의존관계 주입(Dependency Injection, DI) 기술</strong>과 <strong>DI 컨테이너</strong>를 통해 다형성과 OCP, DIP를 지킬 수 있게 도와줍니다. 이러한 Spring의 기술들 덕분에 클라이언트의 코드의 변경 없이도 기능 확장이 가능해졌습니다. 그렇다고 Spring이 없던 시절에는 OCP, DIP를 준수하는게 불가능하진 않았습니다. 순수한 Java로 OCP, DIP를 준수하기 위해 작성한 코드들이 너무 많아지다보니 한 곳에 모아 프레임워크로 만든 것이 바로 <strong>Spring</strong>입니다. 우리가 OCP와 DIP를 준수하면서 개발을 해보면 결국엔 Spring의 핵심인 DI 컨테이너를 만들게 됩니다.</p>
<p><a href="https://blog.coderoad.kr/spring" target="_blank" rel="noopener noreferer">Spring</a> 포스트에서 Spring의 역사에 대해 알아보면서 Spring은 "좋은 객체 지향"을 위해 탄생한 프레임워크라고 설명했습니다. 좋은 객체 지향 프로그래밍을 위해서는 기초 중의 기초인 SOLID를 준수해야하고 Spring은 이를 쉽게 준수할 수 있도록 돕습니다. 따라서 Spring을 100% 활용하기 위해선 객체 지향 5원칙, SOLID를 반드시 공부해야합니다. 그렇지 않으면 Spring의 동작 원리부터 이해할 수 없기 때문입니다.</p>]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[Java 웹 기술의 역사]]></title>
    <link>https://blog.coderoad.kr/backendhistory</link>
    <pubDate>2023-01-17</pubDate>
    <guid isPermaLink="false">https://blog.coderoad.kr/backendhistory</guid>
    <description>
    <![CDATA[Servlet의 등장부터 Spring Boot까지]]>
    </description>
    <content:encoded>
      <![CDATA[<p><strong>본 문서는 인프런에서 수강할 수 있는 <a href="https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-mvc-1/dashboard" target="_blank" rel="noopener noreferer">스프링 MVC 1편 - 백엔드 웹 개발 핵심 기술</a>을 수강한 후, 공부한 내용을 정리한 문서입니다. 본 문서의 모든 저작권은 해당 강의의 저자이신 <a href="https://inflearn.com/users/@yh" target="_blank" rel="noopener noreferer">김영한</a> 우아한형제들 기술이사님께 있습니다.</strong></p>
<h2 id="과거의-기술들" class="heading">과거의 기술들</h2>
<h3 id="서블릿-servlet">서블릿 (Servlet)</h3>
<p>Spring, 그리고 Spring의 수많은 프로젝트들이 탄생하기도 전인 1997년, <strong>서블릿</strong>(Servlet)이라는 기술이 Java EE(Java Enterprise Edition)에 정식 제품으로 포함되며 세상에 나왔습니다. 서블릿은 동적으로 웹 페이지를 생성하기 위한 기술로, Java 소스 코드 내부에 HTML을 포함한다는 특징을 가지고 있습니다. 서블릿에 대한 자세한 내용은 <a href="https://blog.coderoad.kr/servlet" target="_blank" rel="noopener noreferer">Servlet이란?</a>에 정리했습니다.</p>
<h3 id="jsp">JSP</h3>
<p>서블릿의 탄생으로 이전에 서버 개발자가 직접 해야했던 여러 복잡한 작업들(TCP/IP 소켓 통신, HTTP 메시지 파싱 등)을 모두 서블릿이 대신 해주면서 웹 애플리케이션 서버를 구축할 때 들어가는 비용이 크게 줄어 들었지만, 여전히 큰 문제가 하나 남아 있었습니다. 서블릿을 이용해 개발자라면 무조건 피해야하는 '유지보수하기 힘든 코드'가 만들어지곤 했습니다.</p>
<p>아래 코드는 순수하게 서블릿만 사용해서 간단한 회원 정보 입력 폼과 폼을 통해 입력된 데이터를 저장하는 로직을 작성한 코드입니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token comment">// 회원의 이름과 나이를 입력하는 폼 서블릿</span>
</span><span class="code-line"><span class="token annotation punctuation">@Override</span>
</span><span class="code-line"><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">service</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> response<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ServletException</span><span class="token punctuation">,</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>
</span><span class="code-line">    response<span class="token punctuation">.</span><span class="token function">setContentType</span><span class="token punctuation">(</span><span class="token string">"text/html"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    response<span class="token punctuation">.</span><span class="token function">setCharacterEncoding</span><span class="token punctuation">(</span><span class="token string">"utf-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token class-name">PrintWriter</span> w <span class="token operator">=</span> response<span class="token punctuation">.</span><span class="token function">getWriter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    w<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"&#x3C;!DOCTYPE html>\n"</span> <span class="token operator">+</span>
</span><span class="code-line">            <span class="token string">"&#x3C;html>\n"</span> <span class="token operator">+</span>
</span><span class="code-line">            <span class="token string">"&#x3C;head>\n"</span> <span class="token operator">+</span>
</span><span class="code-line">            <span class="token string">"    &#x3C;meta charset=\"UTF-8\">\n"</span> <span class="token operator">+</span>
</span><span class="code-line">            <span class="token string">"    &#x3C;title>Title&#x3C;/title>\n"</span> <span class="token operator">+</span>
</span><span class="code-line">            <span class="token string">"&#x3C;/head>\n"</span> <span class="token operator">+</span>
</span><span class="code-line">            <span class="token string">"&#x3C;body>\n"</span> <span class="token operator">+</span>
</span><span class="code-line">            <span class="token string">"&#x3C;form action=\"/servlet/members/save\" method=\"post\">\n"</span> <span class="token operator">+</span>
</span><span class="code-line">            <span class="token string">"    username: &#x3C;input type=\"text\" name=\"username\" />\n"</span> <span class="token operator">+</span>
</span><span class="code-line">            <span class="token string">"    age:      &#x3C;input type=\"text\" name=\"age\" />\n"</span> <span class="token operator">+</span>
</span><span class="code-line">            <span class="token string">" &#x3C;button type=\"submit\">전송&#x3C;/button>\n"</span> <span class="token operator">+</span> <span class="token string">"&#x3C;/form>\n"</span> <span class="token operator">+</span>
</span><span class="code-line">            <span class="token string">"&#x3C;/body>\n"</span> <span class="token operator">+</span>
</span><span class="code-line">            <span class="token string">"&#x3C;/html>\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token comment">// 폼을 통해 입력 받은 데이터를 저장하는 서블릿</span>
</span><span class="code-line"><span class="token annotation punctuation">@Override</span>
</span><span class="code-line"><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">service</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> response<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ServletException</span><span class="token punctuation">,</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token comment">// 요청 데이터 받아옴</span>
</span><span class="code-line">    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"MemberSaveServlet.service"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token class-name">String</span> username <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getParameter</span><span class="token punctuation">(</span><span class="token string">"username"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token keyword">int</span> age <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span><span class="token function">getParameter</span><span class="token punctuation">(</span><span class="token string">"age"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token comment">// 서비스 로직</span>
</span><span class="code-line">    <span class="token class-name">Member</span> member <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Member</span><span class="token punctuation">(</span>username<span class="token punctuation">,</span> age<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    memberRepository<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span>member<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token comment">// 결과 출력</span>
</span><span class="code-line">    response<span class="token punctuation">.</span><span class="token function">setContentType</span><span class="token punctuation">(</span><span class="token string">"text/html"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    response<span class="token punctuation">.</span><span class="token function">setCharacterEncoding</span><span class="token punctuation">(</span><span class="token string">"utf-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token class-name">PrintWriter</span> w <span class="token operator">=</span> response<span class="token punctuation">.</span><span class="token function">getWriter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    w<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"&#x3C;html>\n"</span> <span class="token operator">+</span>
</span><span class="code-line">            <span class="token string">"&#x3C;head>\n"</span> <span class="token operator">+</span>
</span><span class="code-line">            <span class="token string">" &#x3C;meta charset=\"UTF-8\">\n"</span> <span class="token operator">+</span> <span class="token string">"&#x3C;/head>\n"</span> <span class="token operator">+</span>
</span><span class="code-line">            <span class="token string">"&#x3C;body>\n"</span> <span class="token operator">+</span>
</span><span class="code-line">            <span class="token string">"성공\n"</span> <span class="token operator">+</span>
</span><span class="code-line">            <span class="token string">"&#x3C;ul>\n"</span> <span class="token operator">+</span>
</span><span class="code-line">            <span class="token string">"    &#x3C;li>id="</span><span class="token operator">+</span>member<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"&#x3C;/li>\n"</span> <span class="token operator">+</span>
</span><span class="code-line">            <span class="token string">"    &#x3C;li>username="</span><span class="token operator">+</span>member<span class="token punctuation">.</span><span class="token function">getUsername</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"&#x3C;/li>\n"</span> <span class="token operator">+</span>
</span><span class="code-line">            <span class="token string">" &#x3C;li>age="</span><span class="token operator">+</span>member<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"&#x3C;/li>\n"</span> <span class="token operator">+</span> <span class="token string">"&#x3C;/ul>\n"</span> <span class="token operator">+</span>
</span><span class="code-line">            <span class="token string">"&#x3C;a href=\"/index.html\">메인&#x3C;/a>\n"</span> <span class="token operator">+</span> <span class="token string">"&#x3C;/body>\n"</span> <span class="token operator">+</span>
</span><span class="code-line">            <span class="token string">"&#x3C;/html>"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p>솔직히 저라면 절대 다시 읽기 싫은 코드인 것 같습니다. Java 코드와 HTML의 스타일이 매우 달라 읽는 것만으로도 스트레스 받을 것 같고, 만약 이 코드가 수천, 수만 줄이 넘어간다면 유지보수는 고행이 될 가능성이 높아 보입니다. 더군다나, Java 코드가 데이터도 가공하고 웹 화면도 그리고 있는, 맡고 있는 책임이 여러 개인 상황입니다. 즉, 단일 책임 원칙을 위반하고 있는 객체지향 관점에서도 좋지 못한 코드가 만들어진 것입니다. 이런 서블릿의 문제들을 해결하기 위해 등장한 기술이 1999년에 발표된 <strong>JSP</strong>(Java Server Pages)라는 <strong>템플릿 엔진</strong>(Template Engine)입니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token annotation punctuation">@Override</span>
</span><span class="code-line"><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">service</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> response<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ServletException</span><span class="token punctuation">,</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token class-name">String</span> viewPath <span class="token operator">=</span> <span class="token string">"/WEB-INF/views/new-form.jsp"</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token class-name">RequestDispatcher</span> dispatcher <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getRequestDispatcher</span><span class="token punctuation">(</span>viewPath<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    dispatcher<span class="token punctuation">.</span><span class="token function">forward</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> response<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token annotation punctuation">@Override</span>
</span><span class="code-line"><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">service</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> response<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ServletException</span><span class="token punctuation">,</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token comment">// 요청 데이터 받아옴</span>
</span><span class="code-line">    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"MemberSaveServlet.service"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token class-name">String</span> username <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getParameter</span><span class="token punctuation">(</span><span class="token string">"username"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token keyword">int</span> age <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span><span class="token function">getParameter</span><span class="token punctuation">(</span><span class="token string">"age"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token comment">// 서비스 로직</span>
</span><span class="code-line">    <span class="token class-name">Member</span> member <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Member</span><span class="token punctuation">(</span>username<span class="token punctuation">,</span> age<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    memberRepository<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span>member<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">    request<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">"member"</span><span class="token punctuation">,</span> member<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token class-name">String</span> viewPath <span class="token operator">=</span> <span class="token string">"/WEB-INF/views/save-result.jsp"</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token class-name">RequestDispatcher</span> dispatcher <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getRequestDispatcher</span><span class="token punctuation">(</span>viewPath<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    dispatcher<span class="token punctuation">.</span><span class="token function">forward</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> response<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p>JSP를 활용하게 되니 Java 코드는 HTML과 분리되어 훨씬 깔끔하고 한 눈에 알아볼 수 있게 개선되었습니다. HTML을 작성하고 화면에 그리는 역할은 JSP 파일이 담당합니다. JSP는 컴파일 과정에서 서블릿으로 변환되고 서블릿과 완전 동일한 작업을 수행합니다. 즉, JSP는 서블릿을 좀 더 보기 편하고 개발하기 쉽게 만들어주는 기술입니다.</p>
<pre><code class="language-jsp code-highlight"><span class="code-line">&#x3C;!-- 회원 정보 입력 폼 JSP -->
</span><span class="code-line">&#x3C;%@ page contentType="text/html;charset=UTF-8" language="java" %>
</span><span class="code-line">
</span><span class="code-line">&#x3C;html>
</span><span class="code-line">&#x3C;head>
</span><span class="code-line">    &#x3C;title>Title&#x3C;/title>
</span><span class="code-line">&#x3C;/head>
</span><span class="code-line">&#x3C;body>
</span><span class="code-line">&#x3C;form action="/jsp/members/save.jsp" method="post">
</span><span class="code-line">    username: &#x3C;input type="text" name="username"/>
</span><span class="code-line">    age:      &#x3C;input type="text" name="age"/>
</span><span class="code-line">    &#x3C;button type="submit">전송&#x3C;/button>
</span><span class="code-line">&#x3C;/form>
</span><span class="code-line">&#x3C;/body>
</span><span class="code-line">&#x3C;/html>
</span></code></pre>
<pre><code class="language-jsp code-highlight"><span class="code-line">&#x3C;!-- 회원 정보 저장 로직 JSP -->
</span><span class="code-line">&#x3C;%@ page import="hello.servlet.domain.member.MemberRepository" %>
</span><span class="code-line">&#x3C;%@ page import="hello.servlet.domain.member.Member" %>
</span><span class="code-line">&#x3C;%@ page contentType="text/html;charset=UTF-8" language="java" %>
</span><span class="code-line">&#x3C;%
</span><span class="code-line">    MemberRepository memberRepository = MemberRepository.getInstance();
</span><span class="code-line">
</span><span class="code-line">    System.out.println("MemberSaveServlet.service");
</span><span class="code-line">    String username = request.getParameter("username");
</span><span class="code-line">    int age = Integer.parseInt(request.getParameter("age"));
</span><span class="code-line">
</span><span class="code-line">    Member member = new Member(username, age);
</span><span class="code-line">    memberRepository.save(member);
</span><span class="code-line">%>
</span><span class="code-line">&#x3C;html>
</span><span class="code-line">&#x3C;head>
</span><span class="code-line">    &#x3C;title>Title&#x3C;/title>
</span><span class="code-line">&#x3C;/head>
</span><span class="code-line">&#x3C;body>
</span><span class="code-line">성공
</span><span class="code-line">&#x3C;ul>
</span><span class="code-line">    &#x3C;li>id=&#x3C;%=member.getId()%>&#x3C;/li>
</span><span class="code-line">    &#x3C;li>username=&#x3C;%=member.getUsername()%>&#x3C;/li>
</span><span class="code-line">    &#x3C;li>age=&#x3C;%=member.getAge()%>&#x3C;/li>
</span><span class="code-line">&#x3C;/ul>
</span><span class="code-line">&#x3C;a href="/index.html">메인&#x3C;/a>
</span><span class="code-line">&#x3C;/body>
</span><span class="code-line">&#x3C;/html>
</span></code></pre>
<p>이렇게 JSP는 HTML 안에 Java 코드를 활용할 수 있어 좀 더 HTML 작성이 편리하고 알아보기 쉽지만 여전히 문제점이 남아 있습니다. 먼저, 서버에서 수행되는 핵심 서비스 로직 코드들이 모두 JSP에 노출되어 있습니다. 또한, 웹 페이지만 그리는 것이 아니라 결국 Java 코드를 통해 데이터를 가공하는 역할까지 담당하게 되었습니다. 결국, JSP마저도 HTML을 작성하기 쉬워졌다는 장점 말고는 서블릿과 크게 다르지 않은 문제점들을 갖고 있는 것입니다.</p>
<h3 id="mvc-패턴">MVC 패턴</h3>
<p>그래도 서블릿과 JSP가 없던 시절보다는 훨씬 편하게 개발할 수 있었기 때문에, 당시 개발자들은 이 서블릿과 JSP의 문제점을 다시 한번 해결하고자 열심히 생각한 끝에, MVC 패턴이라는 개념이 등장했습니다. MVC는 Model, View, Controller의 약자로 Controller를 통해 사용자 요청을 처리하기 위한 비즈니스 로직을 수행하고, Model에 그 결과를 저장한 다음, View는 Model에서 그 결과를 꺼내와 화면을 그리는, 각자 맡은 역할이 확실하게 구분되는 획기적인 개념이 탄생했습니다.</p>
<p>그러나 초기 MVC에도 여전히 한계점은 있었습니다. View로 이동하는 코드가 항상 중복된다는 점, 서블릿의 <code>HttpServletRequest</code>, <code>HttpServletResponse</code>를 사용할 때도, 사용하지 않을 때도 있지만 항상 작성해야 한다는 점, 다양한 Controller들이 공통으로 처리할 내용도 모두 따로 작성해야 한다는 점 등, 중복되는 코드가 많고 공통 처리가 어려웠습니다. 이를 해결하기 위해 등장한 것이 공통 작업 처리를 위한 Controller 앞에서 요청을 우선 처리하는 Front Controller 패턴이었고, Front Controller 패턴은 Spring MVC에서도 <code>DispatcherServlet</code>이라는 이름으로 사용되고 있을 정도로 현재 사용되는 MVC 프레임워크의 기반이 되었습니다.</p>
<h2 id="어노테이션-기반-spring-mvc" class="heading">어노테이션 기반 Spring MVC</h2>
<p>MVC 패턴이 Java 웹 기술의 대세로 떠오르고 많은 프레임워크들이 등장하며, 길고 긴 Java 웹 기술 시장의 선두 자리를 두고 경쟁했습니다. 스트럿츠, 웹워크, 과거의 Spring MVC 등, 많은 프레임워크들이 있었지만, 결국 Java의 어노테이션을 기반으로 한 새로운 버전의 <strong>Spring MVC</strong>가 다른 프레임워크들을 역사의 뒤편으로 보내버리고 압도적인 점유율을 차지하게 되었습니다. 특히, 수많은 전처리 과정(핸들러 매핑, 핸들러 어댑터 조회, ViewResolver 호출 등)을 모두 자동으로 해결해주는 편의 기능은 엄청난 강점이었습니다. 자세한 내용은 <a href="https://blog.coderoad.kr/mvcpattern" target="_blank" rel="noopener noreferer">Spring MVC</a>에 정리했습니다.</p>
<h2 id="spring-boot의-등장" class="heading">Spring Boot의 등장</h2>
<p>Java 웹 기술의 최강자로 우뚝 선 Spring은 이에 멈추지 않고 Spring마저 손쉽게 사용할 수 있도록 <strong>Spring Boot</strong>를 출시했습니다. Spring Boot는 과거, 개발자가 서버 컴퓨터에 직접 WAS(Web Application Server)를 설치하고, 개발한 소스 코드는 War 파일로 만들어서 WAS에 배포하는 모든 복잡한 과정을 단순화했습니다.</p>
<p>Spring Boot는 자체적으로 서버를 내장하고 있으며, 소스 코드 빌드 결과(Jar)에도 WAS를 포함시켜버렸습니다. 즉, 소스 코드를 작성하고, 빌드하는 것만으로도 WAS 서버를 통해 배포가 가능해진 것입니다. 또한, Spring의 여러 프로젝트들을 간단하게 추가하거나 제거할 수 있어 Spring Boot의 등장은 사전 설정이 어려웠던 Spring의 진입 장벽을 확 낮춘 계기가 되었습니다.</p>
<h2 id="java-view-template의-역사" class="heading">Java View Template의 역사</h2>
<p>Java 진영에서 사용하는 View Template에는 앞서 살펴본 JSP와 Freemarker, Velocity 등의 여러 기술들이 있습니다. 그러나 최근 Java 진영의 표준이라고 할 수 있는 템플릿 엔진은 <strong>Thymeleaf</strong>입니다. Thymeleaf가 최선의 선택 된 이유는 먼저, JSP는 속도도 느리고 편의 기능이 부족했습니다. 그런 와중에 Thymeleaf가 <strong>Natural Template</strong> 기술을 지원하고 Spring MVC와의 연계를 강화하면서 JSP는 요즘 거의 사용하지 않게 되었습니다.</p>
<p>만약, Spring Boot를 통해 개발하면서 View를 그려야할 상황이 생긴다면 Thymeleaf를 공부하고 적극 활용하는게 좋을 것 같습니다. 물론, 성능 자체는 Freemarker와 Velocity가 더 빠르지만 Spring에서도 Thymeleaf를 전폭적으로 지원하고 있다고 합니다.</p>]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[WAS와 멀티 스레딩]]></title>
    <link>https://blog.coderoad.kr/multithread</link>
    <pubDate>2023-01-17</pubDate>
    <guid isPermaLink="false">https://blog.coderoad.kr/multithread</guid>
    <description>
    <![CDATA[동시 요청 처리를 위한 스레드 풀]]>
    </description>
    <content:encoded>
      <![CDATA[<p><strong>본 문서는 인프런에서 수강할 수 있는 <a href="https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-mvc-1/dashboard" target="_blank" rel="noopener noreferer">스프링 MVC 1편 - 백엔드 웹 개발 핵심 기술</a>을 수강한 후, 공부한 내용을 정리한 문서입니다. 본 문서의 모든 저작권은 해당 강의의 저자이신 <a href="https://inflearn.com/users/@yh" target="_blank" rel="noopener noreferer">김영한</a> 우아한형제들 기술이사님께 있습니다.</strong></p>
<h2 id="thread" class="heading">Thread</h2>
<h2 id="was와-멀티-스레드" class="heading">WAS와 멀티 스레드</h2>
<h2 id="마치-싱글-스레드-같이" class="heading">마치 싱글 스레드 같이</h2>
<h2 id="주의해야할-점" class="heading">주의해야할 점!</h2>]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[Servlet이란?]]></title>
    <link>https://blog.coderoad.kr/servlet</link>
    <pubDate>2023-01-17</pubDate>
    <guid isPermaLink="false">https://blog.coderoad.kr/servlet</guid>
    <description>
    <![CDATA[Java와 Servlet]]>
    </description>
    <content:encoded>
      <![CDATA[<p><strong>본 문서는 인프런에서 수강할 수 있는 <a href="https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-mvc-1/dashboard" target="_blank" rel="noopener noreferer">스프링 MVC 1편 - 백엔드 웹 개발 핵심 기술</a>을 수강한 후, 공부한 내용을 정리한 문서입니다. 본 문서의 모든 저작권은 해당 강의의 저자이신 <a href="https://inflearn.com/users/@yh" target="_blank" rel="noopener noreferer">김영한</a> 우아한형제들 기술이사님께 있습니다.</strong></p>
<h2 id="servlet" class="heading">Servlet?</h2>
<h2 id="복잡하고-낭비되는-작업으로부터의-해방" class="heading">복잡하고 낭비되는 작업으로부터의 해방</h2>
<h2 id="servlet-컨테이너" class="heading">Servlet 컨테이너</h2>
<h2 id="싱글톤-패턴" class="heading">싱글톤 패턴</h2>]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[Web 서버와 WAS]]></title>
    <link>https://blog.coderoad.kr/webwas</link>
    <pubDate>2023-01-17</pubDate>
    <guid isPermaLink="false">https://blog.coderoad.kr/webwas</guid>
    <description>
    <![CDATA[닮은 듯 다른, 웹 시스템의 두 서버]]>
    </description>
    <content:encoded>
      <![CDATA[<p><strong>본 문서는 인프런에서 수강할 수 있는 <a href="https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-mvc-1/dashboard" target="_blank" rel="noopener noreferer">스프링 MVC 1편 - 백엔드 웹 개발 핵심 기술</a>을 수강한 후, 공부한 내용을 정리한 문서입니다. 본 문서의 모든 저작권은 해당 강의의 저자이신 <a href="https://inflearn.com/users/@yh" target="_blank" rel="noopener noreferer">김영한</a> 우아한형제들 기술이사님께 있습니다.</strong></p>
<h2 id="web-server-was" class="heading">Web Server? WAS?</h2>
<h2 id="web-server" class="heading">Web Server</h2>
<h2 id="web-application-server" class="heading">Web Application Server</h2>
<h2 id="둘은-왜-분리되어야-하는가" class="heading">둘은 왜 분리되어야 하는가?</h2>
<h2 id="was만-있어도-되는-경우" class="heading">WAS만 있어도 되는 경우</h2>]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[좋은 객체 지향 프로그래밍]]></title>
    <link>https://blog.coderoad.kr/oop</link>
    <pubDate>2023-01-16</pubDate>
    <guid isPermaLink="false">https://blog.coderoad.kr/oop</guid>
    <description>
    <![CDATA[Spring과 OOP]]>
    </description>
    <content:encoded>
      <![CDATA[<p><strong>본 문서는 인프런에서 수강할 수 있는 <a href="https://inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8" target="_blank" rel="noopener noreferer">스프링 핵심 원리 - 기본편</a>을 수강한 후, 공부한 내용을 정리한 문서입니다. 본 문서의 모든 저작권은 해당 강의의 저자이신 <a href="https://inflearn.com/users/@yh" target="_blank" rel="noopener noreferer">김영한</a> 우아한형제들 기술이사님께 있습니다.</strong></p>
<h2 id="객체-지향-프로그래밍" class="heading">객체 지향 프로그래밍</h2>
<p>객체 지향 프로그래밍의 특징으로는 다양한 것들이 있습니다. 클래스 개념으로 대표되는 <strong>캡슐화(Encapsulation)</strong>, 캡슐화에서 파생된 개념인 접근 제어자를 통한 <strong>정보 은닉(Information hiding)</strong>, 부모 클래스의 요소들을 자식 클래스에서 물려받을 수 있는 <strong>상속(Inheritance)</strong>, 프로그램이 유연하고 변경이 용이하게 해주는 **다형성(Polymorphism)**이 객체 지향의 특징들입니다.</p>
<p>그 중에서도 가장 핵심이라고 할 수 있는 특징은 <strong>다형성</strong>입니다. Spring은 이 다형성의 장점을 극대화하여 활용할 수 있게 도와주는 프레임워크입니다. Spring이 다형성을 어떻게 다루는지 알아보기 전에 다형성에 대해서 좀 더 알아보겠습니다.</p>
<h2 id="다형성이란" class="heading">다형성이란?</h2>
<p>**다형성(Polymorphism)**을 쉽게 이해하기 위해선 <strong>역할</strong>과 <strong>구현</strong>으로 세상을 구분해보는 것이 가장 좋습니다. 가장 대표적인 예시는 <strong>운전자</strong>와 <strong>자동차</strong>입니다. 운전자와 자동차라는 <strong>역할</strong>은 그 자리에 어떤 구현체(예를 들어 택시 운전사와 아반떼)가 오던 운전자는 자동차를 운전할 수 있습니다. 즉, 구현체와 관계 없이 동작은 한다는 의미입니다. 물론 운전자에 프로 레이싱 선수, 자동차에 슈퍼카라는 구현체가 운전자와 자동차 역할을 담당한다면 훨씬 좋은 성능을 낼 수 있을 것입니다. 여기서 중요한 점은 운전자, 자동차라는 역할과 그 역할을 수행할 구현체는 유연하고 변경이 용이해야한다는 점입니다.</p>
<p>역할과 구현을 분리하는 것이 백엔드 프로그래밍에서 주는 장점은 다음과 같습니다.</p>
<ul>
<li>클라이언트는 대상의 역할(인터페이스)만 알고 있으면 된다.</li>
<li>클라이언트는 구현 대상의 내부 구조를 몰라도 된다.</li>
<li>클라이언트는 구현 대상의 내부 구조가 변경되어도 영향을 받지 않는다.</li>
<li>클라이언트는 구현 대상 자체를 변경해도 영향을 받지 않는다.</li>
</ul>
<p>우리가 Spring을 공부하는 중요한 이유 중 하나가 백엔드 프로그래밍 분야에서 가장 강력한 기술을 갖기 위해서임은 부정할 수 없는 사실입니다. 위와 같은 장점들을 통해 우린 클라이언트와 상관없이 독립적으로 유연하고 변경이 용이한 환경에서 개발할 수 있습니다.</p>
<h2 id="java에서의-다형성" class="heading">Java에서의 다형성</h2>
<p>Java에서 <strong>역할</strong>은 <strong>인터페이스(Interface)</strong>, <strong>구현</strong>은 인터페이스를 통해 구현한 <strong>구현체</strong>입니다. 우리는 항상 객체를 설계할 때 역할과 구현을 명확하게 분리해야 합니다. <strong>역할을 먼저</strong> 부여하고, 그 역할을 올바르게 수행하는 <strong>구현</strong> 객체를 만들어야합니다. 이 과정이 곧 다형성을 극대화하는 과정이기 때문입니다. Java의 강력한 장점이자 Spring이 탄생한 이유인 <strong>좋은 객체 지향</strong>을 위해서는 필수적입니다.</p>
<p>객체를 역할과 구현으로 구분하는 과정을 Java에서는 **오버라이딩(Overriding)**이라는 문법을 통해 진행할 수 있습니다. 오버라이딩은 Java의 기본 문법으로 프로그램 실행 시에는 오버라이딩된 메소드가 실행된다는 특징이 있습니다. 쉽게 설명하자면 **"덮어쓰기"**입니다. 이 오버라이딩을 통해 확보한 다형성으로 인터페이스를 구현한 구현체를 실행 시점에서 유연하게 변경할 수 있습니다. 물론 인터페이스 뿐만 아니라 클래스 간의 상속 관계에서도 오버라이딩이 가능하고 다형성이 확보됩니다.</p>
<p>코드로 간단하게 Java에서의 다형성을 확인해보면 다음과 같습니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token comment">//역할</span>
</span><span class="code-line"><span class="token keyword">interface</span> <span class="token class-name">Car</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword">void</span> <span class="token function">accelPedal</span><span class="token punctuation">(</span><span class="token keyword">int</span> speed<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token keyword">void</span> <span class="token function">breakPedal</span><span class="token punctuation">(</span><span class="token keyword">int</span> speed<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token comment">//구현체 1</span>
</span><span class="code-line"><span class="token keyword">class</span> <span class="token class-name">SuperCar</span> <span class="token keyword">implements</span> <span class="token class-name">Car</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token annotation punctuation">@Override</span>
</span><span class="code-line">    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">accelPedal</span><span class="token punctuation">(</span><span class="token keyword">int</span> speed<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">        speed <span class="token operator">+=</span> <span class="token number">50</span><span class="token punctuation">;</span>
</span><span class="code-line">        <span class="token keyword">return</span> speed<span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token punctuation">}</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token annotation punctuation">@Override</span>
</span><span class="code-line">    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">breakPedal</span><span class="token punctuation">(</span><span class="token keyword">int</span> speed<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">        speed <span class="token operator">-=</span> <span class="token number">50</span><span class="token punctuation">;</span>
</span><span class="code-line">        <span class="token keyword">return</span> speed<span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token punctuation">}</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token comment">//구현체 2</span>
</span><span class="code-line"><span class="token keyword">class</span> <span class="token class-name">NormalCar</span> <span class="token keyword">implements</span> <span class="token class-name">Car</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token annotation punctuation">@Override</span>
</span><span class="code-line">    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">accelPedal</span><span class="token punctuation">(</span><span class="token keyword">int</span> speed<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">        speed <span class="token operator">+=</span> <span class="token number">25</span><span class="token punctuation">;</span>
</span><span class="code-line">        <span class="token keyword">return</span> speed<span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token punctuation">}</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token annotation punctuation">@Override</span>
</span><span class="code-line">    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">breakPedal</span><span class="token punctuation">(</span><span class="token keyword">int</span> speed<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">        speed <span class="token operator">-=</span> <span class="token number">25</span><span class="token punctuation">;</span>
</span><span class="code-line">        <span class="token keyword">return</span> speed<span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token punctuation">}</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p>Car라는 인터페이스를 통해 역할을 설계했고, 해당 역할을 수행할 SuperCar와 NormalCar라는 두 구현체를 만들었습니다. 프로그래머가 나중에 어떤 구현체를 사용하냐에 따라 다른 성능에 차이가 날 것입니다. 오버라이딩을 통해 역할의 메소드를 서로 다른 성능을 가지도록 만들었으며 이를 실행 시점에 유연하게 변경이 가능합니다. 유연하게 변경하는 과정을 코드로 보면 다음과 같습니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Driver</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">        <span class="token comment">//NormalCar 자리에 SuperCar 구현체로 바꿔 넣기만 해도</span>
</span><span class="code-line">        <span class="token comment">//훨씬 향상된 성능의 메소드가 수행된다!</span>
</span><span class="code-line">        <span class="token comment">//이것이 유연하고 변경이 용이하다는 의미이다.</span>
</span><span class="code-line">        <span class="token class-name">Car</span> myCar <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NormalCar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">        <span class="token keyword">int</span> currentSpeed<span class="token punctuation">;</span>
</span><span class="code-line">        currentSpeed <span class="token operator">=</span> myCar<span class="token punctuation">.</span><span class="token function">accelPedal</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">        currentSpeed <span class="token operator">=</span> myCar<span class="token punctuation">.</span><span class="token function">breakPedal</span><span class="token punctuation">(</span>currentSpeed<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token punctuation">}</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<h2 id="다형성의-본질" class="heading">다형성의 본질</h2>
<p>다형성의 본질은 결국 **유연하게 변경 가능하다.**에 있습니다. 다형성의 본질을 더 확실하게 이해하려면 <strong>협력</strong>이라는 객체 간의 관계를 이해하는데서 시작해야합니다. 현실 세계에서 <strong>혼자 있는 객체는 없습니다</strong>. 다른 어떤 객체와 협력하지 않는 객체는 존재한다고 할 수 없습니다. <strong>나</strong>라는 객체는 <strong>거주지의 역할</strong>을 하는 <strong>집</strong>이라는 객체와 <strong>협력 관계</strong>에 있습니다. 집은 내가 안전하게 생존할 수 있도록 협력하고 나는 집이 튼튼하게 유지될 수 있도록 돈을 들여 유지보수를 합니다. 만약 이 협력 관계가 없다면 두 객체 모두 빠르게 사라져버릴 것입니다. 사람이 살면서 유지보수하지 않는 집은 집으로서 의미가 없어지고 허물어질 것이며, 집이 없는 사람은 여러 위협에 노출되어 생존에 매우 불리해집니다.</p>
<p>이 협력이라는 관계를 컴퓨터 세계로 가져온다면 <strong>클라이언트</strong>와 <strong>서버</strong>로 볼 수 있습니다. 클라이언트는 서버로 요청을 보내고 서버는 요청에 대한 응답을 클라이언트에게 보냅니다. 클라이언트 객체와 서버 객체는 협력 관계에 있습니다. 만약 두 객체 간의 협력이 없다면 클라이언트가 몇 번이고 요청을 보낸다 한들 서버는 응답을 클라이언트에게 보내지 않을 것입니다. 그렇다면 이 객체들을 클라이언트와 서버로 부르는 것은 옳지 않습니다. 각자 클라이언트와 서버라는 역할을 전혀 수행하지 못하고 있기 때문입니다. 즉, 다형성의 기초였던 역할과 구현으로의 분리는 객체 간 협력 관계가 있어야 성립합니다.</p>
<p>이 협력 관계를 유지하면서 <strong>클라이언트를 전혀 변경하지 않고 서버의 구현 기능을 유연하게 변경할 수 있다</strong>는 것이 다형성의 본질입니다.</p>
<h2 id="다형성의-장점과-한계" class="heading">다형성의 장점과 한계</h2>
<p>다형성의 장점에는 다음과 같은 것들이 있습니다.</p>
<ul>
<li>실세계의 역할과 구현이라는 편리한 컨셉을 다형성을 통해 객체 세상으로 가져올 수 있음</li>
<li>유연하고 변경이 용이함</li>
<li>확장 가능한 설계가 가능함</li>
<li>클라이언트에 영향을 주지 않는 변경 가능함</li>
</ul>
<p>이러한 다형성의 장점을 제대로 활용하기 위해선 역할(인터페이스)를 안정적으로 잘 설계하는 것이 중요합니다. 구현체가 인터페이스에 전혀 영향을 주지 않고 변경이 가능해야하므로 설계 단계부터 완벽히 해야합니다. 만약 그렇지 못할 경우에 한계는 다음과 같습니다.</p>
<ul>
<li>역할(인터페이스) 자체가 변하면, 클라이언트, 서버 모두에 큰 변경이 발생함</li>
<li>자동차를 비행기로 변경해야할 때..?</li>
<li>USB 인터페이스가 변경된다면..?</li>
<li>도량형이 변경되어 버린다면..?</li>
</ul>
<p>기준이 되는 역할이 바뀌어버리면 구현체도 모두 변경해야하는 치명적인 단점이 존재합니다. 따라서 다형성을 극대화하여 "좋은 객체 지향" 프로그래밍을 하기 위해서는 항상 역할(인터페이스)의 설계에 가장 많은 시간을 들여 변경을 최소화 해야합니다.</p>
<h2 id="spring과-좋은-객체-지향-프로그래밍" class="heading">Spring과 좋은 객체 지향 프로그래밍</h2>
<p>Spring에서는 위에서 말했던 다형성을 극대화하는데 집중합니다. Spring의 주요 개념인 <strong>제어의 역전(Inversion of Control)</strong>, **의존관계 주입(Dependency Injection)**은 다형성을 활용해 역활과 구현을 편리하게 다룰 수 있도록 지원합니다. 다시 말하면 다형성이 Spring의 알파이자 오메가, 전부라고 할 수 있습니다! Spring을 사용한다면 마치 레고 블럭을 조립하듯 구현체를 편리하게 변경할 수 있습니다. "좋은 객체 지향"을 목표로 만들어진만큼 프로그래머로 하여금 더 쉽게 객체 지향적 프로그래밍을 할 수 있도록 돕는 것이 Spring의 <strong>역할</strong>입니다.</p>]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[Spring이란?]]></title>
    <link>https://blog.coderoad.kr/spring</link>
    <pubDate>2023-01-15</pubDate>
    <guid isPermaLink="false">https://blog.coderoad.kr/spring</guid>
    <description>
    <![CDATA[Spring 기초 정리]]>
    </description>
    <content:encoded>
      <![CDATA[<p><strong>본 문서는 인프런에서 수강할 수 있는 <a href="https://inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8" target="_blank" rel="noopener noreferer">스프링 핵심 원리 - 기본편</a>을 수강한 후, 공부한 내용을 정리한 문서입니다. 본 문서의 모든 저작권은 해당 강의의 저자이신 <a href="https://inflearn.com/users/@yh" target="_blank" rel="noopener noreferer">김영한</a> 우아한형제들 기술이사님께 있습니다.</strong></p>
<h2 id="spring" class="heading">Spring?</h2>
<p>흔히 Spring은 웹 애플리케이션을 쉽게 만들 수 있게 도와주는 프레임워크 정도로만 알려져있습니다. 그러나 Spring이 탄생하게된 계기를 알게된다면 Spring의 본질, 핵심 개념을 다음과 같이 말할 수 있습니다.</p>
<blockquote>
<p>"Spring은 <strong>좋은 객체 지향</strong> 애플리케이션을 개발할 수 있게 도와주는 프레임워크이다."</p>
</blockquote>
<p>물론 Spring은 웹 애플리케이션을 만드는데 정말 많은 도움을 주는 프레임워크가 맞습니다. 그러나 Spring이 탄생하게된 계기는 "좋은 객체 지향" 개발을 위해서였습니다. 그렇다면, 도대체 왜, 어떻게 만들어졌길래 Spring이 좋은 객체 지향 애플리케이션을 개발하는데 도움이 되는지 알아보겠습니다.</p>
<h2 id="spring의-탄생" class="heading">Spring의 탄생</h2>
<p>Spring은 2002년 <strong>로드 존슨</strong>(Rod Johnson)이라는 개발자가 써낸 <strong>Expert One-on-One J2EE Design and Development</strong>이라는 책에 나온 코드를 기반으로 발전한 프레임워크입니다. 2000년대 초반, 당시 기업들은 시스템을 구현하기 위한 서버 애플리케이션으로 Java의 가장 거대한 기술 표준이었던 J2EE의 API 중 하나인 <strong>Enterprise Java Beans</strong>(EJB)를 사용했습니다. 서버와 관련된 고급 기술들을 제공하던 종합 선물 세트 같은 느낌의 API였지만 큰 문제가 있었습니다. <strong>EJB는 느리고 어려웠습니다.</strong></p>
<p>EJB에서 지원하는 기술들은 원리를 파악하기도 힘들고 테스트를 통한 개발(추후에 정리할 테스트 주도 개발)도 매우 힘들었습니다. 또한 EJB를 이용해 개발할 때는 전적으로 EJB에 의존해서 개발을 해야했기에 Java의 가장 강력한 장점이자 정체성인 <strong>객체 지향 프로그래밍이 전혀 지켜지지 못할 정도</strong>로 코드가 난해하고 확장성이 떨어졌습니다. 이런 쉽지 않은 개발 환경 때문에 <strong>POJO</strong>(Plain Old Java Object)라는 용어까지 등장하며 **순수한 Java로 돌아가자!**라는 생각이 Java 개발자들 사이에서 많아졌습니다.</p>
<p>이때 등장한 것이 앞서 언급한 로드 존슨의 저서입니다. 로드 존슨은 해당 책에서 EJB의 문제점을 지적하며 EJB 없이 순수한 Java 코드로만 더 나은 프로그램을 만들 수 있다는 것을 보여줬습니다. 또한 이 코드들을 본 유겐 휠러(Juergen Hoeller)와 얀 카로프(Yann Caroff)가 로드 존슨에게 이 소스들을 오픈 소스 프로젝트로 발전시키자는 제안을 했고 마침내 <strong>Spring</strong>이 탄생하게 되었습니다. 현재도 유겐 휠러가 Spring Framework의 리드 개발자로서 Spring을 발전시키고 있습니다. 여담으로 Spring이라는 이름은 혹독한 겨울 같았던 Java 개발 생태계를 봄처럼 따뜻하게 만들었다는 의미로 지어졌습니다.</p>
<p>2003년 6월에 처음 공개된 XML 기반의 Spring Framework 1.0을 시작으로 2023년 1월 현재 최신 버전인 Spring Framework 6.0.4와 Spring의 치명적인 단점이었던 개발 사전 설정을 도와주는 Spring Boot 3.0.1까지 약 20년의 시간 동안 Spring은 꾸준히 발전해왔습니다.</p>
<h2 id="spring-생태계" class="heading">Spring 생태계</h2>
<p>Spring 생태계에는 사용자에게 다양한 기능을 제공해주는 많은 프로젝트들이 있습니다. Spring 생태계를 이루는 대표적인 프로젝트들은 다음과 같습니다.</p>
<ul>
<li>Spring Framework</li>
<li>Spring Boot</li>
<li>Spring Data</li>
<li>Spring Session</li>
<li>Spring Security</li>
<li>Spring Batch</li>
<li>Spring Cloud</li>
<li>Spring REST Docs</li>
</ul>
<p>이외에도 많은 프로젝트들을 Spring 공식 페이지에서 확인할 수 있습니다. <a href="https://spring.io/projects" target="_blank" rel="noopener noreferer">Spring Projects</a></p>
<p>이렇게 많은 Spring 프로젝트 중에서 필수적인 두 가지는 Spring 그 자체라고 할 수 있는 <strong>Spring Framework</strong>와 모든 Spring 기술들을 편리하게 사용할 수 있도록 도와주는 <strong>Spring Boot</strong>입니다. Spring Framework 없이는 위에 적어둔 다른 기술들을 사용할 수 없습니다. 또한 본격적인 개발을 시작하기 전에 프로젝트 설정하기가 Spring의 절반이라고 할 수 있을 정도로 Spring Boot는 요즘 Spring Framework를 사용할 때 항상 함께 사용합니다.</p>
<p>가장 중요한 두 프로젝트의 특징들을 살펴보겠습니다.</p>
<ul>
<li><strong>Spring Framework</strong>
<ul>
<li>Spring의 뿌리</li>
<li>핵심 기술 - Spring DI Container, AOP, Event, etc...</li>
<li>웹 기술 - Spring MVC, Spring WebFlux</li>
<li>데이터 접근 기술 - Transaction, JDBC, ORM, XML</li>
</ul>
</li>
<li><strong>Spring Boot</strong>
<ul>
<li>단독으로 실행할 수 있는 Spring Application을 쉽게 생성</li>
<li>Tomcat과 같은 웹 서버를 내장해 별도의 웹 서버 설치 필요 없음</li>
<li>손쉬운 빌드 구성을 위한 starter 종속성 제공 (starter만 가져오면 자동으로 관련 의존관계 모두 설정)</li>
<li>스프링과 서드 파티(외부) 라이브러리 자동 구성 (주요 라이브러리의 호환성을 자동으로 검사하고 호환이 잘되는 버전을 탑재)</li>
<li>메트릭, 상태 확인, 외부 구성 같은 프로덕션 준비 기능 제공 (운영 환경에서의 모니터링 등)</li>
<li>관례에 의한 간결한 설정</li>
</ul>
</li>
</ul>
<p>위에서 살펴본대로 Spring Framework는 웹 기술 뿐만 아니라 다른 많은 기술들도 제공합니다. 또한 Spring Boot가 제공하는 많은 편의 기능들은 만약 Spring Boot가 없었다면 사용자가 직접 해야하는 작업이 얼마나 많은지 알 수 있게 해줍니다.</p>
<h2 id="spring의-핵심-개념" class="heading">Spring의 핵심 개념</h2>
<p>지금까지 Spring에 관해서 대략적으로 살펴봤습니다. 처음으로 돌아가, Spring의 본질이자 핵심 개념은 웹 애플리케이션을 쉽게 만들 수 있게 도와주는 프레임워크가 아니라고 말했습니다.</p>
<p>Spring이 탄생하게된 계기였던 로드 존슨의 저서도 Java의 EJB를 개선하고자 써내려갔고, 개발자들이 "순수한 Java"(POJO)로 더 나은 서버 프로그래밍을 위해 발전시켜온 것이 Spring이기에 웹 애플리케이션 제작에 큰 도움이 되는 것은 사실입니다. 그러나 Spring은 웹 애플리케이션에 국한되지 않고 <strong>더 빠르고, 더 쉽고, 더 안전한 Java 프로그래밍</strong>을 도와준다고 설명해왔습니다. <a href="https://spring.io/why-spring" target="_blank" rel="noopener noreferer">Why Spring?</a></p>
<p>즉, <strong>Spring의 정수는 더 나은 Java 프로그래밍, "좋은 객체 지향" 프로그래밍</strong>인 것입니다. 따라서 Spring을 완벽하게 이해하고, 활용하기 위해서는 Java의 핵심인 "객체 지향 프로그래밍"에 대한 이해가 필요합니다. Spring이 제공하는 API만 따라치기 급급한 개발자가 아닌 Spring을 통해 더 나은 애플리케이션을 만들어낼 수 있는 개발자가 되어야합니다.</p>
<p>Spring이 EJB의 과도한 의존관계를 비판하며 탄생했던 것처럼, 우리 역시 Spring이 주는 편의성에 의존하지 않아야합니다. 부가적인 기술이 아닌, 더 좋은 객체 지향 프로그래밍을 위해 Spring을 활용해야하는 것입니다.</p>]]>
    </content:encoded>
  </item>
    </channel>
  </rss>