<?xml version="1.0" ?>
  <rss
    xmlns:dc="http://purl.org/dc/elements/1.1/"
    xmlns:content="http://purl.org/rss/1.0/modules/content/"
    xmlns:atom="http://www.w3.org/2005/Atom"
    version="2.0"
  >
    <channel>
        <title><![CDATA[Coderoad]]></title>
        <link>https://blog.coderoad.kr</link>
        <description>
          <![CDATA[Road to good developer.]]>
        </description>
        <language>en</language>
        <lastBuildDate>2023-01-18</lastBuildDate>
        <item>
    <title><![CDATA[캐시와 조건부 요청 헤더]]></title>
    <link>https://blog.coderoad.kr/cache</link>
    <pubDate>2023-01-18</pubDate>
    <guid isPermaLink="false">https://blog.coderoad.kr/cache</guid>
    <description>
    <![CDATA[HTTP 캐시와 조건부 요청 헤더란?]]>
    </description>
    <content:encoded>
      <![CDATA[<p><strong>본 문서는 인프런에서 수강할 수 있는 <a href="https://www.inflearn.com/course/http-%EC%9B%B9-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC" target="_blank" rel="noopener noreferer">모든 개발자를 위한 HTTP 웹 기본 지식</a>을 수강한 후, 공부한 내용을 정리한 문서입니다. 본 문서의 모든 저작권은 해당 강의의 저자이신 <a href="https://inflearn.com/users/@yh" target="_blank" rel="noopener noreferer">김영한</a> 우아한형제들 기술이사님께 있습니다.</strong></p>
<h2 id="캐시란" class="heading">캐시란?</h2>
<p>캐시가 없다면... 같은 리소스를 매번 다운로드. 인터넷 네트워크는 매우 느리고 비싸다. 브라우저 속도도 당연히 느려지고, 사용자도 느린 속도에 불편함을 경험한다.
"cache-control: max-age=시간(초)" 헤더를 통해 캐시를 적용할 수 있다. 처음 요청을 제외하곤 항상 브라우저 캐시 저장소를 먼저 방문해서 캐시 유무를 확인한다.
그러나 max-age 속성에 정해둔 시간이 지나면 캐시는 자동으로 삭제된다.(캐시 시간 초과) 그러면 서버에서 다시 다운로드 해야한다. 이를 해결하기 위해 검증 헤더와 조건부 요청을 사용한다.</p>
<h2 id="검증-헤더와-조건부-요청" class="heading">검증 헤더와 조건부 요청</h2>
<p>검증 헤더 "Last-Modified: (날짜)"를 추가해 데이터가 마지막으로 수정된 시간을 기준으로 시간 초과된 캐시 데이터와 서버의 데이터가 아직 일치하다면 기존 캐시 데이터 계속 이용 가능. (서버는 304 Not Modified 상태 코드를 보내 캐시를 재사용해도 좋다고 알린다. Not Modified는 HTTP Body가 없다. 데이터를 바꿀 필요도 없고 용량을 절약해야하기 때문.)</p>
<p>검증 헤더
캐시 데이터와 서버 데이터가 같은지 검증하는 데이터
Last-Modified, ETag</p>
<p>조건부 요청 헤더
검증 헤더로 조건에 따른 분기
If-Modified-Since: Last-Modified 사용
If-None-Match: ETag 사용
조건이 만족하면 200 OK
조건이 만족하지 않으면 304 Not Modified</p>
<p>Last-Modified, If-Modified-Since 단점
1초 미만의 캐시 조정 불가. 날짜 기반의 로직 사용해야함. 데이터를 수정해서 날짜는 다른데 정작 데이터 내용은 같으면 캐시 유지 불가. 서버에서 별도의 캐시 로직을 다루지 못함.</p>
<p>ETag(Entitiy Tag)
캐시용 데이터에 임의의 고유한 버전 이름을 달아둠.
데이터가 변경되면 이 이름을 바꿈. ETag가 같으면 캐시 유지, 다르면 갱신.
캐시 제어 로직을 서버에서 완전히 관리. (ETag 부여를 서버에서 한다.)</p>
<h2 id="캐시와-조건부-요청-헤더" class="heading">캐시와 조건부 요청 헤더</h2>
<p>캐시 제어 헤더
Cache-Control : 캐시 제어
Pragma : 캐시 제어(하위 호환, HTTP 구 버전을 위함)
Expires : 캐시 유효 기간(하위 호환, HTTP 구 버전을 위함)</p>
<p>Cache-Control: max-age : 유효 시간
Cache-Control: no-cache : 데이터는 캐시 가능. 그러나 항상 원 서버에 검증 요청.
Cache-Control: no-store : 데이터에 민감한 정보 있음. 캐시 불가.</p>
<p>검증 헤더
ETag
Last-Modified</p>
<p>조건부 요청 헤더
If-Match, If-None-Match : ETag 사용
If-Modified-Since, If-Unmodified-Since : Last-Modified 사용</p>
<h2 id="프록시-캐시" class="heading">프록시 캐시</h2>
<p>서버와 서버 사이의 거리는 매우 멀다. 한국의 클라이언트와 미국의 서버(오리진 서버)가 직통으로 통신하면 응답이 느리게 도착한다. 그래서 보통 통신 중간에 캐시 데이터를 저장해두는 프록시 캐시 서버를 두어 응답 속도를 높인다. 이때 클라이언트에 있는 캐시를 private 캐시, 프록시 캐시 서버에 있는 캐시를 public 캐시라고 한다.</p>
<p>Cache-Control: public (프록시 캐시 서버에 저장해도 무방함.)
Cache-Control: private (해당 응답이 사용자만을 위한 것. 프록시 캐시 서버에 저장 불가.)
Cache-Control: s-maxage (프록시 캐시에만 적용되는 max-age)
Age: 60 (오리진 서버의 응답 후 프록시 캐시 내에 머문 시간)</p>
<h2 id="캐시-무효화" class="heading">캐시 무효화</h2>
<p>Cache-Control: no-cache, no-store, must-revalidate (원 서버에 데이터 검증을 항상 받고, 캐시로 저장하지 않으며, 원 서버에 검증받아야 하고 만일 서버 접근 실패 시 504 Gateway Timeout이 발생해야함.)
Pragma: no-cache (HTTP/1.0 하위 호환)</p>
<p>no-cache는 만일 원 서버에 접근이 불가하면 오류대신 기존의 데이터를 사용하는 편이 낫다고 판단하고. 시간이 초과된 캐시 데이터를 계속 사용하게 하지만. must-validate는 504 Gateway Timeout 상태 코드를 반환해 캐시를 삭제시킨다.</p>]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[HTTP]]></title>
    <link>https://blog.coderoad.kr/http</link>
    <pubDate>2023-01-18</pubDate>
    <guid isPermaLink="false">https://blog.coderoad.kr/http</guid>
    <description>
    <![CDATA[웹 개발을 한다면 무조건 알아야 할 HTTP]]>
    </description>
    <content:encoded>
      <![CDATA[<p><strong>본 문서는 인프런에서 수강할 수 있는 <a href="https://www.inflearn.com/course/http-%EC%9B%B9-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC" target="_blank" rel="noopener noreferer">모든 개발자를 위한 HTTP 웹 기본 지식</a>을 수강한 후, 공부한 내용을 정리한 문서입니다. 본 문서의 모든 저작권은 해당 강의의 저자이신 <a href="https://inflearn.com/users/@yh" target="_blank" rel="noopener noreferer">김영한</a> 우아한형제들 기술이사님께 있습니다.</strong></p>
<h2 id="http의-시대" class="heading">HTTP의 시대</h2>
<p>HTTP 메시지에 모든 것을 전송. HTML, Text, 이미지, 음악, 영상, 파일, JSON, XML, 거의 모든 형태의 데이터 전송 가능. Server to Server 데이터 통신에도 사용</p>
<h2 id="클라이언트-서버-구조" class="heading">클라이언트-서버 구조</h2>
<p>Request - Response 구조
클라이언트는 서버에 요청을 보내고 서버의 응답을 대기
서버가 요청에 대한 결과를 만들어서 응답</p>
<h2 id="stateful과-stateless" class="heading">Stateful과 Stateless</h2>
<p>HTTP는 무상태(Stateless) 프로토콜이다. 서버가 클라이언트의 상태를 보존하지 않는다. 덕분에 서버 확장성(서버 확충)이 높다. 단점은 클라이언트가 매번 추가 데이터를 전송해야한다.
Stateful에서는 이전 요청에 대한 상태를 기억하고 있다. 그런데 한 명의 사용자에게 하나의 서버를 계속 붙여주는 것이 아니기 때문에 중간에 다른 서버에서 응답을 줘야하는 상황에서는 이전 상황에 대해 아는 것이 없어 제대로 된 데이터 통신이 불가능하다. 무상태에서는 현재 상태에 대한 정보를 클라이언트에서 계속 보내주어 이러한 문제가 해결 가능하다.</p>
<p>그러나 모든 상황에서 무상태를 사용할 수 있는 것은 아니다. (로그인 유지는 모든 서버가 알아야 한다.) 그래도 상태 유지는 최소한으로 사용해야한다.</p>
<h2 id="비연결성connectionless" class="heading">비연결성(Connectionless)</h2>
<p>HTTP는 비연결성 프로토콜이다. HTTP는 서버가 클라이언트의 요청에 대한 응답을 완료하면 즉시 연결을 끊는다. 서버 자원의 낭비를 막을 수 있다. 다만 매번 새로 연결을 해야하기 때문에 3 way handshake(SYN, SYN+ACK, ACK)이 매번 발생. 매번 수많은 리소스들이 다시 다운로드됨. 이 문제는 HTTP 지속 연결로 해결. 최신 버전인 HTTP/2, HTTP/3에선 최적화.</p>
<h2 id="http-메시지" class="heading">HTTP 메시지</h2>
<p>start-line -> header -> (공백(CRLF)) -> message body</p>]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[HTTP 헤더]]></title>
    <link>https://blog.coderoad.kr/httpheader</link>
    <pubDate>2023-01-18</pubDate>
    <guid isPermaLink="false">https://blog.coderoad.kr/httpheader</guid>
    <description>
    <![CDATA[HTTP의 필수 정보들이 담기는 곳]]>
    </description>
    <content:encoded>
      <![CDATA[<p><strong>본 문서는 인프런에서 수강할 수 있는 <a href="https://www.inflearn.com/course/http-%EC%9B%B9-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC" target="_blank" rel="noopener noreferer">모든 개발자를 위한 HTTP 웹 기본 지식</a>을 수강한 후, 공부한 내용을 정리한 문서입니다. 본 문서의 모든 저작권은 해당 강의의 저자이신 <a href="https://inflearn.com/users/@yh" target="_blank" rel="noopener noreferer">김영한</a> 우아한형제들 기술이사님께 있습니다.</strong></p>
<h2 id="http-헤더" class="heading">HTTP 헤더</h2>
<p>header-field = field-name":" OWS field-value OWS (OWS : 띄어쓰기 허용)
field-name은 대소문자 구분 없음. (ex. Host: <a href="http://www.google.com" target="_blank" rel="noopener noreferer">www.google.com</a> )
HTTP 전송에 필요한 모든 부가 정보. 표준 헤더가 너무 많다... 필요할 땐 임의 헤더 추가 가능.</p>
<p>HTTP Body
RFC723X 시리즈에 와서 엔티티는 표현(Representation). Representation = representation metadata + representation data. 즉, 표현 = 표현 메타데이터 + 표현 데이터.</p>
<p>메시지 본문을 통해 표현 데이터 전달. 메시지 본문 = 페이로드(payload). 표현은 요청이나 응답에서 전달할 실제 데이터. 표현 헤더는 표현 데이터를 해석할 수 있는 정보 제공.</p>
<h2 id="표현" class="heading">표현</h2>
<p>Content-Type : 표현 데이터의 형식
Content-Encoding : 표현 데이터의 압축 방식
Content-Language : 표현 데이터의 자연 언어
Content-Length : 표현 데이터의 길이</p>
<p>표현 헤더는 전송, 응답 둘다 사용</p>
<h2 id="협상콘텐츠-네고시에이션" class="heading">협상(콘텐츠 네고시에이션)</h2>
<p>Accept : 클라이언트가 선호하는 미디어 타입 전달
Accept-Charset : 클라이언트가 선호하는 문자 인코딩
Accept-Encoding : 클라이언트가 선호하는 압축 인코딩
Accept-Language : 클라이언트가 선호하는 자연 언어</p>
<p>협상 헤더는 요청 시에만 사용</p>
<p>협상과 우선순위
0 ~ 1 클수록 높은 우선순위, 생략하면 1, 구체적인 것이 우선한다. 구체적인 것을 기준으로 미디어 타입을 맞춘다.</p>
<h2 id="전송-방식" class="heading">전송 방식</h2>
<p>단순 전송(Content-Length), 압축 전송(Content-Encoding), 분할 전송(Transfer-Encoding), 범위 전송(Range, Content-Range)</p>
<h2 id="일반-정보" class="heading">일반 정보</h2>
<p>From : 유저 에이전트의 이메일 정보
Referer : 이전 웹 페이지 주소
User-Agent : 유저 에이전트 애플리케이션 정보
Server : 요청을 처리하는 오리진 서버의 소프트웨어 정보
Date : 메시지가 생성된 날짜</p>
<h2 id="특별한-정보" class="heading">특별한 정보</h2>
<p>Host : 요청한 호스트 정보 (도메인)
Location : 페이지 리다이렉션
Allow : 허용 가능한 HTTP 메소드
Retry-After : 유저 에이전트가 다음 요청을 하기까지 기다려야 하는 시간</p>
<h2 id="인증" class="heading">인증</h2>
<p>Authorization : 클라이언트 인증 정보를 서버에 전달
WWW-Authenticate : 리소스 접근시 필요한 인증 방법 정의</p>
<h2 id="쿠키" class="heading">쿠키</h2>
<p>Set-Cookie : 서버에서 클라이언트로 쿠키 전달(응답)
Cookie : 클라이언트가 서버에서 받은 쿠키를 저장하고, HTTP 요청 시 서버로 전달</p>
<p>생명주기 Expires, max-age
도메인 명시: 명시한 문서 기준 도메인 + 서브 도메인 포함. 생략: 현재 문서 기준 도메인만 적용
경로 : 이 경로를 포함한 하위 경로 페이지만 쿠키 접근
보안 : Secure(https에서만 전송), HttpOnly(자바스크립트의 쿠키 접근 불가.) SameSite(요청 도메인과 쿠키에 설정된 도메인이 같은 경우에만 쿠키 전송)</p>]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[HTTP 메소드]]></title>
    <link>https://blog.coderoad.kr/httpmethod</link>
    <pubDate>2023-01-18</pubDate>
    <guid isPermaLink="false">https://blog.coderoad.kr/httpmethod</guid>
    <description>
    <![CDATA[HTTP는 어떻게 동작할까?]]>
    </description>
    <content:encoded>
      <![CDATA[<p><strong>본 문서는 인프런에서 수강할 수 있는 <a href="https://www.inflearn.com/course/http-%EC%9B%B9-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC" target="_blank" rel="noopener noreferer">모든 개발자를 위한 HTTP 웹 기본 지식</a>을 수강한 후, 공부한 내용을 정리한 문서입니다. 본 문서의 모든 저작권은 해당 강의의 저자이신 <a href="https://inflearn.com/users/@yh" target="_blank" rel="noopener noreferer">김영한</a> 우아한형제들 기술이사님께 있습니다.</strong></p>
<h2 id="http-api-만들기" class="heading">HTTP API 만들기</h2>
<p>URI는 리소스만 고려해야한다. 행동(등록, 조회, 수정, 삭제)는 URI에 포함시키지 않는다.</p>
<h2 id="get" class="heading">GET</h2>
<p>리소스 조회</p>
<h2 id="post" class="heading">POST</h2>
<p>클라이언트에서 서버로 데이터를 전송해 서버가 처리하도록 전달하는 메소드. 메시지 바디를 통해 전달하며 주로 전달된 데이터로 신규 리소스 등록, 프로세스 처리 등에 사용한다.</p>
<h2 id="put" class="heading">PUT</h2>
<p>리소스 데이터 등록. 기존 데이터가 있다면 완전히 지우고 요청한 데이터 등록. (덮어쓰기)</p>
<h2 id="patch" class="heading">PATCH</h2>
<p>리소스 데이터 수정. 기존 데이터를 수정한다.</p>
<h2 id="delete" class="heading">DELETE</h2>
<p>리소스 데이터 삭제.</p>
<h2 id="http-메소드의-속성들" class="heading">HTTP 메소드의 속성들</h2>
<p>안전, 멱등, 캐시 가능</p>
<h2 id="클라이언트에서-서버로" class="heading">클라이언트에서 서버로</h2>
<p>크게 두가지 방식. 쿼리 파라미터를 통한 전송 (GET, 주로 정렬 필터(검색어)), 메시지 바디를 통한 데이터 전송 (POST, PUT, PATCH 회원 가입, 상품 주문, 리소스 등록, 리소스 변경). 4가지 상황 (정적 데이터 조회(GET, 리소스 경로), 동적 데이터 조회(GET, 쿼리 파라미터), HTML Form (GET(조회)/POST(저장), multipart/form-data), HTTP API (Server to server, App, Web, POST/PUT/PATCH, GET, Content-Type:application/json))</p>
<h2 id="http-api-설계-예시" class="heading">HTTP API 설계 예시</h2>
<p>HTTP API - 컬렉션 (POST 기반 리소스 등록) : 서버가 리소스의 URI를 관리 POST /members -> 서버가 /members/{id} 생성 후 저장
HTTP API - 스토어 (PUT 기반 리소스 등록) : 클라이언트가 리소스의 URI를 관리 PUT /filse/{filename} -> 서버는 저장
HTML FORM 사용 (GET/POST) : DELETE 같은 HTTP 메소드 사용 불가, 컨트롤러(컨트롤 URI, 동사 형태의 API)를 사용해야함. POST /members/{id}/delete</p>]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[HTTP 상태코드]]></title>
    <link>https://blog.coderoad.kr/httpstatus</link>
    <pubDate>2023-01-18</pubDate>
    <guid isPermaLink="false">https://blog.coderoad.kr/httpstatus</guid>
    <description>
    <![CDATA[404? 500? 200? 헷갈리는 HTTP의 상태코드들]]>
    </description>
    <content:encoded>
      <![CDATA[<p><strong>본 문서는 인프런에서 수강할 수 있는 <a href="https://www.inflearn.com/course/http-%EC%9B%B9-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC" target="_blank" rel="noopener noreferer">모든 개발자를 위한 HTTP 웹 기본 지식</a>을 수강한 후, 공부한 내용을 정리한 문서입니다. 본 문서의 모든 저작권은 해당 강의의 저자이신 <a href="https://inflearn.com/users/@yh" target="_blank" rel="noopener noreferer">김영한</a> 우아한형제들 기술이사님께 있습니다.</strong></p>
<h2 id="http-상태코드" class="heading">HTTP 상태코드</h2>
<p>클라이언트가 보낸 요청의 처리 상태를 응답에서 알려주는 기능. 클라이언트에서는 상위 상태코드로 상태를 해석한다. (2XX이면 성공!)</p>
<h2 id="2xx---successful" class="heading">2XX - Successful</h2>
<ul>
<li>
<p><strong>200 OK</strong>
요청 성공</p>
</li>
<li>
<p><strong>201 Created</strong>
요청 성공으로 새로운 리소스 생성</p>
</li>
<li>
<p><strong>202 Accepted</strong>
요청 접수되었으나 처리 미완 (배치 처리)</p>
</li>
<li>
<p><strong>204 No Content</strong>
요청 성공적으로 수행, 그러나 응답 메시지로 보낼 데이터 없음 (게시글 Save 버튼)</p>
</li>
</ul>
<h2 id="3xx---redirection" class="heading">3XX - Redirection</h2>
<h3 id="영구-리다이렉션">영구 리다이렉션</h3>
<p>리소스의 URI가 영구적으로 변경. 원래의 URL 사용하지 않음. 검색 엔진에서도 변경해야함.</p>
<ul>
<li>
<p><strong>301 Moved Permanently</strong>
리다이렉트 시 요청 메소드가 GET으로 변하고, 본문(메시지 바디)이 제거될 수도 있음.</p>
</li>
<li>
<p><strong>308 Permanent Redirect</strong>
리다이렉트 시 요청 메소드와 본문을 유지(첫 요청과 동일하게 유지).</p>
</li>
</ul>
<h3 id="일시적-리다이렉션">일시적 리다이렉션</h3>
<p>리소스의 URI가 일시적으로 변경. 검색 엔진에서 절대 변경되면 안됨.</p>
<ul>
<li>
<p><strong>302 Found</strong>
리다이렉트 시 요청 메소드가 GET으로 변하고, 본문이 제거될 수도 있음.</p>
</li>
<li>
<p><strong>307 Temporary Redirect</strong>
리다이렉트 시 요청 메소드와 본문 유지(절대 요청 메소드를 변경하면 안된다).</p>
</li>
<li>
<p><strong>303 See Other</strong>
리다이렉트 시 요청 메소드가 GET으로 변경</p>
</li>
<li>
<p><strong>304 Not Modified</strong>
캐시를 목적으로 사용. 클라이언트에게 리소스가 수정되지 않았음을 알림(캐시 사용 허가).</p>
</li>
</ul>
<h3 id="prg--postredirectget">PRG : POST/Redirect/GET</h3>
<p>POST로 요청 후에 새로 고침으로 인한 중복 요청 방지. POST 후에 결과 화면(응답)을 GET 메소드로 리다이렉트.</p>
<h2 id="4xx---client-error" class="heading">4XX - Client Error</h2>
<p>오류의 원인이 클라이언트에 있어 서버가 전혀 요청을 수행할 수 없음. 같은 요청을 다시 보내도 서버에선 계속 같은 실패 응답을 보냄.</p>
<ul>
<li>
<p><strong>400 Bad Request</strong>
클라이언트가 잘못된 요청을 보냄. 클라이언트가 요청 내용을 검토해야함. HTTP API 스펙이 맞지 않거나, 요청 파라미터가 잘못됨.</p>
</li>
<li>
<p><strong>401 Unauthorized</strong>
클라이언트가 접근하려는 리소스에 대한 인증 필요. Authentication되지 않음. WWW-Authenticate 헤더와 함께 인증 방법 설명
Authentication (본인 인증), Authorization (권한 확인)</p>
</li>
<li>
<p><strong>403 Forbidden</strong>
서버가 클라이언트의 요청을 이해했지만 승인 거부. 권한 부족. (일반 사용자가 어드민 리소스 접근)</p>
</li>
<li>
<p><strong>404 Not Found</strong>
요청 리소스가 서버에 없음. 또는 클라이언트에게 완전히 리소스의 존재 확인을 막을 때.</p>
</li>
</ul>
<h2 id="5xx---server-error" class="heading">5XX - Server Error</h2>
<p>서버 문제로 오류 발생. 재시도 시 성공 가능성 있음. 서버의 문제일 때만 5XX대 오류 반환해야함.</p>
<ul>
<li>
<p><strong>500 Internal Server Error</strong>
서버 문제로 오류 발생, 애매하면 500.</p>
</li>
<li>
<p><strong>503 Service Unavailable</strong>
서비스 이용 불가. 서버가 일시적인 과부하 또는 예정 작업으로 요청 처리 불가. Retry-After 헤더 필드로 복구 예상 시간 반환 가능.</p>
</li>
</ul>]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[인터넷 네트워크]]></title>
    <link>https://blog.coderoad.kr/internet</link>
    <pubDate>2023-01-18</pubDate>
    <guid isPermaLink="false">https://blog.coderoad.kr/internet</guid>
    <description>
    <![CDATA[웹 개발을 위한 인터넷 네트워크 기본 지식]]>
    </description>
    <content:encoded>
      <![CDATA[<p><strong>본 문서는 인프런에서 수강할 수 있는 <a href="https://www.inflearn.com/course/http-%EC%9B%B9-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC" target="_blank" rel="noopener noreferer">모든 개발자를 위한 HTTP 웹 기본 지식</a>을 수강한 후, 공부한 내용을 정리한 문서입니다. 본 문서의 모든 저작권은 해당 강의의 저자이신 <a href="https://inflearn.com/users/@yh" target="_blank" rel="noopener noreferer">김영한</a> 우아한형제들 기술이사님께 있습니다.</strong></p>
<h2 id="인터넷" class="heading">인터넷!</h2>
<h2 id="ip" class="heading">IP</h2>
<h2 id="tcp와-udp" class="heading">TCP와 UDP</h2>
<h2 id="port" class="heading">PORT</h2>
<h2 id="dns" class="heading">DNS</h2>]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[URI]]></title>
    <link>https://blog.coderoad.kr/uri</link>
    <pubDate>2023-01-18</pubDate>
    <guid isPermaLink="false">https://blog.coderoad.kr/uri</guid>
    <description>
    <![CDATA[통합 자원 식별자에 대해]]>
    </description>
    <content:encoded>
      <![CDATA[<p><strong>본 문서는 인프런에서 수강할 수 있는 <a href="https://www.inflearn.com/course/http-%EC%9B%B9-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC" target="_blank" rel="noopener noreferer">모든 개발자를 위한 HTTP 웹 기본 지식</a>을 수강한 후, 공부한 내용을 정리한 문서입니다. 본 문서의 모든 저작권은 해당 강의의 저자이신 <a href="https://inflearn.com/users/@yh" target="_blank" rel="noopener noreferer">김영한</a> 우아한형제들 기술이사님께 있습니다.</strong></p>
<h2 id="uri-url-urn" class="heading">URI, URL, URN</h2>
<h2 id="url-살펴보기" class="heading">URL 살펴보기</h2>]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[Java 웹 기술의 역사]]></title>
    <link>https://blog.coderoad.kr/backendhistory</link>
    <pubDate>2023-01-17</pubDate>
    <guid isPermaLink="false">https://blog.coderoad.kr/backendhistory</guid>
    <description>
    <![CDATA[Servlet의 등장부터 Spring Boot까지]]>
    </description>
    <content:encoded>
      <![CDATA[<p><strong>본 문서는 인프런에서 수강할 수 있는 <a href="https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-mvc-1/dashboard" target="_blank" rel="noopener noreferer">스프링 MVC 1편 - 백엔드 웹 개발 핵심 기술</a>을 수강한 후, 공부한 내용을 정리한 문서입니다. 본 문서의 모든 저작권은 해당 강의의 저자이신 <a href="https://inflearn.com/users/@yh" target="_blank" rel="noopener noreferer">김영한</a> 우아한형제들 기술이사님께 있습니다.</strong></p>
<h2 id="과거의-기술들" class="heading">과거의 기술들</h2>
<h2 id="어노테이션-기반-spring-mvc" class="heading">어노테이션 기반 Spring MVC</h2>
<h2 id="spring-boot의-등장" class="heading">Spring Boot의 등장</h2>
<h2 id="spring-webflux" class="heading">Spring WebFlux?</h2>
<h2 id="java-view-template의-역사" class="heading">Java View Template의 역사</h2>]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[WAS와 멀티 스레딩]]></title>
    <link>https://blog.coderoad.kr/multithread</link>
    <pubDate>2023-01-17</pubDate>
    <guid isPermaLink="false">https://blog.coderoad.kr/multithread</guid>
    <description>
    <![CDATA[동시 요청 처리를 위한 스레드 풀]]>
    </description>
    <content:encoded>
      <![CDATA[<p><strong>본 문서는 인프런에서 수강할 수 있는 <a href="https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-mvc-1/dashboard" target="_blank" rel="noopener noreferer">스프링 MVC 1편 - 백엔드 웹 개발 핵심 기술</a>을 수강한 후, 공부한 내용을 정리한 문서입니다. 본 문서의 모든 저작권은 해당 강의의 저자이신 <a href="https://inflearn.com/users/@yh" target="_blank" rel="noopener noreferer">김영한</a> 우아한형제들 기술이사님께 있습니다.</strong></p>
<h2 id="thread" class="heading">Thread</h2>
<h2 id="was와-멀티-스레드" class="heading">WAS와 멀티 스레드</h2>
<h2 id="마치-싱글-스레드-같이" class="heading">마치 싱글 스레드 같이</h2>
<h2 id="주의해야할-점" class="heading">주의해야할 점!</h2>]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[Servlet이란?]]></title>
    <link>https://blog.coderoad.kr/servlet</link>
    <pubDate>2023-01-17</pubDate>
    <guid isPermaLink="false">https://blog.coderoad.kr/servlet</guid>
    <description>
    <![CDATA[Java와 Servlet]]>
    </description>
    <content:encoded>
      <![CDATA[<p><strong>본 문서는 인프런에서 수강할 수 있는 <a href="https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-mvc-1/dashboard" target="_blank" rel="noopener noreferer">스프링 MVC 1편 - 백엔드 웹 개발 핵심 기술</a>을 수강한 후, 공부한 내용을 정리한 문서입니다. 본 문서의 모든 저작권은 해당 강의의 저자이신 <a href="https://inflearn.com/users/@yh" target="_blank" rel="noopener noreferer">김영한</a> 우아한형제들 기술이사님께 있습니다.</strong></p>
<h2 id="servlet" class="heading">Servlet?</h2>
<h2 id="복잡하고-낭비되는-작업으로부터의-해방" class="heading">복잡하고 낭비되는 작업으로부터의 해방</h2>
<h2 id="servlet-컨테이너" class="heading">Servlet 컨테이너</h2>
<h2 id="싱글톤-패턴" class="heading">싱글톤 패턴</h2>]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[Web 서버와 WAS]]></title>
    <link>https://blog.coderoad.kr/webwas</link>
    <pubDate>2023-01-17</pubDate>
    <guid isPermaLink="false">https://blog.coderoad.kr/webwas</guid>
    <description>
    <![CDATA[닮은 듯 다른, 웹 시스템의 두 서버]]>
    </description>
    <content:encoded>
      <![CDATA[<p><strong>본 문서는 인프런에서 수강할 수 있는 <a href="https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-mvc-1/dashboard" target="_blank" rel="noopener noreferer">스프링 MVC 1편 - 백엔드 웹 개발 핵심 기술</a>을 수강한 후, 공부한 내용을 정리한 문서입니다. 본 문서의 모든 저작권은 해당 강의의 저자이신 <a href="https://inflearn.com/users/@yh" target="_blank" rel="noopener noreferer">김영한</a> 우아한형제들 기술이사님께 있습니다.</strong></p>
<h2 id="web-server-was" class="heading">Web Server? WAS?</h2>
<h2 id="web-server" class="heading">Web Server</h2>
<h2 id="web-application-server" class="heading">Web Application Server</h2>
<h2 id="둘은-왜-분리되어야-하는가" class="heading">둘은 왜 분리되어야 하는가?</h2>
<h2 id="was만-있어도-되는-경우" class="heading">WAS만 있어도 되는 경우</h2>]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[빈 스코프]]></title>
    <link>https://blog.coderoad.kr/beanscope</link>
    <pubDate>2023-01-15</pubDate>
    <guid isPermaLink="false">https://blog.coderoad.kr/beanscope</guid>
    <description>
    <![CDATA[Spring 빈의 스코프]]>
    </description>
    <content:encoded>
      <![CDATA[<p><strong>본 문서는 인프런에서 수강할 수 있는 <a href="https://inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8" target="_blank" rel="noopener noreferer">스프링 핵심 원리 - 기본편</a>을 수강한 후, 공부한 내용을 정리한 문서입니다. 본 문서의 모든 저작권은 해당 강의의 저자이신 <a href="https://inflearn.com/users/@yh" target="_blank" rel="noopener noreferer">김영한</a> 우아한형제들 기술이사님께 있습니다.</strong></p>
<p>문서 공사중입니다.</p>
<h3 id="빈-스코프">빈 스코프?</h3>
<p>빈의 생명주기가 적용되는 범위, 변수의 스코프에서의 그 스코프 맞다.</p>
<h3 id="프로토타입-스코프">프로토타입 스코프</h3>
<p>Spring 빈의 기본 스코프는 싱글톤이다. 싱글톤 스코프는 객체가 생성된 다음 스프링 컨테이너가 종료될 때까지 살아있지만, 프로토타입 스코프로 지정하면 한번 생성되서 의존관계만 주입해주고 스프링 컨테이너에서도 지워진다.</p>
<h3 id="프로토타입-스코프의-문제와-해결">프로토타입 스코프의 문제와 해결</h3>
<p>프로토타입 스코프를 싱글톤 스코프 객체 안의 필드에 저장하게 되면 프로토타입의 특징을 잃는다. 생성할 때마다 매번 새로운 객체가 들어오는 것을 기대하지만 이미 필드에 저장된 객체를 불러오기 때문에 같은 객체를 참조하게 된다. 이것을 해결하는 방법이 Provider.</p>
<h3 id="웹-스코프">웹 스코프</h3>
<p>웹 스코프는 웹 환경에서만 동작한다. 웹 스코프는 프로토타입과 다르게 스프링이 해당 스코프의 종료 시점까지 관리한다. (생성은 웹 요청 시에 생성된다.) 문제는 웹 요청 시에 빈이 생성되기 때문에 컨테이너가 올라가고 로직이 실행될 때 없는 빈을 참조하기 때문에 예외가 발생한다.</p>
<h3 id="스코프와-provider">스코프와 Provider</h3>
<p>이런 예외를 해결하기 위해서 첫 번째 방법으로 Provider가 있다. DL(Dependency Lookup)을 사용하는 Provider는 getObjec()를 호출하는 시점까지 빈의 생성을 지연한다.</p>
<h3 id="스코프와-프록시">스코프와 프록시</h3>
<p>스코프 애노티에션에 proxyMode 어트리뷰트를 활용해 프록시 방식을 적용할 수 있다. Provider 사용 시와는 다르게 싱글톤 스코프와 같은 코드로도 빈의 생성이 정상적으로 이루어진다. 이것이 가능한 이유는 CGLIB 라이브러리를 활용해 내가 작성한 클래스(빈)을 상속한 가짜 "프록시" 객체를 만들어서 대신 주입하고 HTTP Request가 왔을 때 가짜 "프록시" 객체가 내부 로직(위임)을 통해 진짜 객체(빈)의 로직을 실행한다. 이는 다형성의 장점이다.(클라이언트는 객체가 가짜 프록시 객체인지 진짜 스프링 빈인지 알 필요가 없다.) 꼭 웹 스코프가 아니더라도 프록시는 사용 가능하다.</p>]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[컴포넌트 스캔]]></title>
    <link>https://blog.coderoad.kr/componentscan</link>
    <pubDate>2023-01-15</pubDate>
    <guid isPermaLink="false">https://blog.coderoad.kr/componentscan</guid>
    <description>
    <![CDATA[Spring 빈을 더 현명하게 관리하기]]>
    </description>
    <content:encoded>
      <![CDATA[<p><strong>본 문서는 인프런에서 수강할 수 있는 <a href="https://inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8" target="_blank" rel="noopener noreferer">스프링 핵심 원리 - 기본편</a>을 수강한 후, 공부한 내용을 정리한 문서입니다. 본 문서의 모든 저작권은 해당 강의의 저자이신 <a href="https://inflearn.com/users/@yh" target="_blank" rel="noopener noreferer">김영한</a> 우아한형제들 기술이사님께 있습니다.</strong></p>
<h2 id="컴포넌트-스캔" class="heading">컴포넌트 스캔?</h2>
<p>우리는 지금까지 Spring 빈을 Spring 컨테이너에 등록할 때, 구성자(Java 설정 클래스)에서 <code>@Bean</code> 어노테이션이나 XML 파일을 통해 등록했습니다. (자세한 설명은 <a href="https://blog.coderoad.kr/iocanddi" target="_blank" rel="noopener noreferer">IoC와 DI</a>와 <a href="https://blog.coderoad.kr/containerandbean" target="_blank" rel="noopener noreferer">Spring 컨테이너와 Bean</a> 문서 참고!) 아주 간단한 Spring 애플리케이션이라면 이 방식도 괜찮지만, 규모가 큰 서비스에서 하나하나 직접 빈을 등록하는 것은 여러 문제점이 있습니다. 개발자가 직접 설정 정보를 작성해야하기 때문에 설정 클래스의 코드가 지나치게 길어지고, 등록해야할 빈을 실수로 빼먹기도 하는 문제가 발생합니다. 더군다나 이런 단순 반복 작업을 개발자가 하게 되는 것 자체가 너무 비효율적입니다.</p>
<p>다행히 Spring이 개발자가 사소한 일에 너무 많은 시간을 쏟지 않도록 자동으로 Spring 빈을 등록해주는 <strong>컴포넌트 스캔</strong>이라는 기능을 제공합니다. 기존에 <code>@Configuration</code> 어노테이션을 붙여 설정 클래스로 지정한 클래스의 빈 등록 코드를 모두 지우고 <code>@ComponentScan</code>이라는 어노테이션을 붙여주면 빈 생성과 등록을 모두 자동으로 합니다!</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token comment">//설정 클래스가 이제 스스로 빈을 생성하고 등록합니다!</span>
</span><span class="code-line"><span class="token annotation punctuation">@Configuration</span>
</span><span class="code-line"><span class="token annotation punctuation">@ComponentScan</span>
</span><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AppConfig</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token comment">//@ComponentScan이 없던 코드와 다르게 클래스 내부가 비어도 괜찮습니다.</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p>이렇게 어노테이션 하나만 추가하고 간단하게 자동 등록 기능이 동작하면 정말 좋겠지만, 그렇지 않습니다. 이 방식을 사용하려면 2가지 선행 조건을 충족해야합니다. <strong>Spring 빈으로 등록하고자 하는 Java 클래스에 <code>@Component</code> 어노테이션</strong>을 붙여줘야 하며, 의존관계를 명시한 코드가 설정 클래스에서 없어졌으니 <strong><code>@Component</code> 어노테이션을 붙인 클래스에서 직접 의존관계 주입</strong>을 해줘야합니다. 그래도 크게 걱정할 필요 없습니다. Spring은 <code>@AutoWired</code> 어노테이션을 통해 의존관계 자동 주입 기능도 제공합니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token annotation punctuation">@Component</span> <span class="token comment">//이제 이 Java 클래스는 Spring 빈입니다.</span>
</span><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MemberServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">MemberService</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">MemberRepository</span> memberRepository<span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token annotation punctuation">@Autowired</span> <span class="token comment">//Spring이 MemberRepository에 대한 의존관계를 자동으로 주입해줍니다.</span>
</span><span class="code-line">    <span class="token keyword">public</span> <span class="token class-name">MemberServiceImpl</span><span class="token punctuation">(</span><span class="token class-name">MemberRepository</span> memberRepository<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">        <span class="token keyword">this</span><span class="token punctuation">.</span>memberRepository <span class="token operator">=</span> memberRepository<span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token punctuation">}</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p>이 기능들의 원리는 의외로 간단한데, <code>@ComponentScan</code>은 <code>@Component</code> 어노테이션이 붙은 모든 클래스를 Spring 빈으로 등록합니다. 이때 빈 이름은 <code>@Bean</code> 방식과 유사하게 클래스명을 사용하되 맨 앞글자만 소문자로 등록합니다. (<code>@Bean</code> 방식은 메소드 명을 이름으로 사용했습니다.) 또한, <code>@Component("이름")</code>과 같이 빈 이름을 직접 지어줄 수도 있습니다.</p>
<p>이렇게 등록된 빈들은 <code>@Autowired</code> 어노테이션이 붙어 있는 생성자나 필드를 만나면 Spring 컨테이너에 의해 조회되고 주입됩니다. 이때, 컨테이너가 사용하는 기본 조회 방식은 타입으로 찾는 방식입니다. <code>getBean(타입.class)</code>와 동일하다고 보면 됩니다.</p>
<h2 id="컴포넌트-스캔-범위-설정" class="heading">컴포넌트 스캔 범위 설정</h2>
<p><code>@ComponentScan</code>을 사용해 빈을 등록하는 방식은 <code>@ComponentScan</code> 어노테이션이 붙은 클래스가 위치한 패키지와 하위 패키지의 모든 Java 클래스를 하나씩 검사하는 방식입니다. 따라서 명확하게 Spring 빈이 아닌 클래스들은 스캔 범위에서 제외해주면 성능 향상에 도움이 됩니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">(</span>
</span><span class="code-line">    <span class="token comment">//컴포넌트 스캔을 시작할 위치를 지정합니다.</span>
</span><span class="code-line">    <span class="token comment">//code.road를 포함해 모든 하위 패키지를 스캔합니다.</span>
</span><span class="code-line">    <span class="token comment">//시작 위치를 여러개 설정할 수도 있습니다.</span>
</span><span class="code-line">    basePackages <span class="token operator">=</span> <span class="token string">"code.road"</span><span class="token punctuation">,</span>
</span><span class="code-line"><span class="token punctuation">)</span>
</span></code></pre>
<p>물론 이렇게 직접 지정할 수도 있지만, 이 글을 작성하게된 강의의 저자이신 김영한님께서 가장 권장하시는 방법은 <strong>시작 위치를 따로 지정하지 않고 Java 설정 클래스(<code>@ComponentScan</code>이 붙은 클래스)를 프로젝트의 최상단에 두는 방법</strong>이었습니다. Spring Boot도 기본적으로 이 방식을 사용하고, 설정 클래스는 프로젝트를 대표하는 정보이기 때문에 최상단에 두는 것이 좋다라고 하셨기 때문에, 저도 프로젝트를 진행하면서 따로 스캔 시작 위치를 지정하지는 않고 있습니다.</p>
<p>추가로 컴포넌트 스캔 기본 대상은 <code>@Component</code> 어노테이션 뿐만 아니라 <code>@Controller</code>, <code>@Service</code>, <code>@Repository</code>, <code>@Configuration</code>도 컴포넌트 스캔 기능의 스캔 대상입니다. 우리가 Spring Web MVC를 공부하고 애플리케이션을 만들면서 자주 사용하게 될 어노테이션입니다. 위 어노테이션을 사용하면 우리가 크게 신경쓰지 않아도 Spring 빈으로 자동 등록됩니다.</p>
<h2 id="필터를-사용해보자" class="heading">필터를 사용해보자</h2>
<p>필터를 통해 컴포넌트 스캔 대상에 추가하거나 제외할 수 있습니다. 예시 코드를 통해 간단하게 필터 사용법을 알아보겠습니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">(</span>
</span><span class="code-line">    <span class="token comment">//BeanA는 스캔 대상에 추가되고</span>
</span><span class="code-line">    includeFilters <span class="token operator">=</span> <span class="token annotation punctuation">@Filter</span><span class="token punctuation">(</span>type <span class="token operator">=</span> <span class="token class-name">FilterType</span><span class="token punctuation">.</span>ASSIGNABLE_TYPE<span class="token punctuation">,</span> classes <span class="token operator">=</span> <span class="token class-name">BeanA</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
</span><span class="code-line">    <span class="token comment">//BeanB는 스캔 대상에서 제외됩니다.</span>
</span><span class="code-line">    excludeFilters <span class="token operator">=</span> <span class="token annotation punctuation">@Filter</span><span class="token punctuation">(</span>type <span class="token operator">=</span> <span class="token class-name">FilterType</span><span class="token punctuation">.</span>ASSIGNABLE_TYPE<span class="token punctuation">,</span> classes <span class="token operator">=</span> <span class="token class-name">BeanB</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
</span><span class="code-line"><span class="token punctuation">)</span>
</span></code></pre>
<p><code>FilterType</code>에 올 수 있는 옵션에는 5가지가 있습니다.</p>
<ul>
<li>ANNOTATION : 기본값으로 어노테이션을 인식해 필터링합니다.</li>
<li>ASSIGNABLE_TYPE : 지정한 타입과 자식 타입을 필터링합니다.</li>
<li>ASPECTJ : AspectJ 패턴을 통해 필터링합니다.</li>
<li>REGEX : 정규 표현식을 통해 필터링합니다.</li>
<li>CUSTOM : <code>TypeFilter</code>라는 인터페이스를 구현해서 필터링합니다.</li>
</ul>
<p>그러나, 스캔 대상에 추가하는 기능은 <code>@Component</code>나 <code>@Service</code> 같은 스캔 대상 어노테이션을 붙여주는 것으로 충분해 거의 사용하지 않습니다. 거기다 스캔 대상에서 제외하는 기능도 사용할 일이 많지 않으며, Spring Boot가 기본적으로 컴포넌트 스캔 기능을 제공하기 때문에, 필터를 사용하지 않는 편이 낫습니다. 그래서 컴포넌트 스캔에 필터라는 기능도 존재한다고 알고 넘어가면 될 것 같습니다.</p>
<h2 id="중복과-충돌" class="heading">중복과 충돌</h2>
<p>컴포넌트 스캔을 이용해 Spring 빈을 <strong>자동</strong> 등록하다보면 빈 이름이 중복되는 문제가 발생할 수 있습니다. 이때, <strong>자동으로 등록된 빈들은</strong> 개발자가 <strong>수동으로 등록한 빈보다 우선 순위가 떨어집니다.</strong> 기존의 Spring 프레임워크는 수동 등록한 빈이 자동으로 등록된 빈을 덮어씌워버리기 때문에 의도하지 않았다면 정말 잡아내기 힘든 버그가 탄생하게 됩니다.</p>
<p>그래서인지 최근 Spring Boot에서는 수동 등록 빈과 자동 등록 빈의 이름 중복으로 등록 과정에서 충돌이 발생하면 덮어씌우지 않고 오류를 발생시킵니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token class-name">Consider</span> renaming one of the beans or enabling overriding by setting spring<span class="token punctuation">.</span>main<span class="token punctuation">.</span>allow<span class="token operator">-</span>bean<span class="token operator">-</span>definition<span class="token operator">-</span>overriding<span class="token operator">=</span><span class="token boolean">true</span>
</span></code></pre>
<p>물론 자동 등록 빈 사이에서도 빈 이름 중복이 발생하면 오류가 발생합니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token class-name">Caused</span> by<span class="token operator">:</span> <span class="token class-name"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span>ConflictingBeanDefinitionException</span><span class="token operator">:</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</span></code></pre>
<p>사실 클래스 이름을 중복해서 작성하지 않는 한, 자주 볼 일 없는 오류지만 주의해야합니다.</p>]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[Spring 컨테이너와 빈]]></title>
    <link>https://blog.coderoad.kr/containerandbean</link>
    <pubDate>2023-01-15</pubDate>
    <guid isPermaLink="false">https://blog.coderoad.kr/containerandbean</guid>
    <description>
    <![CDATA[컨테이너와 빈의 개념 정리]]>
    </description>
    <content:encoded>
      <![CDATA[<p><strong>본 문서는 인프런에서 수강할 수 있는 <a href="https://inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8" target="_blank" rel="noopener noreferer">스프링 핵심 원리 - 기본편</a>을 수강한 후, 공부한 내용을 정리한 문서입니다. 본 문서의 모든 저작권은 해당 강의의 저자이신 <a href="https://inflearn.com/users/@yh" target="_blank" rel="noopener noreferer">김영한</a> 우아한형제들 기술이사님께 있습니다.</strong></p>
<h2 id="spring-컨테이너" class="heading">Spring 컨테이너</h2>
<p>Spring은 <strong><a href="https://blog.coderoad.kr/iocanddi" target="_blank" rel="noopener noreferer">IoC(제어의 역전)</a></strong> 개념을 통해 탄생한 구성자, <strong>컨테이너</strong>로 프로그램의 흐름을 제어합니다. Spring에서의 컨테이너를 <strong>Spring 컨테이너</strong>라고 부릅니다. Spring 컨테이너는 <code>ApplicationContext</code> 인터페이스를 통해 생성하는데, 이 <code>ApplicationContext</code> 자체를 Spring 컨테이너라고 하기도 합니다. 본격적으로 Spring을 활용하기 위해선 이 Spring 컨테이너를 생성해야합니다. 방법은 매우 간단합니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token comment">//'AppConfig.class'는 프로그래머가 작성한 구성 정보를 담은 Java 설정 클래스입니다.</span>
</span><span class="code-line"><span class="token class-name">ApplicationContext</span> applicationContext <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span><span class="token class-name">AppConfig</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></code></pre>
<p>위 코드가 바로 Spring 컨테이너를 생성하는 코드입니다. <code>AnnotationConfigApplicationContext</code>는 <code>ApplicationContext</code> 인터페이스의 구현체로, <code>AppConfig</code>와 같이 구성 정보를 담은 <strong>'어노테이션'</strong> 기반의 <strong>'Java 설정 클래스'</strong>(구성자)를 통해 Spring 컨테이너를 생성합니다. Spring 컨테이너를 생성하는 방식은 다양합니다. 그 중, 대표적인 두 가지가 위의 코드와 같이 어노테이션 기반의 Java 설정 클래스를 통한 생성법과 XML을 기반으로한 생성법입니다. 최근에는 주로 Java 설정 클래스를 통해 Spring 컨테이너를 생성합니다.</p>
<p>우리는 Spring 컨테이너를 생성할 때 Java 설정 클래스(이제 설정 클래스라 작성하겠습니다.)를 활용한다는 것을 알았습니다. 그런데 Spring이 프로그램의 수많은 클래스들 중에 설정 클래스가 무엇인지 어떻게 알 수 있을까요? 또, 어노테이션을 기반으로 한다는데, 어노테이션은 무엇일까요? 당연히 모든 클래스가 설정 클래스가 되는 것은 아닙니다. 프로그램의 구성 정보(DI 정보)를 담고 있다고 해서 자동으로 설정 클래스가 되는 것도 아닙니다. 프로그래머가 설정 클래스로 사용하고자 하는 클래스를 <strong>어노테이션</strong>을 통해 직접 명시해줘야 Spring이 이를 확인하고 컨테이너를 생성하는데 설정 클래스로 등록된 클래스를 활용합니다.</p>
<p>어노테이션은 Java의 문법으로 메타데이터의 일종입니다. 쉽게 설명하자면 해당 코드가 무엇인지 설명해주는 역할을 가집니다. Spring은 여러가지 자체적인 어노테이션들을 가지고 있고, 프로그래머가 이를 사용해 Spring의 기술을 활용할 수 있도록 합니다. 그 중 가장 기초가 되는 것이 바로 순수한 클래스를 설정 클래스로 만들어주는 <code>@Configuration</code> 어노테이션입니다. 클래스 선언문 앞에 해당 어노테이션을 붙혀주면 Spring은 해당 클래스를 자동으로 설정 클래스로 인식하고 그에 맞는 동작들을 수행합니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token comment">//이제 AppConfig 클래스는 Spring에 의해 설정 클래스로 관리됩니다.</span>
</span><span class="code-line"><span class="token annotation punctuation">@Configuration</span>
</span><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AppConfig</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p>이렇게 <code>@Configuration</code> 어노테이션을 통해 설정 클래스로 등록된 <code>AppConfig</code> 클래스는 Spring 컨테이너 생성 시 프로그램의 구성 정보로 활용됩니다. Spring은 <code>AppConfig</code>에 적혀진 대로 객체를 생성하고, 관리하며, 의존관계를 주입합니다. 다시 말해, <code>@Configuration</code> 어노테이션에 의해 설정 클래스로 등록된 <code>AppConfig</code> 클래스는, IoC를 통해 프로그램의 제어권을 가지게 된 Spring 컨테이너에게 해당 프로그램의 설명서 역할을 하는 것입니다. <code>AnnotationConfigApplicationContext</code> 클래스를 기반으로 Spring 컨테이너를 생성하기 위해선 <code>AppConfig</code>와 같은 설정 클래스가 필수입니다.</p>
<h2 id="spring-빈" class="heading">Spring 빈</h2>
<p>Spring 컨테이너는 생성될 때, 구성 정보로 등록한 설정 클래스(<code>@Configuration</code>이 붙은 클래스)에 작성되어 있는 객체들을 모두 생성해서 자기 자신에 등록합니다. 이때, 컨테이너에 등록된 객체들을 **빈(Bean)**이라고 합니다.</p>
<blockquote>
<p>@Configuration 어노테이션 뿐만 아니라 @Component, @Controller 같은 어노테이션으로도 컨테이너에 빈 등록이 가능합니다! 각각 어노테이션들은 다른 포스트에서 설명하도록 하겠습니다.</p>
</blockquote>
<p>물론 이 방식을 사용할 때, 설정 클래스에 있는 모든 요소들이 빈으로 등록되는 것은 아닙니다. <code>@Bean</code> 어노테이션을 붙힌 메소드가 반환하는 객체들이 등록되는 것입니다. 빈은 정확히는 컨테이너 내부의 빈 저장소에 등록되는데, 빈을 불러올 수 있는 키(key) 역할을 하는 **'빈 이름'**과 실제 객체인 **'빈 객체'**가 같이 등록됩니다. 빈 이름은 따로 지정해주지 않으면 <code>@Bean</code>을 붙혀 Spring 빈으로 지정한 메소드 이름으로 자동 저장됩니다. Spring 빈으로 등록하는 법은 다음과 같습니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token comment">//컨테이너 생성에 활용할 구성 정보를 가진 설정 클래스입니다.</span>
</span><span class="code-line"><span class="token annotation punctuation">@Configuration</span>
</span><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AppConfig</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token comment">//Spring 빈으로 등록되었습니다.</span>
</span><span class="code-line">    <span class="token comment">//빈 이름 : memberRepository</span>
</span><span class="code-line">    <span class="token comment">//빈 객체 : MemoryMemberRepository 클래스의 인스턴스</span>
</span><span class="code-line">    <span class="token annotation punctuation">@Bean</span>
</span><span class="code-line">    <span class="token keyword">public</span> <span class="token class-name">MemberRepository</span> <span class="token function">memberRepository</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">        <span class="token comment">//IoC에 의해 해당 객체는 이 곳에서만 생성되고 의존관계가 주입됩니다.</span>
</span><span class="code-line">        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MemoryMemberRepository</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token punctuation">}</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token comment">//빈 이름을 직접 등록할 수도 있습니다.</span>
</span><span class="code-line">    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">"memberServiceBean"</span><span class="token punctuation">)</span>
</span><span class="code-line">    <span class="token keyword">public</span> <span class="token class-name">MemberService</span> <span class="token function">memberService</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MemberServiceImpl</span><span class="token punctuation">(</span><span class="token function">memberRepository</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token punctuation">}</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p>빈 이름을 직접 등록할 때 꼭 주의해야할 점은 이름이 중복되면 안된다는 것입니다. 서로 다른 두 빈이 같은 이름을 가지게 될 경우, 컨테이너에서 다른 하나의 빈은 무시되거나 아예 덮어씌워질 수도 있고 설정에 따라 오류가 발생할 수도 있습니다.</p>
<p>컨테이너의 역할인 생성과 관리(빈을 생성하고 컨테이너에 등록)까지 알아봤습니다. 다음은 가장 중요하다고 할 수 있는 컨테이너의 DI, 의존관계 주입 방식에 대해 알아보겠습니다. Spring은 빈을 생성하고 의존관계를 주입하는 단계가 나뉘어져 있습니다. 위의 코드로 설명하면, <code>@Bean</code> 어노테이션을 확인한 Spring은 그 아래에 있는 메소드들의 이름을 빈 이름으로, 그 메소드가 반환하는 객체들을 빈 객체로 Spring 컨테이너에 등록합니다. 이후, 메소드 안에 작성되어 있는 의존관계 정보(MemberServiceImpl 클래스는 memberRepository 빈에 의존합니다.)를 확인하고 그 의존관계를 주입해줍니다. 그런데, 위 코드와 같이 Java 설정 클래스를 통해 빈을 등록하면 생성자를 호출함과 동시에 의존관계도 주입됩니다. 즉, 단계가 나누어지지 않는다는 말입니다. 자세한 내용은 의존관계 자동 주입 파트에서 설명하겠습니다. 지금 가지고 가야할 정보는 설정 클래스를 활용해서 만들어진 Spring 빈은 생성될 때 의존관계가 자동으로 주입된다는 것입니다.</p>
<h2 id="컨테이너의-빈-조회하기" class="heading">컨테이너의 빈 조회하기</h2>
<p>이제 Spring 컨테이너를 생성하고 Spring 빈을 등록하는 방법까지 알아봤습니다. 이제 빈이 잘 등록되어 있는지 확인하는(혹은 빈을 활용하고자 객체를 불러오는) 방법에 대해 알아보겠습니다.</p>
<h2 id="모두-조회하기" class="heading">모두 조회하기</h2>
<p>먼저 Spring에 등록된 모든 빈 정보를 확인할 수 있는 방법입니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token comment">//설정 클래스 AppConfig를 구성 정보로 하는 어노테이션 기반 Spring 컨테이너 생성</span>
</span><span class="code-line"><span class="token class-name">AnnotationConfigApplicationContext</span> ac <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span><span class="token class-name">AppConfig</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token keyword">void</span> <span class="token function">findAllBean</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token comment">//빈 이름들을 모두 받아온 후</span>
</span><span class="code-line">    <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> beanDefinitionNames <span class="token operator">=</span> ac<span class="token punctuation">.</span><span class="token function">getBeanDefinitionNames</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token comment">//해당 빈 이름을 가진 빈 객체를 받아와서</span>
</span><span class="code-line">    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">String</span> beanDefinitionName <span class="token operator">:</span> beanDefinitionNames<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">        <span class="token class-name">Object</span> bean <span class="token operator">=</span> ac<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>beanDefinitionName<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">        <span class="token comment">//출력</span>
</span><span class="code-line">        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"name = "</span> <span class="token operator">+</span> beanDefinitionName <span class="token operator">+</span> <span class="token string">" object = "</span> <span class="token operator">+</span> bean<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token punctuation">}</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p>현재 Spring에서 관리하고 있는 모든 Spring 빈을 출력하는 방법입니다. <code>ac.getBeanDefinitionNames()</code>을 통해 Spring에 등록된 모든 빈 이름을 조회하고, <code>ac.getBean()</code>으로 조회한 빈 이름을 가진 빈 객체(인스턴스)를 조회합니다. 여기서 <code>ac</code>는 Spring 컨테이너 인스턴스를 담은 변수입니다. 당연히 이 이름은 바뀔 수 있습니다.</p>
<p>그러나 조금 아쉬운 점이 있습니다. 위의 방식을 사용하면 내가 등록한 Spring 빈 뿐만 아니라 Spring 자체적으로 등록한 Spring 빈들도 모두 조회됩니다. 내가 직접 등록한 빈들만 확인하려면 어떻게 해야할까요? 방법은 다음과 같습니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token comment">//설정 클래스 AppConfig를 구성 정보로 하는 어노테이션 기반 Spring 컨테이너 생성</span>
</span><span class="code-line"><span class="token class-name">AnnotationConfigApplicationContext</span> ac <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span><span class="token class-name">AppConfig</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token keyword">void</span> <span class="token function">findApplicationBean</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token comment">//빈 이름들을 모두 받아온 후</span>
</span><span class="code-line">    <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> beanDefinitionNames <span class="token operator">=</span> ac<span class="token punctuation">.</span><span class="token function">getBeanDefinitionNames</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token comment">//해당 빈 이름을 가진 빈 객체를 받아와서</span>
</span><span class="code-line">    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">String</span> beanDefinitionName <span class="token operator">:</span> beanDefinitionNames<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">        <span class="token class-name">BeanDefinition</span> beanDefinition <span class="token operator">=</span> ac<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>beanDefinitionName<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">        <span class="token comment">//해당 빈 이름을 가진 빈 객체의 속성을 확인한 후</span>
</span><span class="code-line">        <span class="token comment">//직접 등록한 애플리케이션 빈일 경우</span>
</span><span class="code-line">        <span class="token keyword">if</span> <span class="token punctuation">(</span>beanDefinition<span class="token punctuation">.</span><span class="token function">getRole</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token class-name">BeanDefinition</span><span class="token punctuation">.</span>ROLE_APPLICATION<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">            <span class="token class-name">Object</span> bean <span class="token operator">=</span> ac<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>beanDefinitionName<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">            <span class="token comment">//출력</span>
</span><span class="code-line">            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"name = "</span> <span class="token operator">+</span> beanDefinitionName <span class="token operator">+</span> <span class="token string">" object = "</span> <span class="token operator">+</span> bean<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">        <span class="token punctuation">}</span>
</span><span class="code-line">        <span class="token comment">//Role ROLE_APPLICATION: 직접 등록한 애플리케이션 빈</span>
</span><span class="code-line">        <span class="token comment">//Role ROLE_INFRASTRUCTURE: 스프링이 내부에서 사용하는 빈</span>
</span><span class="code-line">    <span class="token punctuation">}</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p>내가 직접 등록한 빈을 **'애플리케이션 빈'**이라고 합니다. Spring 내부의 빈과 애플리케이션 빈은 <code>getRole()</code> 메소드의 결과값으로 구분할 수 있습니다. <code>beanDefinition.getRole()</code>의 결과값은 <code>beanDefinition</code>에 저장해두었던 빈 이름을 가진 빈의 역할입니다. 만약 프로그래머가 직접 등록한 빈이라면 <code>ROLE_APPLICATION</code>이라는 결과값이 나옵니다. 이를 통해 내가 등록한 빈만 확인할 수 있습니다.</p>
<h3 id="기본-방식">기본 방식</h3>
<p>간단하게 정리하자면 Spring 컨테이너에서 빈을 찾는 가장 기본적인 방법은 <code>ac.getBean(빈 이름, 타입)</code>이나 <code>ac.getBean(타입)</code>입니다. 만약 이 방법으로 조회했는데 찾고자하는 Spring 빈이 존재하지 않는다면 다음과 같은 예외가 발생합니다. <code>NoSuchBeanDefinitionException: No bean named '' available</code></p>
<p>기본 방식을 사용할 때 주의해야할 점은 조회 코드의 <code>타입</code> 인자에 구현체 타입을 대입해서 조회하면 유연성이 떨어진다는 것입니다. 프로그래머는 추상화에 의존해야하지 구현체에 의존해서는 안 된다는 <strong>DIP</strong>를 항상 기억합시다!</p>
<h3 id="동일한-타입-존재-시">동일한 타입 존재 시</h3>
<p>만약 동일한 타입의 빈이 여러개 저장되어 있다면 <code>타입</code> 인자만 넣어서 조회할 시 오류가 발생합니다. 이때는 <code>ac.getBean(빈 이름, 타입)</code> 메소드를 사용해서 찾고자하는 빈의 이름을 정확하게 지정해줘야합니다.</p>
<p>혹은, <code>ac.getBeansOfType(타입)</code>을 사용해 인자로 넘겨준 타입의 모든 빈을 조회할 수도 있습니다. 기본적으로 Spring 빈의 이름은 어노테이션을 통해 직접 지정하거나 메소드의 이름으로 자동 지정되기 때문에 여러 빈을 한 번에 조회해도 내가 찾고자하는 빈을 쉽게 찾을 수 있습니다.</p>
<h3 id="상속-관계">상속 관계</h3>
<p>Spring 빈은 Spring 컨테이너가 관리하는 Java 객체이기 때문에 당연히 <strong>상속 관계도 가지고 있습니다.</strong> 부모 타입으로 빈을 조회하면 자식 타입을 가지는 빈들도 모두 조회됩니다. 이러한 특징을 이용해 <code>Object</code> 타입으로 빈을 조회하면 모든 Spring 빈을 조회할 수 있습니다.</p>
<h2 id="beanfactory와-applicationcontext" class="heading">BeanFactory와 ApplicationContext</h2>
<p>우리는 지금까지 <code>ApplicationContext</code>만으로 Spring 컨테이너를 구현했습니다. 그런데 이 <code>ApplicationContext</code>의 상위 인터페이스가 존재합니다. 바로 <code>BeanFactory</code> 인터페이스입니다. <code>BeanFactory</code>는 Spring 컨테이너의 최상위 인터페이스로 Spring 빈을 관리하고 조회하는 역할을 담당합니다. 바로 이 인터페이스에서 <code>getBean()</code>을 제공합니다. 지금까지 우리가 알아본 대부분의 기능들을 이 <code>BeanFactory</code>가 제공합니다.</p>
<p><code>ApplicationContext</code>은 <code>BeanFactory</code>를 상속받아 모든 기능들을 제공합니다. 그렇다면 <code>ApplicationContext</code>를 사용하는 이유는 무엇일까요? 당연한 말이지만 애플리케이션을 개발할 때는 빈의 관리와 조회 뿐만 아니라 다른 부가 기능들도 필요합니다.</p>
<p><code>ApplicationContext</code>는 <code>BeanFactory</code>를 비롯해 애플리케이션 국제화를 위한 <code>MessageSource</code> 인터페이스, 로컬, 개발, 운영을 구분해서 처리하기 위해 지정하는 환경 변수를 다루는 <code>EnvironmentCapable</code> 인터페이스 등을 추가로 상속받아 더 풍부한 편의 기능들을 제공합니다. 덕분에 우리가 <code>BeanFactory</code>를 직접 사용할 일은 거의 없습니다. 대부분의 경우에 <code>ApplicationContext</code>를 사용합니다.</p>
<p>물론 <code>BeanFactory</code>, <code>ApplicationContext</code> 두 인터페이스 모두 Spring 빈을 관리하고 조회하기 때문에 Spring 컨테이너입니다.</p>
<h2 id="beandefinition" class="heading">BeanDefinition</h2>
<p>우리는 지금까지 Spring 컨테이너가 <strong>어노테이션</strong>과 <strong>Java 설정 클래스</strong>(AppConfig 클래스)를 통해 설정 정보를 읽어와 Spring 빈을 생성하고 DI(의존관계 주입)를 진행한다는 것도 알아봤습니다. 그런데 앞서 Java 설정 클래스 방식뿐만 아니라 XML을 통한 설정법도 있다고 언급했습니다. 물론 지금은 잘 사용하지 않는 오래된 방식이지만 여전히 사용 중인 레거시 프로젝트들이 있기에 정상적으로 지원되고 있습니다. Spring은 어떻게 다양한 설정 방식을 지원하는 것일까요? 그 비밀은 바로 <code>BeanDefinition</code> 인터페이스에 있습니다.</p>
<p><code>BeanDefinition</code>은 XML 방식을 사용하든 Java 설정 클래스를 사용하든 개발자가 작성한 설정 정보를 기반으로 빈 설정 메타데이터를 가지게 됩니다. 그렇기에 Spring 컨테이너는 개발자가 어떤 방식을 사용(구현)했는지 알 필요 없이 <code>BeanDefintion</code>만 알고 있다면 적절하게 빈들을 생성하고, 관리하고 각종 기능들을 제공할 수 있습니다. 즉, 세상을 <strong>역할</strong>과 <strong>구현</strong>으로 나누는 <strong>다형성</strong>을 통해 실제 구현체(Java 설정 클래스나 XML 파일)가 무엇이든 <code>BeanDefinition</code>이라는 역할(추상화)에만 의존하는 것입니다. 덕분에 컨테이너는 유연하게 다양한 설정 지정 방식을 지원할 수 있게 된 것입니다.</p>
<p>사실 실무에서 이 <code>BeanDefinition</code>을 직접 다룰 일은 거의 없다고 합니다. 이 <code>BeanDefinition</code>을 깊이 있게 알기보다 어떤 방식으로 Spring이 다양한 형태의 설정 정보를 다루는지를 알기 위해 공부하는 것이 좋을 것 같습니다. 중요한 점은 Spring이 설정 정보를 다루는 과정에서 <strong>다형성</strong>을 활용한다는 것입니다. 그만큼 OOP에 대해 제대로 공부해야만 Spring을 온전히 내 기술로 다룰 수 있을 것 같습니다.</p>]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[의존관계 주입]]></title>
    <link>https://blog.coderoad.kr/ditype</link>
    <pubDate>2023-01-15</pubDate>
    <guid isPermaLink="false">https://blog.coderoad.kr/ditype</guid>
    <description>
    <![CDATA[다양한 DI 방식들]]>
    </description>
    <content:encoded>
      <![CDATA[<p><strong>본 문서는 인프런에서 수강할 수 있는 <a href="https://inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8" target="_blank" rel="noopener noreferer">스프링 핵심 원리 - 기본편</a>을 수강한 후, 공부한 내용을 정리한 문서입니다. 본 문서의 모든 저작권은 해당 강의의 저자이신 <a href="https://inflearn.com/users/@yh" target="_blank" rel="noopener noreferer">김영한</a> 우아한형제들 기술이사님께 있습니다.</strong></p>
<h2 id="다양한-의존관계-주입-방법" class="heading">다양한 의존관계 주입 방법</h2>
<p>Spring의 의존관계 주입 방법에는 크게 4가지 방법이 있습니다.</p>
<ul>
<li>생성자 주입</li>
<li>수정자 주입</li>
<li>필드 주입</li>
<li>일반 메소드 주입</li>
</ul>
<h3 id="생성자-주입">생성자 주입</h3>
<p>생성자 주입 방식은 말 그대로 클래스의 생성자(Constructor)를 통해 의존관계를 주입 받습니다. 생성자를 매개체로 사용하기 때문에 생성자 호출 시점에 <strong>딱 1번만 호출되는 것이 보장</strong>되며, 변하지 않고 필수적인 의존관계에 사용합니다. 즉, 생성자 주입 방식을 사용하면 의존관계 주입된 인스턴스를 중간에 변경할 수 없습니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MemberServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">MemberService</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token comment">//한 번 주입된 의존관계는 외부에서 변경할 수 없습니다!</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">MemberRepository</span> memberRepository<span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token annotation punctuation">@Autowired</span> <span class="token comment">//의존관계 자동 주입 기능을 사용했습니다.</span>
</span><span class="code-line">    <span class="token keyword">public</span> <span class="token class-name">MemberServiceImpl</span><span class="token punctuation">(</span><span class="token class-name">MemberRepository</span> memberRepository<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">        <span class="token comment">//Spring 컨테이너가 memberRepository 이름을 가진 빈을 주입해줍니다.</span>
</span><span class="code-line">        <span class="token keyword">this</span><span class="token punctuation">.</span>memberRepository <span class="token operator">=</span> memberRepository<span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token punctuation">}</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p>만약, 생성자가 딱 1개만 존재하면 <code>@Autowired</code>가 없어도 의존관계가 자동 주입됩니다. 당연히 주입하려는 의존관계가 Spring 빈이어야만 가능합니다.</p>
<h3 id="수정자-주입">수정자 주입</h3>
<p>수정자, 흔히 <code>Setter</code>라고 불리는 <strong>필드 값을 변경하는 수정자 메소드를 통해 의존관계를 주입</strong>하는 방법입니다. 생성자 주입 방식과 다르게 외부에서 언제든 접근이 가능하기 때문에 선택적이고 변경 가능성이 있는 의존관계에 사용하는 방식입니다. <code>Setter</code>를 사용하여 필드에 접근하는 방식을 <strong>Java 빈 프로퍼티 규약</strong>이라 하는데, 수정자 주입 방식이 해당 규약을 따른다고 생각하면 됩니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MemberServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">MemberService</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token comment">//final로 선언되지 않았기 때문에 수정될 수 있습니다.</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token class-name">MemberRepository</span> memberRepository<span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token annotation punctuation">@Autowired</span> <span class="token comment">//의존관계 자동 주입 기능을 사용했습니다.</span>
</span><span class="code-line">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setMemberRepository</span><span class="token punctuation">(</span><span class="token class-name">MemberRepository</span> memberRepository<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">        <span class="token keyword">this</span><span class="token punctuation">.</span>memberRepository <span class="token operator">=</span> memberRepository<span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token punctuation">}</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p>만약, 빈의 의존관계를 필수가 아닌 선택적으로 주입되도록 하려면, <code>@Autowired</code>를 <code>@Autowired(required = false)</code>와 같이 작성해야합니다.</p>
<h3 id="필드-주입">필드 주입</h3>
<p>필드 주입은 위의 두 방식보다 훨씬 간단합니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MemberServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">MemberService</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token comment">//이 한 줄이면 자동으로 의존관계가 주입됩니다!</span>
</span><span class="code-line">    <span class="token annotation punctuation">@Autowired</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token class-name">MemberRepository</span> memberRepository<span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p>너무나도 간단해서 많은 개발자들을 현혹시켰고, 실제로 많은 프로젝트에서 필드 주입 방식을 사용했다고 합니다. 그러나 필드 주입 방식에는 치명적인 단점들이 있어 <strong>사용을 지양해야합니다.</strong></p>
<p>가장 큰 문제는 <a href="https://blog.coderoad.kr/solid" target="_blank" rel="noopener noreferer">SOLID</a>의 SRP를 위반할 가능성이 크다는 것입니다. Spring을 관통하는 <strong>좋은 OOP를 포기하면서</strong>까지 필드 주입 방식을 사용할 이유가 없습니다!</p>
<p>또한, 클래스의 코드만 봐서는 의존관계가 한 눈에 보이지 않는 <strong>숨겨진 의존관계</strong>(Hidden dependency) 문제가 발생합니다. 실제로 어떤 인스턴스(Spring 빈)가 의존관계 주입되어야 하고, 어떤 의존관계가 필수인지, 어떤 의존관계가 변하면 안 되는지 코드를 하나하나 뜯어봐야하는 매우 비효율적인 상황이 생기는 것입니다.</p>
<p>더군다나 필드를 <code>final</code>로 선언할 수 없어 언제든 변경될 수 있습니다. 이 경우에 변경된 의존관계로 인해 예상치 못한 에러가 발생해도 쉽게 알아차릴 수 없습니다. 바로 전에 설명한 문제점에서 알 수 있듯, 필드 주입 방식은 의존관계가 감춰져 있기 때문입니다!</p>
<p>TDD(Test Driven Development, 테스트 주도 개발)에도 악영향을 끼칩니다. 필드 주입 방식은 의존관계를 주입할 때, <code>@Autowired</code> 어노테이션을 보고 Spring 컨테이너가 자동으로 주입 해주는 방식입니다. 이는, 단위 테스트 시 DI 컨테이너, 다시 말해 Spring 컨테이너가 없으면 의존관계를 주입할 방법이 없다는 이야기입니다. <code>@Autowired</code>를 보고 의존관계를 주입해줘야 하는데 순수한 Java 테스트 코드는 Spring 컨테이너가 없으니 제대로 동작할리가 없습니다.</p>
<p>Spring이 등장한 이유가 특정 기술(EJB)에 종속적이었던 Java 개발 생태계를 개선하려던 것이었음을 생각하면, Spring에 종속적인 코드는 매우 모순적인 상황이 아닐 수 없습니다. 그러니 우리는 필드 주입 방식을 멀리해야합니다.</p>
<h3 id="일반-메소드-주입">일반 메소드 주입</h3>
<p>일반적인 Java 메소드를 통해 의존관계를 주입 받을 수도 있습니다. 그러나, 일반적으로 잘 사용하지 않습니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MemberServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">MemberService</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token class-name">MemberRepository</span> memberRepository<span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token annotation punctuation">@Autowired</span>
</span><span class="code-line">    <span class="token comment">//사실 수정자 주입 방식과 별반 다를게 없습니다.</span>
</span><span class="code-line">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">dependencyInject</span><span class="token punctuation">(</span><span class="token class-name">MemberRepository</span> memberRepository<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">        <span class="token keyword">this</span><span class="token punctuation">.</span>memberRepository <span class="token operator">=</span> memberRepository<span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token punctuation">}</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<h2 id="주입-옵션-처리" class="heading">주입 옵션 처리</h2>
<p>앞서 살펴본 여러 의존관계 주입 방식 중, 선택적으로 의존관계를 주입할 때 수정자 주입 방식을 사용해야 한다는 것을 알았습니다. 다시 말하자면, 주입할 Spring 빈이 없어도 애플리케이션이 정상 작동해야할 때가 있습니다. 그런데 자동 주입 방식의 <code>@Autowired</code> 어노테이션은 주입 대상 빈이 없으면 오류가 발생해, <code>@Autowired(required = false)</code>와 같이 옵션 값을 넣어줘야 한다는 것도 잠깐 설명했습니다. 이 방법은 만약 자동 주입 대상이 없다면 수정자 메소드 자체가 실행되지 않습니다.</p>
<p><code>@Autowired</code>에 옵션 값을 지정하는 방법 외에도 주입 옵션을 설정하는 방법은 2가지가 있습니다.</p>
<ul>
<li><code>@Nullable</code> : 자동 주입 대상이 없다면 <code>null</code>을 입력</li>
<li><code>Optional&#x3C;></code> : 자동 주입 대상이 없다면 <code>Optional.empty</code> 입력</li>
</ul>
<p>두 방법의 예시는 다음과 같습니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token keyword">private</span> <span class="token class-name">Member</span> nullMember<span class="token punctuation">;</span>
</span><span class="code-line"><span class="token keyword">private</span> <span class="token class-name">Member</span> optionalMember<span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token annotation punctuation">@Autowired</span>
</span><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setBeanNullable</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Nullable</span> <span class="token class-name">Member</span> member<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword">this</span><span class="token punctuation">.</span>nullMember <span class="token operator">=</span> member<span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token annotation punctuation">@Autowired</span>
</span><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setBeanOptional</span><span class="token punctuation">(</span><span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&#x3C;</span><span class="token class-name">Member</span><span class="token punctuation">></span></span> member<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword">this</span><span class="token punctuation">.</span>optionalMember <span class="token operator">=</span> member<span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p><code>Member</code>가 Spring 빈이 아니라고 가정했을 때, 두 수정자 메소드에 의해 필드에 입력되는 값은 각각 <code>null</code>과 <code>Optional.empty</code>가 됩니다.</p>
<h2 id="생성자-주입을-선택해야하는-이유" class="heading">생성자 주입을 선택해야하는 이유</h2>
<p>지금까지 크게 3가지 의존관계 주입 방식에 대해 정리해봤습니다. 이 방식들 중, <strong>필드 주입 방식은 지양</strong>하는게 좋다는 것과 그 이유에 대해서도 알아봤습니다. 그럼 도대체 어떤 방식을 주로 사용해야하는 걸까요? 이 질문에 대한 답은 **생성자 주입을 적극 권장하며, 선택적인 의존관계(필수가 아닌 의존관계)를 지정할 때만 제한적으로 수정자 주입 방식을 사용한다.**입니다. 이는 생성자 주입이 가지는 강력한 장점과 수정자 주입 방식의 한계 때문입니다.</p>
<h3 id="불변">불변</h3>
<p>먼저, 생성자 주입 방식을 통해 의존관계를 주입하면, <strong>애플리케이션이 작동 중인 동안에 변경되지 않습니다.</strong> 컴파일 단계에서 주입된 대부분의 의존관계가 애플리케이션 종료 전까지 변할 일이 없어야 한다는 걸 생각하면 이는 훌륭한 장점입니다. 사실, 수정자 주입 방식의 <code>Setter</code> 메소드는 의도치 않은 변경에 매우 취약해 좋은 설계 방법이 아닙니다. 따라서, 객체를 생성할 때 딱 1번만 호출되는 <strong>생성자 주입 방식</strong>을 사용하도록 설계하는 것이 훨씬 좋은 방법입니다.</p>
<h3 id="누락">누락</h3>
<p>수정자 주입 방식의 큰 문제점이 하나 더 있습니다. 만약 연관관계 주입 자체가 누락될 경우, 컴파일 단계에서 오류가 발생하지 않고 실행 도중 <code>NullPointerException</code>를 맞닥뜨리게 됩니다. <code>NPE</code>는 그 원인을 찾아내기 까다로워 Java 프로그래머들을 가장 많이 괴롭히는 악명 높은 예외입니다. 그에 반해 <strong>생성자 주입 방식</strong>은 연관관계 주입이 누락되었을 경우, <strong>컴파일 오류</strong>가 발생합니다. 생성자에 즉, 생성자 주입 방식을 사용하는 것 만으로도 Java 프로그래머의 골칫거리 <code>NPE</code>를 사전에 차단할 수 있는 큰 장점이 있습니다.</p>
<h3 id="final">final</h3>
<p>더 나아가, <code>final</code> 키워드를 사용할 수 있는 것이 생성자 주입을 사용해야하는 이유입니다. <code>final</code> 키워드가 붙은 필드는 선언과 동시에 값을 할당해야하고, 그 값은 변경할 수 없습니다. 이 <code>final</code> 필드에 값을 할당할 수 있는 방법들 중 한가지가 바로 <strong>생성자</strong>를 활용하는 것입니다. 만약 <code>final</code> 필드에 생성자를 통해 아무런 값도 할당하지 않으면, Java는 다음과 같은 컴파일 오류를 발생시킵니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line">java<span class="token operator">:</span> variable might not have been initialized
</span></code></pre>
<p>선언과 동시에 값이 할당(초기화)되어야 하는 <code>final</code> 필드에 아무런 값도 할당되지 않았으니, 이대로 실행시켜도 오류가 발생할 수 밖에 없어 Java가 컴파일 단계에서 오류를 발생시켜주는 것입니다. <strong>컴파일 오류는 세상에서 가장 빠르고, 좋은 오류입니다!</strong> 이렇게 <code>final</code> 키워드를 붙이는 것만으로도 연관관계 주입이 빠지지 않고 제대로 될 수 있도록 강제하는 장점도 있으니, <strong>생성자 주입 방식</strong> 대신 다른 방식을 선택할 이유가 없습니다!</p>
<h2 id="lombok과-함께" class="heading">Lombok과 함께</h2>
<p>자, 이제 우리는 좋은 코드를 작성하기 위해선 <strong>생성자 주입 방식</strong>을 사용해야한다는 것도 알게 되었습니다. 그런데, 대부분의 연관관계는 불변입니다. 덕분에 <code>final</code> 키워드를 붙이는 건 이제 습관이 될 정도로 자주 사용하게 되었습니다. 매번 생성자를 작성하는 것도 반복적이고 지루한 작업으로 느껴질 정도가 되어버렸고, 비효율적인 것은 참지 못하는 개발자들은 더 나은 방법을 고안해내기 시작했습니다. 역시 가장 빠르고 효율적인 개발은 불필요한 코드를 지우는 것이었습니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token annotation punctuation">@Component</span>
</span><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MemberServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">MemberService</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">MemberRepository</span> memberRepository<span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">TeamRepository</span> teamRepository<span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token comment">//@Autowired 어노테이션은 생성자가 하나일 때 생략되어도 된다!</span>
</span><span class="code-line">    <span class="token keyword">public</span> <span class="token class-name">MemberServiceImpl</span><span class="token punctuation">(</span><span class="token class-name">MemberRepository</span> memberRepository<span class="token punctuation">,</span> <span class="token class-name">TeamRepository</span> teamRepository<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">        <span class="token keyword">this</span><span class="token punctuation">.</span>memberRepository <span class="token operator">=</span> memberRepository<span class="token punctuation">;</span>
</span><span class="code-line">        <span class="token keyword">this</span><span class="token punctuation">.</span>teamRepository <span class="token operator">=</span> teamRepository<span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token punctuation">}</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p><code>@Autowired</code> 어노테이션은 <strong>생성자가 딱 1개 있을 때 생략해도 된다</strong>는 것을 이 포스트의 초반에서 알아봤습니다. <code>@Autowired</code>를 생략하고보니 <strong>생성자</strong>도 굳이 개발자가 직접 타이핑 하지 않는 것이 더 효율적이지 않을까라고 생각하게 되었습니다. 이때 등장하는 것이 바로 <strong><code>Lombok</code> 라이브러리</strong>입니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token annotation punctuation">@Component</span>
</span><span class="code-line"><span class="token annotation punctuation">@RequiredArgsConstructor</span> <span class="token comment">//Lombok 라이브러리의 어노테이션</span>
</span><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MemberServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">MemberService</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">MemberRepository</span> memberRepository<span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">TeamRepository</span> teamRepository<span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token comment">//생성자가 사라져도 문제 없습니다!</span>
</span><span class="code-line">    <span class="token comment">//Lombok 라이브러리의 @RequiredArgsConstructor 어노테이션이</span>
</span><span class="code-line">    <span class="token comment">//연관관계 주입이 필요한 필드를 위해 자동으로 생성자를 만들어줍니다.</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p>놀랍게도 <code>Lombok</code>이라는 라이브러리를 사용했더니 어노테이션 한 줄 붙여줬을 뿐인데 생성자를 작성할 필요가 없어졌습니다! 이는 <code>Lombok</code> 라이브러리가 Java의 <strong>어노테이션 프로세서</strong>라는 기능을 통해 애플리케이션의 컴파일 시점에 생성자 코드를 자동으로 생성해줬기 때문입니다. 컴파일의 결과물인 <code>.class</code> 파일(Java 바이트 코드 파일)을 열어보면 알맞은 생성자가 작성되어 있는 것을 확인할 수 있습니다.</p>
<p>최근 실무에서는 이렇게 생성자를 1개만 둬 <code>@Autowired</code> 어노테이션을 생략하는 방법을 사용한다고 합니다. 거기에 <code>Lombok</code> 라이브러리까지 활용해 코드를 최대한 깔끔하게 만들되 기능은 모두 제공하는 방식으로 코드를 작성한다고 합니다.</p>
<h2 id="중복-빈이-존재할-때" class="heading">중복 빈이 존재할 때</h2>
<p>중복된 Spring 빈, 다시 말해 같은 타입의 빈이 여러개 존재할 경우, <code>NoUniqueBeanDefinitionException</code> 오류가 발생할 수 있습니다. 자동으로 의존관계를 주입해주는 <code>@Autowired</code> 어노테이션은 타입 기반으로 빈을 조회하는데, <a href="https://blog.coderoad.kr/containerandbean" target="_blank" rel="noopener noreferer">Spring 컨테이너와 빈</a> 포스트에서 정리했던 것처럼 동일한 타입의 빈이 존재하면 오류가 발생합니다. 이 오류를 해결하는 방법에는 여러가지가 있지만, <strong>의존관계 자동 주입 방식을 유지하면서 해결</strong>하는 방법들에 대해 알아보겠습니다.</p>
<h3 id="autowired-필드-이름과-빈-이름-매칭">@Autowired 필드 이름과 빈 이름 매칭</h3>
<p>가장 먼저, 간단하면서도 코드 변경도 적은 방법입니다. 예시로 간단한 의존관계 주입 코드를 작성해봤습니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token annotation punctuation">@Autowired</span>
</span><span class="code-line"><span class="token comment">//DiscountPolicy 타입의 Spring 빈이 하나만 있다면 문제 없지만...</span>
</span><span class="code-line"><span class="token keyword">private</span> <span class="token class-name">DiscountPolicy</span> discountPolicy<span class="token punctuation">;</span>
</span></code></pre>
<p>만약, <code>DiscountPolicy</code> 타입의 빈이 여러개 있다면, 오류가 발생할 것입니다. <strong><code>@Autowired</code> 필드 이름 매칭 방식</strong>으로 오류를 해결하려면 다음과 같이 빈 이름을 필드 이름으로 작성해주시면 됩니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token annotation punctuation">@Autowired</span>
</span><span class="code-line"><span class="token comment">//DiscountPolicy 타입의 rateDiscountPolicy Spring 빈을 주입합니다.</span>
</span><span class="code-line"><span class="token keyword">private</span> <span class="token class-name">DiscountPolicy</span> rateDiscountPolicy<span class="token punctuation">;</span>
</span></code></pre>
<p>이렇게 빈 이름을 필드 이름으로 작성하면 <code>DiscountPolicy</code> 타입의 <code>rateDiscountPolicy</code> 빈이 주입됩니다.</p>
<h3 id="qualifier와-primary-활용">@Qualifier와 @Primary 활용</h3>
<p>필드 이름 매칭 방식 외에도 활용할만한 방식이 2가지 더 있습니다. <code>@Qualifier</code>와 <code>@Primary</code> 어노테이션을 활용하는 방법입니다. 먼저 <code>@Qualifier</code> 어노테이션은 빈을 등록할 때, 추가적인 주입 옵션을 부여하는 어노테이션입니다. 사용 방법은 다음과 같습니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token annotation punctuation">@Component</span>
</span><span class="code-line"><span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span><span class="token string">"mainDiscountPolicy"</span><span class="token punctuation">)</span>
</span><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RateDiscountPolicy</span> <span class="token keyword">implements</span> <span class="token class-name">DiscountPolicy</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</span></code></pre>
<p>위와 같이 Spring 빈으로 등록할 클래스에 <code>@Qualifier</code> 어노테이션으로 의존관계 주입 시에 추가적으로 사용할 옵션을 부여할 수 있습니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token annotation punctuation">@Autowired</span>
</span><span class="code-line"><span class="token keyword">public</span> <span class="token class-name">OrderServiceImpl</span><span class="token punctuation">(</span><span class="token class-name">MemberRepository</span> memberRepository<span class="token punctuation">,</span> <span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span><span class="token string">"mainDiscountPolicy"</span><span class="token punctuation">)</span> <span class="token class-name">DiscountPolicy</span> discountPolicy<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword">this</span><span class="token punctuation">.</span>memberRepository <span class="token operator">=</span> memberRepository<span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token keyword">this</span><span class="token punctuation">.</span>discountPolicy <span class="token operator">=</span> discountPolicy<span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<h2 id="조회한-빈이-모두-필요할-때" class="heading">조회한 빈이 모두 필요할 때</h2>
<h2 id="자동과-수동-빈-등록-올바른-실무-운영법" class="heading">자동과 수동 빈 등록, 올바른 실무 운영법</h2>
<pre><code class="code-highlight"></code></pre>]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[IoC와 DI]]></title>
    <link>https://blog.coderoad.kr/iocanddi</link>
    <pubDate>2023-01-15</pubDate>
    <guid isPermaLink="false">https://blog.coderoad.kr/iocanddi</guid>
    <description>
    <![CDATA[Spring의 시작과 끝, IoC와 DI]]>
    </description>
    <content:encoded>
      <![CDATA[<p><strong>본 문서는 인프런에서 수강할 수 있는 <a href="https://inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8" target="_blank" rel="noopener noreferer">스프링 핵심 원리 - 기본편</a>을 수강한 후, 공부한 내용을 정리한 문서입니다. 본 문서의 모든 저작권은 해당 강의의 저자이신 <a href="https://inflearn.com/users/@yh" target="_blank" rel="noopener noreferer">김영한</a> 우아한형제들 기술이사님께 있습니다.</strong></p>
<h2 id="제어의-역전-ioc" class="heading">제어의 역전 IoC</h2>
<p>**제어의 역전(Inversion of Control)**은 말 그대로 제어에 역전이 일어났다는 의미입니다. 제어에 역전이 일어났다니, 도대체 무슨 말일까요? 그동안 우리가 작성해왔던 프로그램들은 크게 신경쓰지 않았다면 자연스럽게 <strong>구현 객체가 프로그램의 흐름을 제어</strong>했습니다. 구현 객체 스스로 로직에 필요한 다른 구현 객체들을 생성하고(new 키워드), 연결하고, 로직에 맞춰 실행했습니다. 그러나 이런 방식은 결국 구현 객체에 의존해야(알아야)한다는 문제가 있습니다. 다시 말해서 <a href="https://blog.coderoad.kr/solid" target="_blank" rel="noopener noreferer">SOLID</a> 중 DIP(의존관계 역전 원칙)를 위반한다는 것입니다. 또한, 기존의 방식은 SRP와 OCP도 함께 위반하게 됩니다. 구현 객체가 객체의 생성, 연결, 실행까지 모두 담당하고 있어 SRP(단일 책임 원칙)에 위배되고, 새로운 구현 객체를 비즈니스에 적용하고자 코드를 수정해야할 때, 기존의 구현 객체에 의존하는 모든 코드들을 수정해야하기 때문에 OCP(개방-폐쇄 원칙)을 위반하게 됩니다.</p>
<p>우린 좋은 객체 지향 프로그래밍을 위해 여러 SOLID 원칙들을 위반하는 문제를 해결해야합니다. 먼저, DIP를 준수하기 위해선 <strong>추상화에만 의존</strong>해야합니다. 구현 객체들은 다른 구현 객체에 전혀 의존하지 않고, 자신들이 맡은 비즈니스 로직만 잘 수행하면 됩니다. 즉, 구현 객체 내부에서 다른 구현 객체들을 알고 있을 필요가 없습니다. 하지만 다른 구현 객체들과 협력하지 못한다면 SOLID를 지키기는 커녕 프로그램이 제대로 돌아갈리가 없습니다. 그렇다면 어떻게 추상화에만 의존하면서 객체들 간의 협력 관계를 부여할 수 있을까요?</p>
<p>방법은 간단합니다. 추상화에만 의존하고 있는 객체들에게 구현 객체를 전달해주는 <strong>구성자</strong>가 존재하면 해결됩니다. 모든 구현 객체들을 생성하고 필요한 곳에 연결해주는 등의 제어 권한을 가진 클래스를 만들어주면 DIP를 준수할 수 있습니다. 이 구성자의 등장으로 SRP와 OCP도 준수할 수 있습니다. 구성자는 앞서 설명했던대로 객체 생성, 연결이라는 책임을 구현 객체들로부터 가져왔기 때문에 구현 객체는 실행이라는 책임만 가지게 됐습니다. 또한, 구현 객체들이 <strong>추상화</strong>에만 의존하게 되었으므로 구현 객체를 교체할 때 수정해야하는 것은 <strong>구성자</strong>이지 구현 객체들이 아니기 때문에 OCP도 준수할 수 있습니다.</p>
<p>이렇게 외부의 <strong>구성자</strong>가 프로그램의 흐름을 관리하는 것을 **제어의 역전(Inversion of Control)**이라고 합니다. 흔히 프레임워크들이 제어의 역전을 통해 우리가 작성한 코드들을 제어하고 대신 실행합니다. 그에 반해 라이브러리는 우리의 코드를 제어하기 보단 라이브러리의 코드를 우리가 직접 활용하기 때문에 제어의 역전을 사용하지 않습니다.</p>
<h2 id="의존관계-주입-di" class="heading">의존관계 주입 DI</h2>
<p>**의존관계 주입(Dependency Injection)**은 의존관계를 외부에서 주입해주는 것을 말합니다. 우리는 앞서 SOLID 위반을 피하기 위해 추상화에만 의존하고자 프로그램에 IoC 개념을 적용했습니다. 추상화에만 의존하게 된 구현 객체들은 자신이 의존하고 있는 인터페이스 외에는 알고 있는 것이 전혀 없습니다. 하지만 인터페이스는 역할이고 구현체가 아니기 때문에, 인터페이스만 알고 있어서는 프로그램이 올바르게 동작하지 않습니다. 제대로 프로그램이 동작하도록 프로그램의 제어권을 가져간 <strong>구성자</strong>가 의존관계를 설정해줘야 합니다.</p>
<p>구성자가 관리해야할 의존관계에 대해 자세히 알아보기 전에 의존관계의 두 가지 분류를 살펴보겠습니다. 먼저, <strong>import 구문</strong>을 통해 명시적으로 작성하는 의존관계인 <strong>정적 클래스 의존관계</strong>가 있습니다. 이 의존관계는 import 구문을 읽으면 어떤 객체에 의존하고 있는지 프로그램을 실행하지 않아도 알 수 있습니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token comment">//이 코드는 MemberRepository 객체에 의존하고 있습니다.</span>
</span><span class="code-line"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">hello<span class="token punctuation">.</span>core<span class="token punctuation">.</span>member<span class="token punctuation">.</span></span><span class="token class-name">MemberRepository</span></span><span class="token punctuation">;</span>
</span></code></pre>
<p>그러나, 우리는 프로그램을 오로지 추상화에만 의존하도록 제어의 역전을 일으켜야 SOLID를 준수할 수 있다는 것을 알았습니다. 위의 코드와 같은 정적 클래스 의존관계는 의존하고 있는 추상화가 무엇인지는 알 수 있지만 실제 구현 객체는 전혀 알 수 없습니다. 이때, IoC와 <strong>구성자</strong>의 역할이 중요한 이유가 나타납니다. 프로그램의 제어권을 가져간 구성자는 프로그램의 실행 시점(런타임)에 실제 구현 객체 인스턴스를 직접 생성하고 해당 객체를 필요로하는 코드들에 의존관계를 연결합니다. 이것을 **의존관계 주입(Dependency Injection)**이라고 합니다. DI를 사용하면 클라이언트 코드를 전혀 변경하지 않고, 클라이언트가 호출하는 대상의 인스턴스 타입을 변경할 수 있습니다. 즉, OCP 원칙이 준수된다는 의미입니다.</p>
<h2 id="컨테이너의-등장" class="heading">컨테이너의 등장</h2>
<p>IoC를 통해 프로그램의 제어권을 온전히 가지게 된 <strong>구성자</strong>는 앞서 살펴본대로 객체를 생성하고, 관리하면서, 의존관계를 연결(DI)해주는 역할을 수행하고 있습니다. 이 구성자를 바로 **컨테이너(Container)**라고 합니다. IoC 컨테이너, DI 컨테이너 등, 많은 이름이 있지만 최근에는 DI에 중점을 두고 주로 DI 컨테이너라고 합니다. 물론 Spring에서는 <strong>Spring 컨테이너</strong>라고 합니다. 이름은 차이가 있어도 맡고 있는 역할은 전혀 다를게 없으니 Spring을 공부하는 입장에선 Spring 컨테이너라고 하는 것이 좋을 것 같습니다. 다시 한번 강조하지만, 컨테이너 외부에서는 애플리케이션의 모든 객체는 추상화에만 의존해야합니다. 컨테이너 외부에서 추상화가 아닌 구현체에 의존하게 되면 Spring을 사용하는 의미도 없을 뿐더러 SOLID에 위배되어 좋은 객체 지향 프로그래밍도 아니기 때문입니다. 물론 테스트 코드를 작성할 때는 필요에 따라 new 키워드로 구현 객체를 생성해도 상관 없습니다. 단위 테스트를 위해 간단한 더미 데이터가 필요한데 실제 서비스 코드를 수정하는게 훨씬 비효율적이기 때문입니다.</p>
<p>자, 이제 우리는 IoC를 통해 만들어진 구성자가 컨테이너라는 것도 알았습니다. 좋은 객체 지향 프로그래밍을 위해서 직접 컨테이너를 만들어 구현 객체를 생성하고, 관리하면서, 의존관계도 주입해주면 됩니다! Spring에서는 기본적으로 <strong>ApplicationContext</strong>라는 인터페이스를 통해 컨테이너를 제공하고 있습니다. 즉, 우린 Spring 컨테이너에 대해 공부하면 지금까지 알아봤던 여러 개념들을 간단하게 적용할 수 있는 것입니다! 이제 Spring의 컨테이너에 대해 더 자세하게 공부해, Spring의 장점을 극대화해봅시다.</p>]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[빈 생명주기와 콜백]]></title>
    <link>https://blog.coderoad.kr/lifecyclecallback</link>
    <pubDate>2023-01-15</pubDate>
    <guid isPermaLink="false">https://blog.coderoad.kr/lifecyclecallback</guid>
    <description>
    <![CDATA[Spring 빈의 생명주기, 콜백이란?]]>
    </description>
    <content:encoded>
      <![CDATA[<p><strong>본 문서는 인프런에서 수강할 수 있는 <a href="https://inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8" target="_blank" rel="noopener noreferer">스프링 핵심 원리 - 기본편</a>을 수강한 후, 공부한 내용을 정리한 문서입니다. 본 문서의 모든 저작권은 해당 강의의 저자이신 <a href="https://inflearn.com/users/@yh" target="_blank" rel="noopener noreferer">김영한</a> 우아한형제들 기술이사님께 있습니다.</strong></p>
<h2 id="spring-빈의-생명주기와-콜백" class="heading">Spring 빈의 생명주기와 콜백</h2>
<h2 id="인터페이스를-통한-콜백-다루기" class="heading">인터페이스를 통한 콜백 다루기</h2>
<h2 id="빈-등록-초기화와-소멸-메소드" class="heading">빈 등록 초기화와 소멸 메소드</h2>
<h2 id="애노테이션을-통한-콜백-다루기" class="heading">애노테이션을 통한 콜백 다루기</h2>]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[좋은 객체 지향 프로그래밍]]></title>
    <link>https://blog.coderoad.kr/oop</link>
    <pubDate>2023-01-15</pubDate>
    <guid isPermaLink="false">https://blog.coderoad.kr/oop</guid>
    <description>
    <![CDATA[Spring과 OOP]]>
    </description>
    <content:encoded>
      <![CDATA[<p><strong>본 문서는 인프런에서 수강할 수 있는 <a href="https://inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8" target="_blank" rel="noopener noreferer">스프링 핵심 원리 - 기본편</a>을 수강한 후, 공부한 내용을 정리한 문서입니다. 본 문서의 모든 저작권은 해당 강의의 저자이신 <a href="https://inflearn.com/users/@yh" target="_blank" rel="noopener noreferer">김영한</a> 우아한형제들 기술이사님께 있습니다.</strong></p>
<h2 id="객체-지향-프로그래밍" class="heading">객체 지향 프로그래밍</h2>
<p>객체 지향 프로그래밍의 특징으로는 다양한 것들이 있습니다. 클래스 개념으로 대표되는 <strong>캡슐화(Encapsulation)</strong>, 캡슐화에서 파생된 개념인 접근 제어자를 통한 <strong>정보 은닉(Information hiding)</strong>, 부모 클래스의 요소들을 자식 클래스에서 물려받을 수 있는 <strong>상속(Inheritance)</strong>, 프로그램이 유연하고 변경이 용이하게 해주는 **다형성(Polymorphism)**이 객체 지향의 특징들입니다.</p>
<p>그 중에서도 가장 핵심이라고 할 수 있는 특징은 <strong>다형성</strong>입니다. Spring은 이 다형성의 장점을 극대화하여 활용할 수 있게 도와주는 프레임워크입니다. Spring이 다형성을 어떻게 다루는지 알아보기 전에 다형성에 대해서 좀 더 알아보겠습니다.</p>
<h2 id="다형성이란" class="heading">다형성이란?</h2>
<p>**다형성(Polymorphism)**을 쉽게 이해하기 위해선 <strong>역할</strong>과 <strong>구현</strong>으로 세상을 구분해보는 것이 가장 좋습니다. 가장 대표적인 예시는 <strong>운전자</strong>와 <strong>자동차</strong>입니다. 운전자와 자동차라는 <strong>역할</strong>은 그 자리에 어떤 구현체(예를 들어 택시 운전사와 아반떼)가 오던 운전자는 자동차를 운전할 수 있습니다. 즉, 구현체와 관계 없이 동작은 한다는 의미입니다. 물론 운전자에 프로 레이싱 선수, 자동차에 슈퍼카라는 구현체가 운전자와 자동차 역할을 담당한다면 훨씬 좋은 성능을 낼 수 있을 것입니다. 여기서 중요한 점은 운전자, 자동차라는 역할과 그 역할을 수행할 구현체는 유연하고 변경이 용이해야한다는 점입니다.</p>
<p>역할과 구현을 분리하는 것이 백엔드 프로그래밍에서 주는 장점은 다음과 같습니다.</p>
<ul>
<li>클라이언트는 대상의 역할(인터페이스)만 알고 있으면 된다.</li>
<li>클라이언트는 구현 대상의 내부 구조를 몰라도 된다.</li>
<li>클라이언트는 구현 대상의 내부 구조가 변경되어도 영향을 받지 않는다.</li>
<li>클라이언트는 구현 대상 자체를 변경해도 영향을 받지 않는다.</li>
</ul>
<p>우리가 Spring을 공부하는 중요한 이유 중 하나가 백엔드 프로그래밍 분야에서 가장 강력한 기술을 갖기 위해서임은 부정할 수 없는 사실입니다. 위와 같은 장점들을 통해 우린 클라이언트와 상관없이 독립적으로 유연하고 변경이 용이한 환경에서 개발할 수 있습니다.</p>
<h2 id="java에서의-다형성" class="heading">Java에서의 다형성</h2>
<p>Java에서 <strong>역할</strong>은 <strong>인터페이스(Interface)</strong>, <strong>구현</strong>은 인터페이스를 통해 구현한 <strong>구현체</strong>입니다. 우리는 항상 객체를 설계할 때 역할과 구현을 명확하게 분리해야 합니다. <strong>역할을 먼저</strong> 부여하고, 그 역할을 올바르게 수행하는 <strong>구현</strong> 객체를 만들어야합니다. 이 과정이 곧 다형성을 극대화하는 과정이기 때문입니다. Java의 강력한 장점이자 Spring이 탄생한 이유인 <strong>좋은 객체 지향</strong>을 위해서는 필수적입니다.</p>
<p>객체를 역할과 구현으로 구분하는 과정을 Java에서는 **오버라이딩(Overriding)**이라는 문법을 통해 진행할 수 있습니다. 오버라이딩은 Java의 기본 문법으로 프로그램 실행 시에는 오버라이딩된 메소드가 실행된다는 특징이 있습니다. 쉽게 설명하자면 **"덮어쓰기"**입니다. 이 오버라이딩을 통해 확보한 다형성으로 인터페이스를 구현한 구현체를 실행 시점에서 유연하게 변경할 수 있습니다. 물론 인터페이스 뿐만 아니라 클래스 간의 상속 관계에서도 오버라이딩이 가능하고 다형성이 확보됩니다.</p>
<p>코드로 간단하게 Java에서의 다형성을 확인해보면 다음과 같습니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token comment">//역할</span>
</span><span class="code-line"><span class="token keyword">interface</span> <span class="token class-name">Car</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword">void</span> <span class="token function">accelPedal</span><span class="token punctuation">(</span><span class="token keyword">int</span> speed<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token keyword">void</span> <span class="token function">breakPedal</span><span class="token punctuation">(</span><span class="token keyword">int</span> speed<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token comment">//구현체 1</span>
</span><span class="code-line"><span class="token keyword">class</span> <span class="token class-name">SuperCar</span> <span class="token keyword">implements</span> <span class="token class-name">Car</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token annotation punctuation">@Override</span>
</span><span class="code-line">    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">accelPedal</span><span class="token punctuation">(</span><span class="token keyword">int</span> speed<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">        speed <span class="token operator">+=</span> <span class="token number">50</span><span class="token punctuation">;</span>
</span><span class="code-line">        <span class="token keyword">return</span> speed<span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token punctuation">}</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token annotation punctuation">@Override</span>
</span><span class="code-line">    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">breakPedal</span><span class="token punctuation">(</span><span class="token keyword">int</span> speed<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">        speed <span class="token operator">-=</span> <span class="token number">50</span><span class="token punctuation">;</span>
</span><span class="code-line">        <span class="token keyword">return</span> speed<span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token punctuation">}</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token comment">//구현체 2</span>
</span><span class="code-line"><span class="token keyword">class</span> <span class="token class-name">NormalCar</span> <span class="token keyword">implements</span> <span class="token class-name">Car</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token annotation punctuation">@Override</span>
</span><span class="code-line">    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">accelPedal</span><span class="token punctuation">(</span><span class="token keyword">int</span> speed<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">        speed <span class="token operator">+=</span> <span class="token number">25</span><span class="token punctuation">;</span>
</span><span class="code-line">        <span class="token keyword">return</span> speed<span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token punctuation">}</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token annotation punctuation">@Override</span>
</span><span class="code-line">    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">breakPedal</span><span class="token punctuation">(</span><span class="token keyword">int</span> speed<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">        speed <span class="token operator">-=</span> <span class="token number">25</span><span class="token punctuation">;</span>
</span><span class="code-line">        <span class="token keyword">return</span> speed<span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token punctuation">}</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p>Car라는 인터페이스를 통해 역할을 설계했고, 해당 역할을 수행할 SuperCar와 NormalCar라는 두 구현체를 만들었습니다. 프로그래머가 나중에 어떤 구현체를 사용하냐에 따라 다른 성능에 차이가 날 것입니다. 오버라이딩을 통해 역할의 메소드를 서로 다른 성능을 가지도록 만들었으며 이를 실행 시점에 유연하게 변경이 가능합니다. 유연하게 변경하는 과정을 코드로 보면 다음과 같습니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Driver</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">        <span class="token comment">//NormalCar 자리에 SuperCar 구현체로 바꿔 넣기만 해도</span>
</span><span class="code-line">        <span class="token comment">//훨씬 향상된 성능의 메소드가 수행된다!</span>
</span><span class="code-line">        <span class="token comment">//이것이 유연하고 변경이 용이하다는 의미이다.</span>
</span><span class="code-line">        <span class="token class-name">Car</span> myCar <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NormalCar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">        <span class="token keyword">int</span> currentSpeed<span class="token punctuation">;</span>
</span><span class="code-line">        currentSpeed <span class="token operator">=</span> myCar<span class="token punctuation">.</span><span class="token function">accelPedal</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">        currentSpeed <span class="token operator">=</span> myCar<span class="token punctuation">.</span><span class="token function">breakPedal</span><span class="token punctuation">(</span>currentSpeed<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token punctuation">}</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<h2 id="다형성의-본질" class="heading">다형성의 본질</h2>
<p>다형성의 본질은 결국 **유연하게 변경 가능하다.**에 있습니다. 다형성의 본질을 더 확실하게 이해하려면 <strong>협력</strong>이라는 객체 간의 관계를 이해하는데서 시작해야합니다. 현실 세계에서 <strong>혼자 있는 객체는 없습니다</strong>. 다른 어떤 객체와 협력하지 않는 객체는 존재한다고 할 수 없습니다. <strong>나</strong>라는 객체는 <strong>거주지의 역할</strong>을 하는 <strong>집</strong>이라는 객체와 <strong>협력 관계</strong>에 있습니다. 집은 내가 안전하게 생존할 수 있도록 협력하고 나는 집이 튼튼하게 유지될 수 있도록 돈을 들여 유지보수를 합니다. 만약 이 협력 관계가 없다면 두 객체 모두 빠르게 사라져버릴 것입니다. 사람이 살면서 유지보수하지 않는 집은 집으로서 의미가 없어지고 허물어질 것이며, 집이 없는 사람은 여러 위협에 노출되어 생존에 매우 불리해집니다.</p>
<p>이 협력이라는 관계를 컴퓨터 세계로 가져온다면 <strong>클라이언트</strong>와 <strong>서버</strong>로 볼 수 있습니다. 클라이언트는 서버로 요청을 보내고 서버는 요청에 대한 응답을 클라이언트에게 보냅니다. 클라이언트 객체와 서버 객체는 협력 관계에 있습니다. 만약 두 객체 간의 협력이 없다면 클라이언트가 몇 번이고 요청을 보낸다 한들 서버는 응답을 클라이언트에게 보내지 않을 것입니다. 그렇다면 이 객체들을 클라이언트와 서버로 부르는 것은 옳지 않습니다. 각자 클라이언트와 서버라는 역할을 전혀 수행하지 못하고 있기 때문입니다. 즉, 다형성의 기초였던 역할과 구현으로의 분리는 객체 간 협력 관계가 있어야 성립합니다.</p>
<p>이 협력 관계를 유지하면서 <strong>클라이언트를 전혀 변경하지 않고 서버의 구현 기능을 유연하게 변경할 수 있다</strong>는 것이 다형성의 본질입니다.</p>
<h2 id="다형성의-장점과-한계" class="heading">다형성의 장점과 한계</h2>
<p>다형성의 장점에는 다음과 같은 것들이 있습니다.</p>
<ul>
<li>실세계의 역할과 구현이라는 편리한 컨셉을 다형성을 통해 객체 세상으로 가져올 수 있음</li>
<li>유연하고 변경이 용이함</li>
<li>확장 가능한 설계가 가능함</li>
<li>클라이언트에 영향을 주지 않는 변경 가능함</li>
</ul>
<p>이러한 다형성의 장점을 제대로 활용하기 위해선 역할(인터페이스)를 안정적으로 잘 설계하는 것이 중요합니다. 구현체가 인터페이스에 전혀 영향을 주지 않고 변경이 가능해야하므로 설계 단계부터 완벽히 해야합니다. 만약 그렇지 못할 경우에 한계는 다음과 같습니다.</p>
<ul>
<li>역할(인터페이스) 자체가 변하면, 클라이언트, 서버 모두에 큰 변경이 발생함</li>
<li>자동차를 비행기로 변경해야할 때..?</li>
<li>USB 인터페이스가 변경된다면..?</li>
<li>도량형이 변경되어 버린다면..?</li>
</ul>
<p>기준이 되는 역할이 바뀌어버리면 구현체도 모두 변경해야하는 치명적인 단점이 존재합니다. 따라서 다형성을 극대화하여 "좋은 객체 지향" 프로그래밍을 하기 위해서는 항상 역할(인터페이스)의 설계에 가장 많은 시간을 들여 변경을 최소화 해야합니다.</p>
<h2 id="spring과-좋은-객체-지향-프로그래밍" class="heading">Spring과 좋은 객체 지향 프로그래밍</h2>
<p>Spring에서는 위에서 말했던 다형성을 극대화하는데 집중합니다. Spring의 주요 개념인 <strong>제어의 역전(Inversion of Control)</strong>, **의존관계 주입(Dependency Injection)**은 다형성을 활용해 역활과 구현을 편리하게 다룰 수 있도록 지원합니다. 다시 말하면 다형성이 Spring의 알파이자 오메가, 전부라고 할 수 있습니다! Spring을 사용한다면 마치 레고 블럭을 조립하듯 구현체를 편리하게 변경할 수 있습니다. "좋은 객체 지향"을 목표로 만들어진만큼 프로그래머로 하여금 더 쉽게 객체 지향적 프로그래밍을 할 수 있도록 돕는 것이 Spring의 <strong>역할</strong>입니다.</p>]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[싱글톤]]></title>
    <link>https://blog.coderoad.kr/singleton</link>
    <pubDate>2023-01-15</pubDate>
    <guid isPermaLink="false">https://blog.coderoad.kr/singleton</guid>
    <description>
    <![CDATA[Spring과 싱글톤 패턴]]>
    </description>
    <content:encoded>
      <![CDATA[<p><strong>본 문서는 인프런에서 수강할 수 있는 <a href="https://inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8" target="_blank" rel="noopener noreferer">스프링 핵심 원리 - 기본편</a>을 수강한 후, 공부한 내용을 정리한 문서입니다. 본 문서의 모든 저작권은 해당 강의의 저자이신 <a href="https://inflearn.com/users/@yh" target="_blank" rel="noopener noreferer">김영한</a> 우아한형제들 기술이사님께 있습니다.</strong></p>
<h2 id="spring과-싱글톤" class="heading">Spring과 싱글톤</h2>
<p>싱글톤 패턴은 클래스의 <strong>인스턴스</strong>가 <strong>딱 1개 생성</strong>되는 것을 <strong>보장</strong>하는 <strong>디자인 패턴</strong>입니다. 따라서 우리가 싱글톤 패턴을 구현할 때, 의도적으로 객체 인스턴스가 2개 이상 생성되지 않게 해야합니다. 제가 갑자기 싱글톤에 대해서 설명하는 이유는, 이 싱글톤 패턴이 Spring과 아주 밀접한 관계가 있기 때문입니다.</p>
<p>웹 애플리케이션은 Spring 애플리케이션의 절대 다수를 차지합니다. Spring 프레임워크가 당시 무겁고 복잡했던 기업용 Java 기술들을 순수하고 편리하게 제공하기 위해 탄생했다는 것을 생각하면 웹 애플리케이션과 Spring은 뗄레야 뗄 수 없는 사이입니다. 그런데 웹 애플리케이션은 다수의 사용자가 동시에 서비스에 접근하게 됩니다. 만약 웹 애플리케이션이 서비스에 접근하는 사용자 모두에게 새로운 서비스 인스턴스를 생성해서 제공한다면, 초당 1천 명만 접속해도 순식간에 1천 개가 넘는 객체가 생성되고 삭제되는 심각한 메모리 낭비가 발생합니다.</p>
<p>이러한 메모리 낭비를 막고자 싱글톤 패턴을 사용해 서비스 객체는 딱 1개만 생성되고 모든 사용자들이 이를 공유하도록 해야합니다. 싱글톤 패턴을 구현하는 방법은 다양합니다. 중요한 것은 애플리케이션이 실행 중인 동안 인스턴스가 1개만 생성되어야 한다는 것입니다. 성공적으로 싱글톤 패턴을 구현했다면, 메모리 낭비가 심해지는 문제를 쉽게 해결할 수 있습니다.</p>
<p>그러나, 이런 싱글톤 패턴에도 문제가 있습니다. 싱글톤 패턴을 직접 구현한다는 것은 결국 핵심 서비스 로직 외에도 추가적인 코드를 작성해야하는 비용이 드는 것이고, 의존 관계상 클라이언트가 구체 클래스(유일한 인스턴스)에 의존하게 됩니다. 이것은 DIP를 위반하게 되는 것으로 <a href="https://blog.coderoad.kr/solid" target="_blank" rel="noopener noreferer">SOLID</a>를 지키지 못한, 나쁜 객체지향 프로그래밍입니다. 또한 구체 클래스에 의존하게 됐기 때문에, OCP도 위반할 가능성이 높습니다.</p>
<p>메모리 낭비를 줄이겠다고 Spring의 근간부터 흔들리고 코드는 잔뜩 꼬여버리는 배보다 배꼽이 더 커져버린 상황이 발생합니다. Spring은 이런 문제를 해결하기 위해 **<a href="https://blog.coderoad.kr/containerandbean" target="_blank" rel="noopener noreferer">Spring 컨테이너</a>**에게 객체 인스턴스를 싱글톤으로 관리하도록 했습니다.</p>
<h2 id="싱글톤-컨테이너" class="heading">싱글톤 컨테이너</h2>
<p><strong>Spring 컨테이너는 싱글톤 컨테이너</strong>의 역할을 담당합니다. 다시 말해서, Spring 컨테이너가 관리하는 Spring 빈들은 모두 싱글톤 패턴으로 관리되는 인스턴스들입니다. 우리가 Spring 컨테이너에 대해 정리했을때, Spring 빈으로 등록한 객체들은 Spring 컨테이너가 인스턴스화하여 가지고 있다가 요청에 따라 의존관계를 주입해준다는 것을 알았습니다.</p>
<p>이렇게 싱글톤 객체를 생성하고 관리하는 기능을 **싱글톤 레지스트리(Singleton Registry)**라고 합니다. Spring 컨테이너의 이런 기능 덕분에 싱글톤 패턴을 직접 구현하면서 발생한 문제들을 해결하고도 인스턴스를 싱글톤으로 유지할 수 있습니다. 즉, 사용자의 요청이 애플리케이션으로 올 때 마다 인스턴스를 생성하는 것이 아니라 이미 만들어진 인스턴스(빈)을 공유해 효율적으로 재사용할 수 있게 된 것입니다.</p>
<p>물론, Spring의 빈 등록 방식은 다양합니다. 기본 방식이 싱글톤일 뿐, 다른 방식도 지정할 수 있습니다.</p>
<h2 id="싱글톤-방식의-주의점" class="heading">싱글톤 방식의 주의점</h2>
<p>싱글톤 방식을 사용할 때 너무나도 중요하고 명심해야하는 점은 Spring 빈을 설계할 때 **무상태(Stateless)**로 설계해야 한다는 것입니다. 싱글톤으로 관리되는 Spring 빈을 공유하는 사용자들은 인스턴스의 공유 가능한 값(클래스 변수)들도 동시다발적으로 접근 가능합니다. 만약 어떤 값을 유지하고 이를 중요 서비스 로직에 사용하도록 빈을 설계했다면 치명적인 오류가 발생할 수 있습니다.</p>
<p>예를 들어, 클래스 변수에 내가 주문한 금액을 저장해두고(Stateful) 이를 통해 은행 계좌에서 주문 금액만큼 인출되도록 서비스 객체를 설계했다고 가정합시다. 이 서비스 객체가 싱글톤 방식으로 관리되고 인스턴스를 모든 사용자가 공유한다면 클래스 변수도 당연히 모든 사용자가 공유하는 변수입니다. 이 변수에 나의 주문 금액을 저장해두어도 다른 사용자가 몇 초 차이로 나중에 주문 서비스를 이용하면 값이 <strong>덮어씌워질 수 있다</strong>는 것입니다.</p>
<p>만약, 난 10만원만 사용했는데 3초 뒤에 다시 주문 서비스를 이용한 사람이 100만원을 사용했고 내가 5초 뒤에 주문을 확정지었다면 나도 모르는 새에 주문 금액은 100만원으로 늘어나는 대형 사고가 발생하는 것입니다. 때문에, 무슨 일이 있어도 싱글톤 방식을 사용할 때는 무조건 무상태(Stateless), 공유 가능한 필드가 없도록 Spring 빈을 설계해야합니다.</p>
<h2 id="configuration" class="heading">@Configuration</h2>
<p>사실 Spring 컨테이너가 싱글톤 컨테이너의 역할을 할 수 있는 것은 <strong>@Configuration</strong> 어노테이션이 붙은 <strong>구성자</strong>, Java 설정 클래스 덕분입니다. 우리가 <strong>@Bean</strong> 어노테이션을 통해 Spring 빈으로 등록한 객체들은 @Configuration 어노테이션이 없으면 싱글톤이 보장되지 않습니다. 도대체 @Configuration에 무슨 비밀이 있길래 이 어노테이션만 붙이면 싱글톤이 보장되는 것일까요?</p>
<p>바로, @Configuration 어노테이션이 활용하는 <code>CGLIB</code>라는 기술에 있습니다. @Configuration 어노테이션은 <code>CGLIB</code> 기술을 통해 Java 설정 클래스에서 <strong>같은 객체를 여러번 <code>new</code> 키워드로 생성해도 처음 생성된 인스턴스를 활용</strong>하도록 <strong>바이트코드를 조작</strong>해 싱글톤을 보장합니다. 즉, 아무리 <code>new</code> 키워드를 여러번 사용해도 바이트코드 단계에서 <code>new</code> 키워드가 새로운 인스턴스를 만들지 않고 기존에 생성된 인스턴스를 반환하도록 합니다. 따라서 Spring 컨테이너가 싱글톤 방식을 사용하도록 하려면, Java 설정 클래스(구성자)에 @Configuration 어노테이션을 잊어선 안됩니다.</p>]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[SOLID]]></title>
    <link>https://blog.coderoad.kr/solid</link>
    <pubDate>2023-01-15</pubDate>
    <guid isPermaLink="false">https://blog.coderoad.kr/solid</guid>
    <description>
    <![CDATA[Spring과 SOLID]]>
    </description>
    <content:encoded>
      <![CDATA[<p><strong>본 문서는 인프런에서 수강할 수 있는 <a href="https://inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8" target="_blank" rel="noopener noreferer">스프링 핵심 원리 - 기본편</a>을 수강한 후, 공부한 내용을 정리한 문서입니다. 본 문서의 모든 저작권은 해당 강의의 저자이신 <a href="https://inflearn.com/users/@yh" target="_blank" rel="noopener noreferer">김영한</a> 우아한형제들 기술이사님께 있습니다.</strong></p>
<h2 id="solid" class="heading">SOLID?</h2>
<p>SOLID, 단단하다는 뜻을 가진 영단어입니다. Spring과 SOLID는 도대체 무슨 연관이 있을까요? 사실 Spring을 넘어 프로그래밍에서 <strong>SOLID는 객체 지향 프로그래밍 및 설계의 가장 기초적인 원칙 5가지</strong>의 앞 글자를 딴 단어입니다. 2000년대 초반, 미국의 소프트웨어 엔지니어인 로버트 마틴이 "<a href="http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod" target="_blank" rel="noopener noreferer">The Principles of OOD</a>"라는 제목의 블로그 게시글에서 5개의 원칙을 명명했습니다.</p>
<p>그 원칙들은 다음과 같습니다.</p>
<table>
    <tr>
        <th colspan="2">SOLID</th>
    </tr>
    <tr>
        <th>이름</th>
        <th>설명</th>
    </tr>
    <tr>
        <td>단일 책임 원칙</td>
        <td>SRP (Single Responsibility Principle)<br>한 클래스는 하나의 책임만 가져야 한다.</td>
    </tr>
    <tr>
        <td>개방-폐쇄 원칙</td>
        <td>OCP (Open/Closed Principle)<br>소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.</td>
    </tr>
    <tr>
        <td>리스코프 치환 원칙</td>
        <td>LSP (Liskov Substitution Principle)<br>프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스를 바꿀 수 있어야 한다.</td>
    </tr>
    <tr>
        <td>인터페이스 분리 원칙</td>
        <td>ISP (Interface Segregation Principle)<br>특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나 보다 낫다.</td>
    </tr>
    <tr>
        <td>의존관계 역전 원칙</td>
        <td>DIP (Dependency Inversion Principle)<br>프로그래머는 추상화에 의존해야하지 구체화에 의존하면 안된다. 의존관계 주입은 이 원칙을 따르는 방법 중 하나.</td>
    </tr>
</table>
<h2 id="단일-책임-원칙-srp" class="heading">단일 책임 원칙 (SRP)</h2>
<p><strong>단일 책임 원칙</strong>(Single Responsibility Principle)은 "한 클래스는 하나의 책임만 가져야 한다."라는 원칙입니다. 여기서 '하나의 책임'이라는 말이 모호할 수 있습니다. 책임은 클 수도 있고, 작을 수도 있으며, 문맥과 상황에 따라 다릅니다. 하지만 가장 중요한 것은 <strong>변경</strong>입니다. 즉, 우리는 "변경"을 기준으로 잡아 단일 책임 원칙이 준수되었는지 확인해야합니다.</p>
<p>예를 들어, 웹 애플리케이션에서 특정 기능을 수정하게 된 상황을 가정해보겠습니다. 기능의 수정이 생겼기 때문에 당연히 내부 코드에도 변경이 필요합니다. 이 때, 단 하나의 클래스만 수정되어야 SRP를 잘 준수한 프로그램이 되는 것입니다. 즉, 하나의 클래스가 하나의 기능(책임)을 가지기 때문에 다른 클래스(코드)에 영향을 주지 않고도 변경이 가능합니다.</p>
<h2 id="개방-폐쇄-원칙-ocp" class="heading">개방-폐쇄 원칙 (OCP)</h2>
<p><strong>개방-폐쇄 원칙</strong>(Open/Closed Principle)은 "소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다."라는 원칙입니다. 그런데 이름부터 모순되는 말입니다. 어떻게 개방과 폐쇄가 동시에 지켜질 수 있다는 말일까요? 애플리케이션을 확장하려면, 즉 기능을 추가하거나 수정하려면 당연히 기존의 코드를 변경해야하는 것 아닐까요? 이 질문의 답은 객체 지향 프로그래밍에서 가장 중요한 <strong>다형성</strong>에 있습니다.</p>
<p>우리가 앞서 살펴봤던 다형성을 활용하려면, <strong>역할</strong>과 <strong>구현</strong>으로 철저하게 구분지어서 설계해야한다고 했습니다. 잘 설계된 역할이 있다면 그 구현체를 새로 만드는 것은 기존 코드에 전혀 영향을 주지 않습니다. 다형성의 목적이 유연하고 변경이 용이하게 하는 것임을 기억한다면, 미리 적어둔 코드의 수정 없이도 완전히 새로운 기능을 추가(확장)하는 것이 가능합니다. 즉, 새로운 클래스를 작성하고 애플리케이션에 적용(확장)할 때 다른 클래스를 수정(변경)한다면 확장에도 열려있고 변경에도 열려있어 OCP를 위반하는 것입니다.</p>
<p>그럼 OCP를 준수하려면 어떻게 해야할까요? 지금까지 우리는 새로 만든 구현체를 적용시키려면 그 구현체를 사용하는 다른 구현체의 코드를 수정해야했습니다. 이제 우리는 새로운 구현체를 외부에서 생성, 조립, 설정까지 모두 해주는 설정자가 필요해졌습니다. 이 설정자를 통해 기존 코드의 수정이 없이 설정자만 변경했을 때 의도한대로 동작한다면 그 프로그램은 OCP를 준수한 것입니다. 이 "설정자"는 나중에 설명하겠지만 "Spring 컨테이너"라는 Spring에서 아주 중요한 역할을 맡게 됩니다.</p>
<h2 id="리스코프-치환-원칙-lsp" class="heading">리스코프 치환 원칙 (LSP)</h2>
<p><strong>리스코프 치환 원칙</strong>(Liskov Substitution Principle)은 "프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스를 바꿀 수 있어야 한다."는 원칙입니다. 쉽게 설명해서 자식 클래스는 부모 클래스를 언제든 완전히 대체할 수 있어야 한다는 원칙입니다. 즉, 부모 클래스의 기능이 자식 클래스에서 정반대가 되어버린다면 LSP가 지켜지지 않은 것입니다. 오류는 나지 않겠지만 다형성이 완전히 무너지게 됩니다.</p>
<p>예를 들어, 자동차 인터페이스의 악셀 메소드는 가속을 합니다. 모든 자동차는 악셀은 가속, 브레이크는 감속이라는 기능을 가지는데, 만약 어느 한 구현체(자동차)만 이 인터페이스와는 정반대로 악셀은 감속, 브레이크는 가속이라는 기능을 가지면 대참사가 발생할 가능성이 있습니다. 물론 만들 수는 있고 실제로 운전도 어렵겠지만 가능은 합니다. 그러나 이 예시에선 구현체(자식 클래스)가 인터페이스(부모 클래스)를 완전히 대체하지 못하고 있기 때문에 LSP를 위반하고 있습니다.</p>
<p>가장 지키기 쉬운 원칙 중에 하나입니다. 인터페이스를 설계한 목적 그대로 구현하면 됩니다.</p>
<h2 id="인터페이스-분리-원칙-isp" class="heading">인터페이스 분리 원칙 (ISP)</h2>
<p><strong>인터페이스 분리 원칙</strong>(Interface Segregation Principle)은 "특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다."는 원칙입니다. 쉽게 설명하면 인터페이스를 더 세세하게 분리하는 것이 좋다는 것입니다. 즉, 하나의 인터페이스가 가지는 책임(기능)이 과다할 때, 분리할 수 있는 책임(기능)이 있다면 따로 분리해두어야 합니다.</p>
<p>예를 들어, 자동차 인터페이스는 "운전"이라는 큰 관점으로 묶이는 기능들과 "정비"라는 큰 관점으로 묶이는 기능들로 분리할 수 있습니다. 또한 사용자 인터페이스도 "운전자"와 "정비사"로 나눌 수 있습니다. 그럼 정비 인터페이스가 변해도 운전자 구현체에는 전혀 영향을 주지 않게 됩니다. 만약 자동차 인터페이스를 ISP 원칙을 지키지 않았다면 정비 부분 기능들을 수정할 때 운전자 구현체에도 영향을 미칠 것입니다. 따라서 ISP를 준수하면 인터페이스가 좀 더 명확해지고 대체 가능성이 높아집니다.</p>
<h2 id="의존관계-역전-원칙-dip" class="heading">의존관계 역전 원칙 (DIP)</h2>
<p><strong>의존관계 역전 원칙</strong>(Dependency Inversion Principle)은 "프로그래머는 추상화에 의존해야지, 구체화에 의존하면 안 된다."는 원칙입니다. 의존관계 주입(Dependency Injection)은 이 원칙을 따르는 방법 중 하나입니다. 쉽게 이야기해서 DIP는 구현 클래스에 의존하지 말고, 역할인 인터페이스에 의존하라는 뜻입니다. 여기서 "의존한다."는 "알고 있다."와 같습니다. 즉, 클라이언트가 인터페이스<strong>만</strong> 의존해야(알고 있어야) DIP를 준수하는 것입니다. 만약 인터페이스 뿐만 아니라 구현 객체도 의존한다(알고 있다)면, 구현체를 변경해야할 때 해당 구현체를 의존하는(알고 있는) 코드를 모두 변경해야합니다.</p>
<p>DIP에 대해 더 자세히 알아보기 위해 다형성을 설명하면서 작성했던 코드를 다시 살펴보겠습니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token comment">//이 코드는 DIP를 위반합니다!</span>
</span><span class="code-line"><span class="token comment">//Car라는 인터페이스를 의존합니다. 그러나 NormalCar라는 구현체도 알고 있습니다.</span>
</span><span class="code-line"><span class="token class-name">Car</span> myCar <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NormalCar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token keyword">int</span> currentSpeed<span class="token punctuation">;</span>
</span><span class="code-line">currentSpeed <span class="token operator">=</span> myCar<span class="token punctuation">.</span><span class="token function">accelPedal</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">currentSpeed <span class="token operator">=</span> myCar<span class="token punctuation">.</span><span class="token function">breakPedal</span><span class="token punctuation">(</span>currentSpeed<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></code></pre>
<p>한 눈에봐도 추상화(인터페이스)와 구체화(구현 클래스)를 동시에 의존하고(알고) 있어 DIP를 위반했다는 것을 알 수 있습니다. DIP를 준수하려면 추상화에만 의존해야합니다. 그런데 만약 추상화만 의존하기 위해 위의 코드를 아래와 같이 고치면 예외가 발생할 것입니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token comment">//추상화만 의존하긴 하지만...</span>
</span><span class="code-line"><span class="token comment">//myCar에는 아무것도 들어가지 않았습니다.</span>
</span><span class="code-line"><span class="token class-name">Car</span> myCar<span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token keyword">int</span> currentSpeed<span class="token punctuation">;</span>
</span><span class="code-line">currentSpeed <span class="token operator">=</span> myCar<span class="token punctuation">.</span><span class="token function">accelPedal</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">currentSpeed <span class="token operator">=</span> myCar<span class="token punctuation">.</span><span class="token function">breakPedal</span><span class="token punctuation">(</span>currentSpeed<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></code></pre>
<p>DIP를 지키려고 했더니 동작조차 하지 않는 망가진 코드가 완성되어버렸습니다. 분명 유연하게 변경할 수는 있지만 SOLID를 준수하자니 무언가 부족합니다. 객체 지향의 핵심이라는 다형성만으로는 쉽게 부품을 갈아 끼우듯이 개발할 수 없다는 것을 깨달았습니다. 또한 구현 객체를 변경할 때 클라이언트의 코드도 변경되어버린다는 것도 알았습니다. 즉, 다형성만으로는 DIP와 OCP를 완벽하게 지킬 수 없다는 것을 알아버렸습니다! 그럼 어떻게 해야 SOLID를 준수하면서 객체 지향 프로그래밍을 할 수 있을까요? 정답은 바로 <strong>Spring</strong>에 있습니다.</p>
<h2 id="갑자기-spring" class="heading">갑자기 Spring?</h2>
<p>Spring이 제공하는 <strong>의존관계 주입(Dependency Injection, DI) 기술</strong>과 <strong>DI 컨테이너</strong>를 통해 다형성과 OCP, DIP를 지킬 수 있게 도와줍니다. 이러한 Spring의 기술들 덕분에 클라이언트의 코드의 변경 없이도 기능 확장이 가능해졌습니다. 그렇다고 Spring이 없던 시절에는 OCP, DIP를 준수하는게 불가능하진 않았습니다. 순수한 Java로 OCP, DIP를 준수하기 위해 작성한 코드들이 너무 많아지다보니 한 곳에 모아 프레임워크로 만든 것이 바로 <strong>Spring</strong>입니다. 우리가 OCP와 DIP를 준수하면서 개발을 해보면 결국엔 Spring의 핵심인 DI 컨테이너를 만들게 됩니다.</p>
<p><a href="https://blog.coderoad.kr/spring" target="_blank" rel="noopener noreferer">Spring</a> 포스트에서 Spring의 역사에 대해 알아보면서 Spring은 "좋은 객체 지향"을 위해 탄생한 프레임워크라고 설명했습니다. 좋은 객체 지향 프로그래밍을 위해서는 기초 중의 기초인 SOLID를 준수해야하고 Spring은 이를 쉽게 준수할 수 있도록 돕습니다. 따라서 Spring을 100% 활용하기 위해선 객체 지향 5원칙, SOLID를 반드시 공부해야합니다. 그렇지 않으면 Spring의 동작 원리부터 이해할 수 없기 때문입니다.</p>]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[Spring이란?]]></title>
    <link>https://blog.coderoad.kr/spring</link>
    <pubDate>2023-01-15</pubDate>
    <guid isPermaLink="false">https://blog.coderoad.kr/spring</guid>
    <description>
    <![CDATA[Spring 기초 정리]]>
    </description>
    <content:encoded>
      <![CDATA[<p><strong>본 문서는 인프런에서 수강할 수 있는 <a href="https://inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8" target="_blank" rel="noopener noreferer">스프링 핵심 원리 - 기본편</a>을 수강한 후, 공부한 내용을 정리한 문서입니다. 본 문서의 모든 저작권은 해당 강의의 저자이신 <a href="https://inflearn.com/users/@yh" target="_blank" rel="noopener noreferer">김영한</a> 우아한형제들 기술이사님께 있습니다.</strong></p>
<h2 id="spring" class="heading">Spring?</h2>
<p>흔히 Spring은 웹 애플리케이션을 쉽게 만들 수 있게 도와주는 프레임워크 정도로만 알려져있습니다. 그러나 Spring이 탄생하게된 계기를 알게된다면 Spring의 본질, 핵심 개념을 다음과 같이 말할 수 있습니다.</p>
<blockquote>
<p>"Spring은 <strong>좋은 객체 지향</strong> 애플리케이션을 개발할 수 있게 도와주는 프레임워크이다."</p>
</blockquote>
<p>물론 Spring은 웹 애플리케이션을 만드는데 정말 많은 도움을 주는 프레임워크가 맞습니다. 그러나 Spring이 탄생하게된 계기는 "좋은 객체 지향" 개발을 위해서였습니다. 그렇다면, 도대체 왜, 어떻게 만들어졌길래 Spring이 좋은 객체 지향 애플리케이션을 개발하는데 도움이 되는지 알아보겠습니다.</p>
<h2 id="spring의-탄생" class="heading">Spring의 탄생</h2>
<p>Spring은 2002년 <strong>로드 존슨</strong>(Rod Johnson)이라는 개발자가 써낸 <strong>Expert One-on-One J2EE Design and Development</strong>이라는 책에 나온 코드를 기반으로 발전한 프레임워크입니다. 2000년대 초반, 당시 기업들은 시스템을 구현하기 위한 서버 애플리케이션으로 Java의 가장 거대한 기술 표준이었던 J2EE의 API 중 하나인 <strong>Enterprise Java Beans</strong>(EJB)를 사용했습니다. 서버와 관련된 고급 기술들을 제공하던 종합 선물 세트 같은 느낌의 API였지만 큰 문제가 있었습니다. <strong>EJB는 느리고 어려웠습니다.</strong></p>
<p>EJB에서 지원하는 기술들은 원리를 파악하기도 힘들고 테스트를 통한 개발(추후에 정리할 테스트 주도 개발)도 매우 힘들었습니다. 또한 EJB를 이용해 개발할 때는 전적으로 EJB에 의존해서 개발을 해야했기에 Java의 가장 강력한 장점이자 정체성인 <strong>객체 지향 프로그래밍이 전혀 지켜지지 못할 정도</strong>로 코드가 난해하고 확장성이 떨어졌습니다. 이런 쉽지 않은 개발 환경 때문에 <strong>POJO</strong>(Plain Old Java Object)라는 용어까지 등장하며 **순수한 Java로 돌아가자!**라는 생각이 Java 개발자들 사이에서 많아졌습니다.</p>
<p>이때 등장한 것이 앞서 언급한 로드 존슨의 저서입니다. 로드 존슨은 해당 책에서 EJB의 문제점을 지적하며 EJB 없이 순수한 Java 코드로만 더 나은 프로그램을 만들 수 있다는 것을 보여줬습니다. 또한 이 코드들을 본 유겐 휠러(Juergen Hoeller)와 얀 카로프(Yann Caroff)가 로드 존슨에게 이 소스들을 오픈 소스 프로젝트로 발전시키자는 제안을 했고 마침내 <strong>Spring</strong>이 탄생하게 되었습니다. 현재도 유겐 휠러가 Spring Framework의 리드 개발자로서 Spring을 발전시키고 있습니다. 여담으로 Spring이라는 이름은 혹독한 겨울 같았던 Java 개발 생태계를 봄처럼 따뜻하게 만들었다는 의미로 지어졌습니다.</p>
<p>2003년 6월에 처음 공개된 XML 기반의 Spring Framework 1.0을 시작으로 2023년 1월 현재 최신 버전인 Spring Framework 6.0.4와 Spring의 치명적인 단점이었던 개발 사전 설정을 도와주는 Spring Boot 3.0.1까지 약 20년의 시간 동안 Spring은 꾸준히 발전해왔습니다.</p>
<h2 id="spring-생태계" class="heading">Spring 생태계</h2>
<p>Spring 생태계에는 사용자에게 다양한 기능을 제공해주는 많은 프로젝트들이 있습니다. Spring 생태계를 이루는 대표적인 프로젝트들은 다음과 같습니다.</p>
<ul>
<li>Spring Framework</li>
<li>Spring Boot</li>
<li>Spring Data</li>
<li>Spring Session</li>
<li>Spring Security</li>
<li>Spring Batch</li>
<li>Spring Cloud</li>
<li>Spring REST Docs</li>
</ul>
<p>이외에도 많은 프로젝트들을 Spring 공식 페이지에서 확인할 수 있습니다. <a href="https://spring.io/projects" target="_blank" rel="noopener noreferer">Spring Projects</a></p>
<p>이렇게 많은 Spring 프로젝트 중에서 필수적인 두 가지는 Spring 그 자체라고 할 수 있는 <strong>Spring Framework</strong>와 모든 Spring 기술들을 편리하게 사용할 수 있도록 도와주는 <strong>Spring Boot</strong>입니다. Spring Framework 없이는 위에 적어둔 다른 기술들을 사용할 수 없습니다. 또한 본격적인 개발을 시작하기 전에 프로젝트 설정하기가 Spring의 절반이라고 할 수 있을 정도로 Spring Boot는 요즘 Spring Framework를 사용할 때 항상 함께 사용합니다.</p>
<p>가장 중요한 두 프로젝트의 특징들을 살펴보겠습니다.</p>
<ul>
<li><strong>Spring Framework</strong>
<ul>
<li>Spring의 뿌리</li>
<li>핵심 기술 - Spring DI Container, AOP, Event, etc...</li>
<li>웹 기술 - Spring MVC, Spring WebFlux</li>
<li>데이터 접근 기술 - Transaction, JDBC, ORM, XML</li>
</ul>
</li>
<li><strong>Spring Boot</strong>
<ul>
<li>단독으로 실행할 수 있는 Spring Application을 쉽게 생성</li>
<li>Tomcat과 같은 웹 서버를 내장해 별도의 웹 서버 설치 필요 없음</li>
<li>손쉬운 빌드 구성을 위한 starter 종속성 제공 (starter만 가져오면 자동으로 관련 의존관계 모두 설정)</li>
<li>스프링과 서드 파티(외부) 라이브러리 자동 구성 (주요 라이브러리의 호환성을 자동으로 검사하고 호환이 잘되는 버전을 탑재)</li>
<li>메트릭, 상태 확인, 외부 구성 같은 프로덕션 준비 기능 제공 (운영 환경에서의 모니터링 등)</li>
<li>관례에 의한 간결한 설정</li>
</ul>
</li>
</ul>
<p>위에서 살펴본대로 Spring Framework는 웹 기술 뿐만 아니라 다른 많은 기술들도 제공합니다. 또한 Spring Boot가 제공하는 많은 편의 기능들은 만약 Spring Boot가 없었다면 사용자가 직접 해야하는 작업이 얼마나 많은지 알 수 있게 해줍니다.</p>
<h2 id="spring의-핵심-개념" class="heading">Spring의 핵심 개념</h2>
<p>지금까지 Spring에 관해서 대략적으로 살펴봤습니다. 처음으로 돌아가, Spring의 본질이자 핵심 개념은 웹 애플리케이션을 쉽게 만들 수 있게 도와주는 프레임워크가 아니라고 말했습니다.</p>
<p>Spring이 탄생하게된 계기였던 로드 존슨의 저서도 Java의 EJB를 개선하고자 써내려갔고, 개발자들이 "순수한 Java"(POJO)로 더 나은 서버 프로그래밍을 위해 발전시켜온 것이 Spring이기에 웹 애플리케이션 제작에 큰 도움이 되는 것은 사실입니다. 그러나 Spring은 웹 애플리케이션에 국한되지 않고 <strong>더 빠르고, 더 쉽고, 더 안전한 Java 프로그래밍</strong>을 도와준다고 설명해왔습니다. <a href="https://spring.io/why-spring" target="_blank" rel="noopener noreferer">Why Spring?</a></p>
<p>즉, <strong>Spring의 정수는 더 나은 Java 프로그래밍, "좋은 객체 지향" 프로그래밍</strong>인 것입니다. 따라서 Spring을 완벽하게 이해하고, 활용하기 위해서는 Java의 핵심인 "객체 지향 프로그래밍"에 대한 이해가 필요합니다. Spring이 제공하는 API만 따라치기 급급한 개발자가 아닌 Spring을 통해 더 나은 애플리케이션을 만들어낼 수 있는 개발자가 되어야합니다.</p>
<p>Spring이 EJB의 과도한 의존관계를 비판하며 탄생했던 것처럼, 우리 역시 Spring이 주는 편의성에 의존하지 않아야합니다. 부가적인 기술이 아닌, 더 좋은 객체 지향 프로그래밍을 위해 Spring을 활용해야하는 것입니다.</p>]]>
    </content:encoded>
  </item>
    </channel>
  </rss>